/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import * as $protobuf from "protobufjs/minimal";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const proto = $root.proto = (() => {

    /**
     * Namespace proto.
     * @exports proto
     * @namespace
     */
    const proto = {};

    proto.TokenUnitBalance = (function() {

        /**
         * Properties of a TokenUnitBalance.
         * @memberof proto
         * @interface ITokenUnitBalance
         * @property {proto.ITokenID|null} [tokenId] TokenUnitBalance tokenId
         * @property {Long|null} [balance] TokenUnitBalance balance
         */

        /**
         * Constructs a new TokenUnitBalance.
         * @memberof proto
         * @classdesc Represents a TokenUnitBalance.
         * @implements ITokenUnitBalance
         * @constructor
         * @param {proto.ITokenUnitBalance=} [p] Properties to set
         */
        function TokenUnitBalance(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TokenUnitBalance tokenId.
         * @member {proto.ITokenID|null|undefined} tokenId
         * @memberof proto.TokenUnitBalance
         * @instance
         */
        TokenUnitBalance.prototype.tokenId = null;

        /**
         * TokenUnitBalance balance.
         * @member {Long} balance
         * @memberof proto.TokenUnitBalance
         * @instance
         */
        TokenUnitBalance.prototype.balance = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new TokenUnitBalance instance using the specified properties.
         * @function create
         * @memberof proto.TokenUnitBalance
         * @static
         * @param {proto.ITokenUnitBalance=} [properties] Properties to set
         * @returns {proto.TokenUnitBalance} TokenUnitBalance instance
         */
        TokenUnitBalance.create = function create(properties) {
            return new TokenUnitBalance(properties);
        };

        /**
         * Encodes the specified TokenUnitBalance message. Does not implicitly {@link proto.TokenUnitBalance.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenUnitBalance
         * @static
         * @param {proto.ITokenUnitBalance} m TokenUnitBalance message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenUnitBalance.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.tokenId != null && Object.hasOwnProperty.call(m, "tokenId"))
                $root.proto.TokenID.encode(m.tokenId, w.uint32(10).fork()).ldelim();
            if (m.balance != null && Object.hasOwnProperty.call(m, "balance"))
                w.uint32(16).uint64(m.balance);
            return w;
        };

        /**
         * Decodes a TokenUnitBalance message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenUnitBalance
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenUnitBalance} TokenUnitBalance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenUnitBalance.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenUnitBalance();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.tokenId = $root.proto.TokenID.decode(r, r.uint32());
                    break;
                case 2:
                    m.balance = r.uint64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TokenUnitBalance;
    })();

    proto.SingleAccountBalances = (function() {

        /**
         * Properties of a SingleAccountBalances.
         * @memberof proto
         * @interface ISingleAccountBalances
         * @property {proto.IAccountID|null} [accountID] SingleAccountBalances accountID
         * @property {Long|null} [hbarBalance] SingleAccountBalances hbarBalance
         * @property {Array.<proto.ITokenUnitBalance>|null} [tokenUnitBalances] SingleAccountBalances tokenUnitBalances
         */

        /**
         * Constructs a new SingleAccountBalances.
         * @memberof proto
         * @classdesc Represents a SingleAccountBalances.
         * @implements ISingleAccountBalances
         * @constructor
         * @param {proto.ISingleAccountBalances=} [p] Properties to set
         */
        function SingleAccountBalances(p) {
            this.tokenUnitBalances = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * SingleAccountBalances accountID.
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.SingleAccountBalances
         * @instance
         */
        SingleAccountBalances.prototype.accountID = null;

        /**
         * SingleAccountBalances hbarBalance.
         * @member {Long} hbarBalance
         * @memberof proto.SingleAccountBalances
         * @instance
         */
        SingleAccountBalances.prototype.hbarBalance = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SingleAccountBalances tokenUnitBalances.
         * @member {Array.<proto.ITokenUnitBalance>} tokenUnitBalances
         * @memberof proto.SingleAccountBalances
         * @instance
         */
        SingleAccountBalances.prototype.tokenUnitBalances = $util.emptyArray;

        /**
         * Creates a new SingleAccountBalances instance using the specified properties.
         * @function create
         * @memberof proto.SingleAccountBalances
         * @static
         * @param {proto.ISingleAccountBalances=} [properties] Properties to set
         * @returns {proto.SingleAccountBalances} SingleAccountBalances instance
         */
        SingleAccountBalances.create = function create(properties) {
            return new SingleAccountBalances(properties);
        };

        /**
         * Encodes the specified SingleAccountBalances message. Does not implicitly {@link proto.SingleAccountBalances.verify|verify} messages.
         * @function encode
         * @memberof proto.SingleAccountBalances
         * @static
         * @param {proto.ISingleAccountBalances} m SingleAccountBalances message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SingleAccountBalances.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(10).fork()).ldelim();
            if (m.hbarBalance != null && Object.hasOwnProperty.call(m, "hbarBalance"))
                w.uint32(16).uint64(m.hbarBalance);
            if (m.tokenUnitBalances != null && m.tokenUnitBalances.length) {
                for (var i = 0; i < m.tokenUnitBalances.length; ++i)
                    $root.proto.TokenUnitBalance.encode(m.tokenUnitBalances[i], w.uint32(26).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a SingleAccountBalances message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SingleAccountBalances
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.SingleAccountBalances} SingleAccountBalances
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SingleAccountBalances.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.SingleAccountBalances();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 2:
                    m.hbarBalance = r.uint64();
                    break;
                case 3:
                    if (!(m.tokenUnitBalances && m.tokenUnitBalances.length))
                        m.tokenUnitBalances = [];
                    m.tokenUnitBalances.push($root.proto.TokenUnitBalance.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return SingleAccountBalances;
    })();

    proto.AllAccountBalances = (function() {

        /**
         * Properties of an AllAccountBalances.
         * @memberof proto
         * @interface IAllAccountBalances
         * @property {proto.ITimestamp|null} [consensusTimestamp] AllAccountBalances consensusTimestamp
         * @property {Array.<proto.ISingleAccountBalances>|null} [allAccounts] AllAccountBalances allAccounts
         */

        /**
         * Constructs a new AllAccountBalances.
         * @memberof proto
         * @classdesc Represents an AllAccountBalances.
         * @implements IAllAccountBalances
         * @constructor
         * @param {proto.IAllAccountBalances=} [p] Properties to set
         */
        function AllAccountBalances(p) {
            this.allAccounts = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * AllAccountBalances consensusTimestamp.
         * @member {proto.ITimestamp|null|undefined} consensusTimestamp
         * @memberof proto.AllAccountBalances
         * @instance
         */
        AllAccountBalances.prototype.consensusTimestamp = null;

        /**
         * AllAccountBalances allAccounts.
         * @member {Array.<proto.ISingleAccountBalances>} allAccounts
         * @memberof proto.AllAccountBalances
         * @instance
         */
        AllAccountBalances.prototype.allAccounts = $util.emptyArray;

        /**
         * Creates a new AllAccountBalances instance using the specified properties.
         * @function create
         * @memberof proto.AllAccountBalances
         * @static
         * @param {proto.IAllAccountBalances=} [properties] Properties to set
         * @returns {proto.AllAccountBalances} AllAccountBalances instance
         */
        AllAccountBalances.create = function create(properties) {
            return new AllAccountBalances(properties);
        };

        /**
         * Encodes the specified AllAccountBalances message. Does not implicitly {@link proto.AllAccountBalances.verify|verify} messages.
         * @function encode
         * @memberof proto.AllAccountBalances
         * @static
         * @param {proto.IAllAccountBalances} m AllAccountBalances message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AllAccountBalances.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.consensusTimestamp != null && Object.hasOwnProperty.call(m, "consensusTimestamp"))
                $root.proto.Timestamp.encode(m.consensusTimestamp, w.uint32(10).fork()).ldelim();
            if (m.allAccounts != null && m.allAccounts.length) {
                for (var i = 0; i < m.allAccounts.length; ++i)
                    $root.proto.SingleAccountBalances.encode(m.allAccounts[i], w.uint32(18).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes an AllAccountBalances message from the specified reader or buffer.
         * @function decode
         * @memberof proto.AllAccountBalances
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.AllAccountBalances} AllAccountBalances
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AllAccountBalances.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.AllAccountBalances();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.consensusTimestamp = $root.proto.Timestamp.decode(r, r.uint32());
                    break;
                case 2:
                    if (!(m.allAccounts && m.allAccounts.length))
                        m.allAccounts = [];
                    m.allAccounts.push($root.proto.SingleAccountBalances.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return AllAccountBalances;
    })();

    proto.ShardID = (function() {

        /**
         * Properties of a ShardID.
         * @memberof proto
         * @interface IShardID
         * @property {Long|null} [shardNum] ShardID shardNum
         */

        /**
         * Constructs a new ShardID.
         * @memberof proto
         * @classdesc Represents a ShardID.
         * @implements IShardID
         * @constructor
         * @param {proto.IShardID=} [p] Properties to set
         */
        function ShardID(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ShardID shardNum.
         * @member {Long} shardNum
         * @memberof proto.ShardID
         * @instance
         */
        ShardID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ShardID instance using the specified properties.
         * @function create
         * @memberof proto.ShardID
         * @static
         * @param {proto.IShardID=} [properties] Properties to set
         * @returns {proto.ShardID} ShardID instance
         */
        ShardID.create = function create(properties) {
            return new ShardID(properties);
        };

        /**
         * Encodes the specified ShardID message. Does not implicitly {@link proto.ShardID.verify|verify} messages.
         * @function encode
         * @memberof proto.ShardID
         * @static
         * @param {proto.IShardID} m ShardID message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShardID.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.shardNum != null && Object.hasOwnProperty.call(m, "shardNum"))
                w.uint32(8).int64(m.shardNum);
            return w;
        };

        /**
         * Decodes a ShardID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ShardID
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ShardID} ShardID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShardID.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ShardID();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.shardNum = r.int64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ShardID;
    })();

    proto.RealmID = (function() {

        /**
         * Properties of a RealmID.
         * @memberof proto
         * @interface IRealmID
         * @property {Long|null} [shardNum] RealmID shardNum
         * @property {Long|null} [realmNum] RealmID realmNum
         */

        /**
         * Constructs a new RealmID.
         * @memberof proto
         * @classdesc Represents a RealmID.
         * @implements IRealmID
         * @constructor
         * @param {proto.IRealmID=} [p] Properties to set
         */
        function RealmID(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * RealmID shardNum.
         * @member {Long} shardNum
         * @memberof proto.RealmID
         * @instance
         */
        RealmID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RealmID realmNum.
         * @member {Long} realmNum
         * @memberof proto.RealmID
         * @instance
         */
        RealmID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new RealmID instance using the specified properties.
         * @function create
         * @memberof proto.RealmID
         * @static
         * @param {proto.IRealmID=} [properties] Properties to set
         * @returns {proto.RealmID} RealmID instance
         */
        RealmID.create = function create(properties) {
            return new RealmID(properties);
        };

        /**
         * Encodes the specified RealmID message. Does not implicitly {@link proto.RealmID.verify|verify} messages.
         * @function encode
         * @memberof proto.RealmID
         * @static
         * @param {proto.IRealmID} m RealmID message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RealmID.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.shardNum != null && Object.hasOwnProperty.call(m, "shardNum"))
                w.uint32(8).int64(m.shardNum);
            if (m.realmNum != null && Object.hasOwnProperty.call(m, "realmNum"))
                w.uint32(16).int64(m.realmNum);
            return w;
        };

        /**
         * Decodes a RealmID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.RealmID
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.RealmID} RealmID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RealmID.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.RealmID();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.shardNum = r.int64();
                    break;
                case 2:
                    m.realmNum = r.int64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return RealmID;
    })();

    proto.AccountID = (function() {

        /**
         * Properties of an AccountID.
         * @memberof proto
         * @interface IAccountID
         * @property {Long|null} [shardNum] AccountID shardNum
         * @property {Long|null} [realmNum] AccountID realmNum
         * @property {Long|null} [accountNum] AccountID accountNum
         */

        /**
         * Constructs a new AccountID.
         * @memberof proto
         * @classdesc Represents an AccountID.
         * @implements IAccountID
         * @constructor
         * @param {proto.IAccountID=} [p] Properties to set
         */
        function AccountID(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * AccountID shardNum.
         * @member {Long} shardNum
         * @memberof proto.AccountID
         * @instance
         */
        AccountID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AccountID realmNum.
         * @member {Long} realmNum
         * @memberof proto.AccountID
         * @instance
         */
        AccountID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AccountID accountNum.
         * @member {Long} accountNum
         * @memberof proto.AccountID
         * @instance
         */
        AccountID.prototype.accountNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new AccountID instance using the specified properties.
         * @function create
         * @memberof proto.AccountID
         * @static
         * @param {proto.IAccountID=} [properties] Properties to set
         * @returns {proto.AccountID} AccountID instance
         */
        AccountID.create = function create(properties) {
            return new AccountID(properties);
        };

        /**
         * Encodes the specified AccountID message. Does not implicitly {@link proto.AccountID.verify|verify} messages.
         * @function encode
         * @memberof proto.AccountID
         * @static
         * @param {proto.IAccountID} m AccountID message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountID.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.shardNum != null && Object.hasOwnProperty.call(m, "shardNum"))
                w.uint32(8).int64(m.shardNum);
            if (m.realmNum != null && Object.hasOwnProperty.call(m, "realmNum"))
                w.uint32(16).int64(m.realmNum);
            if (m.accountNum != null && Object.hasOwnProperty.call(m, "accountNum"))
                w.uint32(24).int64(m.accountNum);
            return w;
        };

        /**
         * Decodes an AccountID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.AccountID
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.AccountID} AccountID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountID.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.AccountID();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.shardNum = r.int64();
                    break;
                case 2:
                    m.realmNum = r.int64();
                    break;
                case 3:
                    m.accountNum = r.int64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return AccountID;
    })();

    proto.FileID = (function() {

        /**
         * Properties of a FileID.
         * @memberof proto
         * @interface IFileID
         * @property {Long|null} [shardNum] FileID shardNum
         * @property {Long|null} [realmNum] FileID realmNum
         * @property {Long|null} [fileNum] FileID fileNum
         */

        /**
         * Constructs a new FileID.
         * @memberof proto
         * @classdesc Represents a FileID.
         * @implements IFileID
         * @constructor
         * @param {proto.IFileID=} [p] Properties to set
         */
        function FileID(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * FileID shardNum.
         * @member {Long} shardNum
         * @memberof proto.FileID
         * @instance
         */
        FileID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FileID realmNum.
         * @member {Long} realmNum
         * @memberof proto.FileID
         * @instance
         */
        FileID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FileID fileNum.
         * @member {Long} fileNum
         * @memberof proto.FileID
         * @instance
         */
        FileID.prototype.fileNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new FileID instance using the specified properties.
         * @function create
         * @memberof proto.FileID
         * @static
         * @param {proto.IFileID=} [properties] Properties to set
         * @returns {proto.FileID} FileID instance
         */
        FileID.create = function create(properties) {
            return new FileID(properties);
        };

        /**
         * Encodes the specified FileID message. Does not implicitly {@link proto.FileID.verify|verify} messages.
         * @function encode
         * @memberof proto.FileID
         * @static
         * @param {proto.IFileID} m FileID message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileID.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.shardNum != null && Object.hasOwnProperty.call(m, "shardNum"))
                w.uint32(8).int64(m.shardNum);
            if (m.realmNum != null && Object.hasOwnProperty.call(m, "realmNum"))
                w.uint32(16).int64(m.realmNum);
            if (m.fileNum != null && Object.hasOwnProperty.call(m, "fileNum"))
                w.uint32(24).int64(m.fileNum);
            return w;
        };

        /**
         * Decodes a FileID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileID
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FileID} FileID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileID.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.FileID();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.shardNum = r.int64();
                    break;
                case 2:
                    m.realmNum = r.int64();
                    break;
                case 3:
                    m.fileNum = r.int64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return FileID;
    })();

    proto.ContractID = (function() {

        /**
         * Properties of a ContractID.
         * @memberof proto
         * @interface IContractID
         * @property {Long|null} [shardNum] ContractID shardNum
         * @property {Long|null} [realmNum] ContractID realmNum
         * @property {Long|null} [contractNum] ContractID contractNum
         */

        /**
         * Constructs a new ContractID.
         * @memberof proto
         * @classdesc Represents a ContractID.
         * @implements IContractID
         * @constructor
         * @param {proto.IContractID=} [p] Properties to set
         */
        function ContractID(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ContractID shardNum.
         * @member {Long} shardNum
         * @memberof proto.ContractID
         * @instance
         */
        ContractID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ContractID realmNum.
         * @member {Long} realmNum
         * @memberof proto.ContractID
         * @instance
         */
        ContractID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ContractID contractNum.
         * @member {Long} contractNum
         * @memberof proto.ContractID
         * @instance
         */
        ContractID.prototype.contractNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ContractID instance using the specified properties.
         * @function create
         * @memberof proto.ContractID
         * @static
         * @param {proto.IContractID=} [properties] Properties to set
         * @returns {proto.ContractID} ContractID instance
         */
        ContractID.create = function create(properties) {
            return new ContractID(properties);
        };

        /**
         * Encodes the specified ContractID message. Does not implicitly {@link proto.ContractID.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractID
         * @static
         * @param {proto.IContractID} m ContractID message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractID.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.shardNum != null && Object.hasOwnProperty.call(m, "shardNum"))
                w.uint32(8).int64(m.shardNum);
            if (m.realmNum != null && Object.hasOwnProperty.call(m, "realmNum"))
                w.uint32(16).int64(m.realmNum);
            if (m.contractNum != null && Object.hasOwnProperty.call(m, "contractNum"))
                w.uint32(24).int64(m.contractNum);
            return w;
        };

        /**
         * Decodes a ContractID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractID
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractID} ContractID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractID.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ContractID();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.shardNum = r.int64();
                    break;
                case 2:
                    m.realmNum = r.int64();
                    break;
                case 3:
                    m.contractNum = r.int64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ContractID;
    })();

    proto.TransactionID = (function() {

        /**
         * Properties of a TransactionID.
         * @memberof proto
         * @interface ITransactionID
         * @property {proto.ITimestamp|null} [transactionValidStart] TransactionID transactionValidStart
         * @property {proto.IAccountID|null} [accountID] TransactionID accountID
         * @property {boolean|null} [scheduled] TransactionID scheduled
         */

        /**
         * Constructs a new TransactionID.
         * @memberof proto
         * @classdesc Represents a TransactionID.
         * @implements ITransactionID
         * @constructor
         * @param {proto.ITransactionID=} [p] Properties to set
         */
        function TransactionID(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TransactionID transactionValidStart.
         * @member {proto.ITimestamp|null|undefined} transactionValidStart
         * @memberof proto.TransactionID
         * @instance
         */
        TransactionID.prototype.transactionValidStart = null;

        /**
         * TransactionID accountID.
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.TransactionID
         * @instance
         */
        TransactionID.prototype.accountID = null;

        /**
         * TransactionID scheduled.
         * @member {boolean} scheduled
         * @memberof proto.TransactionID
         * @instance
         */
        TransactionID.prototype.scheduled = false;

        /**
         * Creates a new TransactionID instance using the specified properties.
         * @function create
         * @memberof proto.TransactionID
         * @static
         * @param {proto.ITransactionID=} [properties] Properties to set
         * @returns {proto.TransactionID} TransactionID instance
         */
        TransactionID.create = function create(properties) {
            return new TransactionID(properties);
        };

        /**
         * Encodes the specified TransactionID message. Does not implicitly {@link proto.TransactionID.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionID
         * @static
         * @param {proto.ITransactionID} m TransactionID message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionID.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.transactionValidStart != null && Object.hasOwnProperty.call(m, "transactionValidStart"))
                $root.proto.Timestamp.encode(m.transactionValidStart, w.uint32(10).fork()).ldelim();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
            if (m.scheduled != null && Object.hasOwnProperty.call(m, "scheduled"))
                w.uint32(24).bool(m.scheduled);
            return w;
        };

        /**
         * Decodes a TransactionID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionID
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionID} TransactionID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionID.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TransactionID();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.transactionValidStart = $root.proto.Timestamp.decode(r, r.uint32());
                    break;
                case 2:
                    m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 3:
                    m.scheduled = r.bool();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TransactionID;
    })();

    proto.AccountAmount = (function() {

        /**
         * Properties of an AccountAmount.
         * @memberof proto
         * @interface IAccountAmount
         * @property {proto.IAccountID|null} [accountID] AccountAmount accountID
         * @property {Long|null} [amount] AccountAmount amount
         */

        /**
         * Constructs a new AccountAmount.
         * @memberof proto
         * @classdesc Represents an AccountAmount.
         * @implements IAccountAmount
         * @constructor
         * @param {proto.IAccountAmount=} [p] Properties to set
         */
        function AccountAmount(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * AccountAmount accountID.
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.AccountAmount
         * @instance
         */
        AccountAmount.prototype.accountID = null;

        /**
         * AccountAmount amount.
         * @member {Long} amount
         * @memberof proto.AccountAmount
         * @instance
         */
        AccountAmount.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new AccountAmount instance using the specified properties.
         * @function create
         * @memberof proto.AccountAmount
         * @static
         * @param {proto.IAccountAmount=} [properties] Properties to set
         * @returns {proto.AccountAmount} AccountAmount instance
         */
        AccountAmount.create = function create(properties) {
            return new AccountAmount(properties);
        };

        /**
         * Encodes the specified AccountAmount message. Does not implicitly {@link proto.AccountAmount.verify|verify} messages.
         * @function encode
         * @memberof proto.AccountAmount
         * @static
         * @param {proto.IAccountAmount} m AccountAmount message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountAmount.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(10).fork()).ldelim();
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                w.uint32(16).sint64(m.amount);
            return w;
        };

        /**
         * Decodes an AccountAmount message from the specified reader or buffer.
         * @function decode
         * @memberof proto.AccountAmount
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.AccountAmount} AccountAmount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountAmount.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.AccountAmount();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 2:
                    m.amount = r.sint64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return AccountAmount;
    })();

    proto.TransferList = (function() {

        /**
         * Properties of a TransferList.
         * @memberof proto
         * @interface ITransferList
         * @property {Array.<proto.IAccountAmount>|null} [accountAmounts] TransferList accountAmounts
         */

        /**
         * Constructs a new TransferList.
         * @memberof proto
         * @classdesc Represents a TransferList.
         * @implements ITransferList
         * @constructor
         * @param {proto.ITransferList=} [p] Properties to set
         */
        function TransferList(p) {
            this.accountAmounts = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TransferList accountAmounts.
         * @member {Array.<proto.IAccountAmount>} accountAmounts
         * @memberof proto.TransferList
         * @instance
         */
        TransferList.prototype.accountAmounts = $util.emptyArray;

        /**
         * Creates a new TransferList instance using the specified properties.
         * @function create
         * @memberof proto.TransferList
         * @static
         * @param {proto.ITransferList=} [properties] Properties to set
         * @returns {proto.TransferList} TransferList instance
         */
        TransferList.create = function create(properties) {
            return new TransferList(properties);
        };

        /**
         * Encodes the specified TransferList message. Does not implicitly {@link proto.TransferList.verify|verify} messages.
         * @function encode
         * @memberof proto.TransferList
         * @static
         * @param {proto.ITransferList} m TransferList message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransferList.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.accountAmounts != null && m.accountAmounts.length) {
                for (var i = 0; i < m.accountAmounts.length; ++i)
                    $root.proto.AccountAmount.encode(m.accountAmounts[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TransferList message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransferList
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransferList} TransferList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransferList.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TransferList();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    if (!(m.accountAmounts && m.accountAmounts.length))
                        m.accountAmounts = [];
                    m.accountAmounts.push($root.proto.AccountAmount.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TransferList;
    })();

    proto.NftTransfer = (function() {

        /**
         * Properties of a NftTransfer.
         * @memberof proto
         * @interface INftTransfer
         * @property {proto.IAccountID|null} [senderAccountID] NftTransfer senderAccountID
         * @property {proto.IAccountID|null} [receiverAccountID] NftTransfer receiverAccountID
         * @property {Long|null} [serialNumber] NftTransfer serialNumber
         */

        /**
         * Constructs a new NftTransfer.
         * @memberof proto
         * @classdesc Represents a NftTransfer.
         * @implements INftTransfer
         * @constructor
         * @param {proto.INftTransfer=} [p] Properties to set
         */
        function NftTransfer(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * NftTransfer senderAccountID.
         * @member {proto.IAccountID|null|undefined} senderAccountID
         * @memberof proto.NftTransfer
         * @instance
         */
        NftTransfer.prototype.senderAccountID = null;

        /**
         * NftTransfer receiverAccountID.
         * @member {proto.IAccountID|null|undefined} receiverAccountID
         * @memberof proto.NftTransfer
         * @instance
         */
        NftTransfer.prototype.receiverAccountID = null;

        /**
         * NftTransfer serialNumber.
         * @member {Long} serialNumber
         * @memberof proto.NftTransfer
         * @instance
         */
        NftTransfer.prototype.serialNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new NftTransfer instance using the specified properties.
         * @function create
         * @memberof proto.NftTransfer
         * @static
         * @param {proto.INftTransfer=} [properties] Properties to set
         * @returns {proto.NftTransfer} NftTransfer instance
         */
        NftTransfer.create = function create(properties) {
            return new NftTransfer(properties);
        };

        /**
         * Encodes the specified NftTransfer message. Does not implicitly {@link proto.NftTransfer.verify|verify} messages.
         * @function encode
         * @memberof proto.NftTransfer
         * @static
         * @param {proto.INftTransfer} m NftTransfer message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NftTransfer.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.senderAccountID != null && Object.hasOwnProperty.call(m, "senderAccountID"))
                $root.proto.AccountID.encode(m.senderAccountID, w.uint32(10).fork()).ldelim();
            if (m.receiverAccountID != null && Object.hasOwnProperty.call(m, "receiverAccountID"))
                $root.proto.AccountID.encode(m.receiverAccountID, w.uint32(18).fork()).ldelim();
            if (m.serialNumber != null && Object.hasOwnProperty.call(m, "serialNumber"))
                w.uint32(24).int64(m.serialNumber);
            return w;
        };

        /**
         * Decodes a NftTransfer message from the specified reader or buffer.
         * @function decode
         * @memberof proto.NftTransfer
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.NftTransfer} NftTransfer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NftTransfer.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.NftTransfer();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.senderAccountID = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 2:
                    m.receiverAccountID = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 3:
                    m.serialNumber = r.int64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return NftTransfer;
    })();

    proto.TokenTransferList = (function() {

        /**
         * Properties of a TokenTransferList.
         * @memberof proto
         * @interface ITokenTransferList
         * @property {proto.ITokenID|null} [token] TokenTransferList token
         * @property {Array.<proto.IAccountAmount>|null} [transfers] TokenTransferList transfers
         * @property {Array.<proto.INftTransfer>|null} [nftTransfers] TokenTransferList nftTransfers
         */

        /**
         * Constructs a new TokenTransferList.
         * @memberof proto
         * @classdesc Represents a TokenTransferList.
         * @implements ITokenTransferList
         * @constructor
         * @param {proto.ITokenTransferList=} [p] Properties to set
         */
        function TokenTransferList(p) {
            this.transfers = [];
            this.nftTransfers = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TokenTransferList token.
         * @member {proto.ITokenID|null|undefined} token
         * @memberof proto.TokenTransferList
         * @instance
         */
        TokenTransferList.prototype.token = null;

        /**
         * TokenTransferList transfers.
         * @member {Array.<proto.IAccountAmount>} transfers
         * @memberof proto.TokenTransferList
         * @instance
         */
        TokenTransferList.prototype.transfers = $util.emptyArray;

        /**
         * TokenTransferList nftTransfers.
         * @member {Array.<proto.INftTransfer>} nftTransfers
         * @memberof proto.TokenTransferList
         * @instance
         */
        TokenTransferList.prototype.nftTransfers = $util.emptyArray;

        /**
         * Creates a new TokenTransferList instance using the specified properties.
         * @function create
         * @memberof proto.TokenTransferList
         * @static
         * @param {proto.ITokenTransferList=} [properties] Properties to set
         * @returns {proto.TokenTransferList} TokenTransferList instance
         */
        TokenTransferList.create = function create(properties) {
            return new TokenTransferList(properties);
        };

        /**
         * Encodes the specified TokenTransferList message. Does not implicitly {@link proto.TokenTransferList.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenTransferList
         * @static
         * @param {proto.ITokenTransferList} m TokenTransferList message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenTransferList.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.token != null && Object.hasOwnProperty.call(m, "token"))
                $root.proto.TokenID.encode(m.token, w.uint32(10).fork()).ldelim();
            if (m.transfers != null && m.transfers.length) {
                for (var i = 0; i < m.transfers.length; ++i)
                    $root.proto.AccountAmount.encode(m.transfers[i], w.uint32(18).fork()).ldelim();
            }
            if (m.nftTransfers != null && m.nftTransfers.length) {
                for (var i = 0; i < m.nftTransfers.length; ++i)
                    $root.proto.NftTransfer.encode(m.nftTransfers[i], w.uint32(26).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TokenTransferList message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenTransferList
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenTransferList} TokenTransferList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenTransferList.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenTransferList();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.token = $root.proto.TokenID.decode(r, r.uint32());
                    break;
                case 2:
                    if (!(m.transfers && m.transfers.length))
                        m.transfers = [];
                    m.transfers.push($root.proto.AccountAmount.decode(r, r.uint32()));
                    break;
                case 3:
                    if (!(m.nftTransfers && m.nftTransfers.length))
                        m.nftTransfers = [];
                    m.nftTransfers.push($root.proto.NftTransfer.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TokenTransferList;
    })();

    proto.Fraction = (function() {

        /**
         * Properties of a Fraction.
         * @memberof proto
         * @interface IFraction
         * @property {Long|null} [numerator] Fraction numerator
         * @property {Long|null} [denominator] Fraction denominator
         */

        /**
         * Constructs a new Fraction.
         * @memberof proto
         * @classdesc Represents a Fraction.
         * @implements IFraction
         * @constructor
         * @param {proto.IFraction=} [p] Properties to set
         */
        function Fraction(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Fraction numerator.
         * @member {Long} numerator
         * @memberof proto.Fraction
         * @instance
         */
        Fraction.prototype.numerator = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Fraction denominator.
         * @member {Long} denominator
         * @memberof proto.Fraction
         * @instance
         */
        Fraction.prototype.denominator = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Fraction instance using the specified properties.
         * @function create
         * @memberof proto.Fraction
         * @static
         * @param {proto.IFraction=} [properties] Properties to set
         * @returns {proto.Fraction} Fraction instance
         */
        Fraction.create = function create(properties) {
            return new Fraction(properties);
        };

        /**
         * Encodes the specified Fraction message. Does not implicitly {@link proto.Fraction.verify|verify} messages.
         * @function encode
         * @memberof proto.Fraction
         * @static
         * @param {proto.IFraction} m Fraction message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Fraction.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.numerator != null && Object.hasOwnProperty.call(m, "numerator"))
                w.uint32(8).int64(m.numerator);
            if (m.denominator != null && Object.hasOwnProperty.call(m, "denominator"))
                w.uint32(16).int64(m.denominator);
            return w;
        };

        /**
         * Decodes a Fraction message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Fraction
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.Fraction} Fraction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Fraction.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.Fraction();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.numerator = r.int64();
                    break;
                case 2:
                    m.denominator = r.int64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return Fraction;
    })();

    proto.TopicID = (function() {

        /**
         * Properties of a TopicID.
         * @memberof proto
         * @interface ITopicID
         * @property {Long|null} [shardNum] TopicID shardNum
         * @property {Long|null} [realmNum] TopicID realmNum
         * @property {Long|null} [topicNum] TopicID topicNum
         */

        /**
         * Constructs a new TopicID.
         * @memberof proto
         * @classdesc Represents a TopicID.
         * @implements ITopicID
         * @constructor
         * @param {proto.ITopicID=} [p] Properties to set
         */
        function TopicID(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TopicID shardNum.
         * @member {Long} shardNum
         * @memberof proto.TopicID
         * @instance
         */
        TopicID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TopicID realmNum.
         * @member {Long} realmNum
         * @memberof proto.TopicID
         * @instance
         */
        TopicID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TopicID topicNum.
         * @member {Long} topicNum
         * @memberof proto.TopicID
         * @instance
         */
        TopicID.prototype.topicNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new TopicID instance using the specified properties.
         * @function create
         * @memberof proto.TopicID
         * @static
         * @param {proto.ITopicID=} [properties] Properties to set
         * @returns {proto.TopicID} TopicID instance
         */
        TopicID.create = function create(properties) {
            return new TopicID(properties);
        };

        /**
         * Encodes the specified TopicID message. Does not implicitly {@link proto.TopicID.verify|verify} messages.
         * @function encode
         * @memberof proto.TopicID
         * @static
         * @param {proto.ITopicID} m TopicID message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TopicID.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.shardNum != null && Object.hasOwnProperty.call(m, "shardNum"))
                w.uint32(8).int64(m.shardNum);
            if (m.realmNum != null && Object.hasOwnProperty.call(m, "realmNum"))
                w.uint32(16).int64(m.realmNum);
            if (m.topicNum != null && Object.hasOwnProperty.call(m, "topicNum"))
                w.uint32(24).int64(m.topicNum);
            return w;
        };

        /**
         * Decodes a TopicID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TopicID
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TopicID} TopicID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TopicID.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TopicID();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.shardNum = r.int64();
                    break;
                case 2:
                    m.realmNum = r.int64();
                    break;
                case 3:
                    m.topicNum = r.int64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TopicID;
    })();

    proto.TokenID = (function() {

        /**
         * Properties of a TokenID.
         * @memberof proto
         * @interface ITokenID
         * @property {Long|null} [shardNum] TokenID shardNum
         * @property {Long|null} [realmNum] TokenID realmNum
         * @property {Long|null} [tokenNum] TokenID tokenNum
         */

        /**
         * Constructs a new TokenID.
         * @memberof proto
         * @classdesc Represents a TokenID.
         * @implements ITokenID
         * @constructor
         * @param {proto.ITokenID=} [p] Properties to set
         */
        function TokenID(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TokenID shardNum.
         * @member {Long} shardNum
         * @memberof proto.TokenID
         * @instance
         */
        TokenID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TokenID realmNum.
         * @member {Long} realmNum
         * @memberof proto.TokenID
         * @instance
         */
        TokenID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TokenID tokenNum.
         * @member {Long} tokenNum
         * @memberof proto.TokenID
         * @instance
         */
        TokenID.prototype.tokenNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new TokenID instance using the specified properties.
         * @function create
         * @memberof proto.TokenID
         * @static
         * @param {proto.ITokenID=} [properties] Properties to set
         * @returns {proto.TokenID} TokenID instance
         */
        TokenID.create = function create(properties) {
            return new TokenID(properties);
        };

        /**
         * Encodes the specified TokenID message. Does not implicitly {@link proto.TokenID.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenID
         * @static
         * @param {proto.ITokenID} m TokenID message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenID.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.shardNum != null && Object.hasOwnProperty.call(m, "shardNum"))
                w.uint32(8).int64(m.shardNum);
            if (m.realmNum != null && Object.hasOwnProperty.call(m, "realmNum"))
                w.uint32(16).int64(m.realmNum);
            if (m.tokenNum != null && Object.hasOwnProperty.call(m, "tokenNum"))
                w.uint32(24).int64(m.tokenNum);
            return w;
        };

        /**
         * Decodes a TokenID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenID
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenID} TokenID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenID.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenID();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.shardNum = r.int64();
                    break;
                case 2:
                    m.realmNum = r.int64();
                    break;
                case 3:
                    m.tokenNum = r.int64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TokenID;
    })();

    proto.ScheduleID = (function() {

        /**
         * Properties of a ScheduleID.
         * @memberof proto
         * @interface IScheduleID
         * @property {Long|null} [shardNum] ScheduleID shardNum
         * @property {Long|null} [realmNum] ScheduleID realmNum
         * @property {Long|null} [scheduleNum] ScheduleID scheduleNum
         */

        /**
         * Constructs a new ScheduleID.
         * @memberof proto
         * @classdesc Represents a ScheduleID.
         * @implements IScheduleID
         * @constructor
         * @param {proto.IScheduleID=} [p] Properties to set
         */
        function ScheduleID(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ScheduleID shardNum.
         * @member {Long} shardNum
         * @memberof proto.ScheduleID
         * @instance
         */
        ScheduleID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ScheduleID realmNum.
         * @member {Long} realmNum
         * @memberof proto.ScheduleID
         * @instance
         */
        ScheduleID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ScheduleID scheduleNum.
         * @member {Long} scheduleNum
         * @memberof proto.ScheduleID
         * @instance
         */
        ScheduleID.prototype.scheduleNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ScheduleID instance using the specified properties.
         * @function create
         * @memberof proto.ScheduleID
         * @static
         * @param {proto.IScheduleID=} [properties] Properties to set
         * @returns {proto.ScheduleID} ScheduleID instance
         */
        ScheduleID.create = function create(properties) {
            return new ScheduleID(properties);
        };

        /**
         * Encodes the specified ScheduleID message. Does not implicitly {@link proto.ScheduleID.verify|verify} messages.
         * @function encode
         * @memberof proto.ScheduleID
         * @static
         * @param {proto.IScheduleID} m ScheduleID message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScheduleID.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.shardNum != null && Object.hasOwnProperty.call(m, "shardNum"))
                w.uint32(8).int64(m.shardNum);
            if (m.realmNum != null && Object.hasOwnProperty.call(m, "realmNum"))
                w.uint32(16).int64(m.realmNum);
            if (m.scheduleNum != null && Object.hasOwnProperty.call(m, "scheduleNum"))
                w.uint32(24).int64(m.scheduleNum);
            return w;
        };

        /**
         * Decodes a ScheduleID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ScheduleID
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ScheduleID} ScheduleID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScheduleID.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ScheduleID();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.shardNum = r.int64();
                    break;
                case 2:
                    m.realmNum = r.int64();
                    break;
                case 3:
                    m.scheduleNum = r.int64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ScheduleID;
    })();

    /**
     * Possible Token Types (IWA Compatibility).
     * Apart from fungible and non-fungible, Tokens can have either a common or unique representation. This distinction might seem subtle, but it is important when considering
     * how tokens can be traced and if they can have isolated and unique properties.
     * @name proto.TokenType
     * @enum {number}
     * @property {number} FUNGIBLE_COMMON=0 Interchangeable value with one another, where any quantity of them has the same value as another equal quantity if they are in the same class.
     * Share a single set of properties, not distinct from one another. Simply represented as a balance or quantity to a given Hedera account.
     * @property {number} NON_FUNGIBLE_UNIQUE=1 Unique, not interchangeable with other tokens of the same type as they typically have different values.
     * Individually traced and can carry unique properties (e.g. serial number).
     */
    proto.TokenType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "FUNGIBLE_COMMON"] = 0;
        values[valuesById[1] = "NON_FUNGIBLE_UNIQUE"] = 1;
        return values;
    })();

    /**
     * Allows a set of resource prices to be scoped to a certain type of a HAPI operation.
     * 
     * For example, the resource prices for a TokenMint operation are different between
     * minting fungible and non-fungible tokens. This enum allows us to "mark" a set of
     * prices as applying to one or the other.
     * 
     * Similarly, the resource prices for a basic TokenCreate without a custom fee schedule
     * yield a total price of $1. The resource prices for a TokenCreate with a custom fee
     * schedule are different and yield a total base price of $2.
     * @name proto.SubType
     * @enum {number}
     * @property {number} DEFAULT=0 DEFAULT value
     * @property {number} TOKEN_FUNGIBLE_COMMON=1 TOKEN_FUNGIBLE_COMMON value
     * @property {number} TOKEN_NON_FUNGIBLE_UNIQUE=2 TOKEN_NON_FUNGIBLE_UNIQUE value
     * @property {number} TOKEN_FUNGIBLE_COMMON_WITH_CUSTOM_FEES=3 TOKEN_FUNGIBLE_COMMON_WITH_CUSTOM_FEES value
     * @property {number} TOKEN_NON_FUNGIBLE_UNIQUE_WITH_CUSTOM_FEES=4 TOKEN_NON_FUNGIBLE_UNIQUE_WITH_CUSTOM_FEES value
     */
    proto.SubType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DEFAULT"] = 0;
        values[valuesById[1] = "TOKEN_FUNGIBLE_COMMON"] = 1;
        values[valuesById[2] = "TOKEN_NON_FUNGIBLE_UNIQUE"] = 2;
        values[valuesById[3] = "TOKEN_FUNGIBLE_COMMON_WITH_CUSTOM_FEES"] = 3;
        values[valuesById[4] = "TOKEN_NON_FUNGIBLE_UNIQUE_WITH_CUSTOM_FEES"] = 4;
        return values;
    })();

    /**
     * Possible Token Supply Types (IWA Compatibility).
     * Indicates how many tokens can have during its lifetime.
     * @name proto.TokenSupplyType
     * @enum {number}
     * @property {number} INFINITE=0 INFINITE value
     * @property {number} FINITE=1 FINITE value
     */
    proto.TokenSupplyType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "INFINITE"] = 0;
        values[valuesById[1] = "FINITE"] = 1;
        return values;
    })();

    /**
     * TokenFreezeStatus enum.
     * @name proto.TokenFreezeStatus
     * @enum {number}
     * @property {number} FreezeNotApplicable=0 FreezeNotApplicable value
     * @property {number} Frozen=1 Frozen value
     * @property {number} Unfrozen=2 Unfrozen value
     */
    proto.TokenFreezeStatus = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "FreezeNotApplicable"] = 0;
        values[valuesById[1] = "Frozen"] = 1;
        values[valuesById[2] = "Unfrozen"] = 2;
        return values;
    })();

    /**
     * TokenKycStatus enum.
     * @name proto.TokenKycStatus
     * @enum {number}
     * @property {number} KycNotApplicable=0 KycNotApplicable value
     * @property {number} Granted=1 Granted value
     * @property {number} Revoked=2 Revoked value
     */
    proto.TokenKycStatus = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "KycNotApplicable"] = 0;
        values[valuesById[1] = "Granted"] = 1;
        values[valuesById[2] = "Revoked"] = 2;
        return values;
    })();

    proto.Key = (function() {

        /**
         * Properties of a Key.
         * @memberof proto
         * @interface IKey
         * @property {proto.IContractID|null} [contractID] Key contractID
         * @property {Uint8Array|null} [ed25519] Key ed25519
         * @property {Uint8Array|null} [RSA_3072] Key RSA_3072
         * @property {Uint8Array|null} [ECDSA_384] Key ECDSA_384
         * @property {proto.IThresholdKey|null} [thresholdKey] Key thresholdKey
         * @property {proto.IKeyList|null} [keyList] Key keyList
         */

        /**
         * Constructs a new Key.
         * @memberof proto
         * @classdesc Represents a Key.
         * @implements IKey
         * @constructor
         * @param {proto.IKey=} [p] Properties to set
         */
        function Key(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Key contractID.
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.Key
         * @instance
         */
        Key.prototype.contractID = null;

        /**
         * Key ed25519.
         * @member {Uint8Array|null|undefined} ed25519
         * @memberof proto.Key
         * @instance
         */
        Key.prototype.ed25519 = null;

        /**
         * Key RSA_3072.
         * @member {Uint8Array|null|undefined} RSA_3072
         * @memberof proto.Key
         * @instance
         */
        Key.prototype.RSA_3072 = null;

        /**
         * Key ECDSA_384.
         * @member {Uint8Array|null|undefined} ECDSA_384
         * @memberof proto.Key
         * @instance
         */
        Key.prototype.ECDSA_384 = null;

        /**
         * Key thresholdKey.
         * @member {proto.IThresholdKey|null|undefined} thresholdKey
         * @memberof proto.Key
         * @instance
         */
        Key.prototype.thresholdKey = null;

        /**
         * Key keyList.
         * @member {proto.IKeyList|null|undefined} keyList
         * @memberof proto.Key
         * @instance
         */
        Key.prototype.keyList = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * Key key.
         * @member {"contractID"|"ed25519"|"RSA_3072"|"ECDSA_384"|"thresholdKey"|"keyList"|undefined} key
         * @memberof proto.Key
         * @instance
         */
        Object.defineProperty(Key.prototype, "key", {
            get: $util.oneOfGetter($oneOfFields = ["contractID", "ed25519", "RSA_3072", "ECDSA_384", "thresholdKey", "keyList"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Key instance using the specified properties.
         * @function create
         * @memberof proto.Key
         * @static
         * @param {proto.IKey=} [properties] Properties to set
         * @returns {proto.Key} Key instance
         */
        Key.create = function create(properties) {
            return new Key(properties);
        };

        /**
         * Encodes the specified Key message. Does not implicitly {@link proto.Key.verify|verify} messages.
         * @function encode
         * @memberof proto.Key
         * @static
         * @param {proto.IKey} m Key message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Key.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(10).fork()).ldelim();
            if (m.ed25519 != null && Object.hasOwnProperty.call(m, "ed25519"))
                w.uint32(18).bytes(m.ed25519);
            if (m.RSA_3072 != null && Object.hasOwnProperty.call(m, "RSA_3072"))
                w.uint32(26).bytes(m.RSA_3072);
            if (m.ECDSA_384 != null && Object.hasOwnProperty.call(m, "ECDSA_384"))
                w.uint32(34).bytes(m.ECDSA_384);
            if (m.thresholdKey != null && Object.hasOwnProperty.call(m, "thresholdKey"))
                $root.proto.ThresholdKey.encode(m.thresholdKey, w.uint32(42).fork()).ldelim();
            if (m.keyList != null && Object.hasOwnProperty.call(m, "keyList"))
                $root.proto.KeyList.encode(m.keyList, w.uint32(50).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a Key message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Key
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.Key} Key
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Key.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.Key();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                    break;
                case 2:
                    m.ed25519 = r.bytes();
                    break;
                case 3:
                    m.RSA_3072 = r.bytes();
                    break;
                case 4:
                    m.ECDSA_384 = r.bytes();
                    break;
                case 5:
                    m.thresholdKey = $root.proto.ThresholdKey.decode(r, r.uint32());
                    break;
                case 6:
                    m.keyList = $root.proto.KeyList.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return Key;
    })();

    proto.ThresholdKey = (function() {

        /**
         * Properties of a ThresholdKey.
         * @memberof proto
         * @interface IThresholdKey
         * @property {number|null} [threshold] ThresholdKey threshold
         * @property {proto.IKeyList|null} [keys] ThresholdKey keys
         */

        /**
         * Constructs a new ThresholdKey.
         * @memberof proto
         * @classdesc Represents a ThresholdKey.
         * @implements IThresholdKey
         * @constructor
         * @param {proto.IThresholdKey=} [p] Properties to set
         */
        function ThresholdKey(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ThresholdKey threshold.
         * @member {number} threshold
         * @memberof proto.ThresholdKey
         * @instance
         */
        ThresholdKey.prototype.threshold = 0;

        /**
         * ThresholdKey keys.
         * @member {proto.IKeyList|null|undefined} keys
         * @memberof proto.ThresholdKey
         * @instance
         */
        ThresholdKey.prototype.keys = null;

        /**
         * Creates a new ThresholdKey instance using the specified properties.
         * @function create
         * @memberof proto.ThresholdKey
         * @static
         * @param {proto.IThresholdKey=} [properties] Properties to set
         * @returns {proto.ThresholdKey} ThresholdKey instance
         */
        ThresholdKey.create = function create(properties) {
            return new ThresholdKey(properties);
        };

        /**
         * Encodes the specified ThresholdKey message. Does not implicitly {@link proto.ThresholdKey.verify|verify} messages.
         * @function encode
         * @memberof proto.ThresholdKey
         * @static
         * @param {proto.IThresholdKey} m ThresholdKey message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ThresholdKey.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.threshold != null && Object.hasOwnProperty.call(m, "threshold"))
                w.uint32(8).uint32(m.threshold);
            if (m.keys != null && Object.hasOwnProperty.call(m, "keys"))
                $root.proto.KeyList.encode(m.keys, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ThresholdKey message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ThresholdKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ThresholdKey} ThresholdKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ThresholdKey.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ThresholdKey();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.threshold = r.uint32();
                    break;
                case 2:
                    m.keys = $root.proto.KeyList.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ThresholdKey;
    })();

    proto.KeyList = (function() {

        /**
         * Properties of a KeyList.
         * @memberof proto
         * @interface IKeyList
         * @property {Array.<proto.IKey>|null} [keys] KeyList keys
         */

        /**
         * Constructs a new KeyList.
         * @memberof proto
         * @classdesc Represents a KeyList.
         * @implements IKeyList
         * @constructor
         * @param {proto.IKeyList=} [p] Properties to set
         */
        function KeyList(p) {
            this.keys = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * KeyList keys.
         * @member {Array.<proto.IKey>} keys
         * @memberof proto.KeyList
         * @instance
         */
        KeyList.prototype.keys = $util.emptyArray;

        /**
         * Creates a new KeyList instance using the specified properties.
         * @function create
         * @memberof proto.KeyList
         * @static
         * @param {proto.IKeyList=} [properties] Properties to set
         * @returns {proto.KeyList} KeyList instance
         */
        KeyList.create = function create(properties) {
            return new KeyList(properties);
        };

        /**
         * Encodes the specified KeyList message. Does not implicitly {@link proto.KeyList.verify|verify} messages.
         * @function encode
         * @memberof proto.KeyList
         * @static
         * @param {proto.IKeyList} m KeyList message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyList.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.keys != null && m.keys.length) {
                for (var i = 0; i < m.keys.length; ++i)
                    $root.proto.Key.encode(m.keys[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a KeyList message from the specified reader or buffer.
         * @function decode
         * @memberof proto.KeyList
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.KeyList} KeyList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyList.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.KeyList();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    if (!(m.keys && m.keys.length))
                        m.keys = [];
                    m.keys.push($root.proto.Key.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return KeyList;
    })();

    proto.Signature = (function() {

        /**
         * Properties of a Signature.
         * @memberof proto
         * @interface ISignature
         * @property {Uint8Array|null} [contract] Signature contract
         * @property {Uint8Array|null} [ed25519] Signature ed25519
         * @property {Uint8Array|null} [RSA_3072] Signature RSA_3072
         * @property {Uint8Array|null} [ECDSA_384] Signature ECDSA_384
         * @property {proto.IThresholdSignature|null} [thresholdSignature] Signature thresholdSignature
         * @property {proto.ISignatureList|null} [signatureList] Signature signatureList
         */

        /**
         * Constructs a new Signature.
         * @memberof proto
         * @classdesc Represents a Signature.
         * @implements ISignature
         * @constructor
         * @param {proto.ISignature=} [p] Properties to set
         */
        function Signature(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Signature contract.
         * @member {Uint8Array|null|undefined} contract
         * @memberof proto.Signature
         * @instance
         */
        Signature.prototype.contract = null;

        /**
         * Signature ed25519.
         * @member {Uint8Array|null|undefined} ed25519
         * @memberof proto.Signature
         * @instance
         */
        Signature.prototype.ed25519 = null;

        /**
         * Signature RSA_3072.
         * @member {Uint8Array|null|undefined} RSA_3072
         * @memberof proto.Signature
         * @instance
         */
        Signature.prototype.RSA_3072 = null;

        /**
         * Signature ECDSA_384.
         * @member {Uint8Array|null|undefined} ECDSA_384
         * @memberof proto.Signature
         * @instance
         */
        Signature.prototype.ECDSA_384 = null;

        /**
         * Signature thresholdSignature.
         * @member {proto.IThresholdSignature|null|undefined} thresholdSignature
         * @memberof proto.Signature
         * @instance
         */
        Signature.prototype.thresholdSignature = null;

        /**
         * Signature signatureList.
         * @member {proto.ISignatureList|null|undefined} signatureList
         * @memberof proto.Signature
         * @instance
         */
        Signature.prototype.signatureList = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * Signature signature.
         * @member {"contract"|"ed25519"|"RSA_3072"|"ECDSA_384"|"thresholdSignature"|"signatureList"|undefined} signature
         * @memberof proto.Signature
         * @instance
         */
        Object.defineProperty(Signature.prototype, "signature", {
            get: $util.oneOfGetter($oneOfFields = ["contract", "ed25519", "RSA_3072", "ECDSA_384", "thresholdSignature", "signatureList"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Signature instance using the specified properties.
         * @function create
         * @memberof proto.Signature
         * @static
         * @param {proto.ISignature=} [properties] Properties to set
         * @returns {proto.Signature} Signature instance
         */
        Signature.create = function create(properties) {
            return new Signature(properties);
        };

        /**
         * Encodes the specified Signature message. Does not implicitly {@link proto.Signature.verify|verify} messages.
         * @function encode
         * @memberof proto.Signature
         * @static
         * @param {proto.ISignature} m Signature message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Signature.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.contract != null && Object.hasOwnProperty.call(m, "contract"))
                w.uint32(10).bytes(m.contract);
            if (m.ed25519 != null && Object.hasOwnProperty.call(m, "ed25519"))
                w.uint32(18).bytes(m.ed25519);
            if (m.RSA_3072 != null && Object.hasOwnProperty.call(m, "RSA_3072"))
                w.uint32(26).bytes(m.RSA_3072);
            if (m.ECDSA_384 != null && Object.hasOwnProperty.call(m, "ECDSA_384"))
                w.uint32(34).bytes(m.ECDSA_384);
            if (m.thresholdSignature != null && Object.hasOwnProperty.call(m, "thresholdSignature"))
                $root.proto.ThresholdSignature.encode(m.thresholdSignature, w.uint32(42).fork()).ldelim();
            if (m.signatureList != null && Object.hasOwnProperty.call(m, "signatureList"))
                $root.proto.SignatureList.encode(m.signatureList, w.uint32(50).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a Signature message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Signature
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.Signature} Signature
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Signature.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.Signature();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.contract = r.bytes();
                    break;
                case 2:
                    m.ed25519 = r.bytes();
                    break;
                case 3:
                    m.RSA_3072 = r.bytes();
                    break;
                case 4:
                    m.ECDSA_384 = r.bytes();
                    break;
                case 5:
                    m.thresholdSignature = $root.proto.ThresholdSignature.decode(r, r.uint32());
                    break;
                case 6:
                    m.signatureList = $root.proto.SignatureList.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return Signature;
    })();

    proto.ThresholdSignature = (function() {

        /**
         * Properties of a ThresholdSignature.
         * @memberof proto
         * @interface IThresholdSignature
         * @property {proto.ISignatureList|null} [sigs] ThresholdSignature sigs
         */

        /**
         * Constructs a new ThresholdSignature.
         * @memberof proto
         * @classdesc Represents a ThresholdSignature.
         * @implements IThresholdSignature
         * @constructor
         * @param {proto.IThresholdSignature=} [p] Properties to set
         */
        function ThresholdSignature(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ThresholdSignature sigs.
         * @member {proto.ISignatureList|null|undefined} sigs
         * @memberof proto.ThresholdSignature
         * @instance
         */
        ThresholdSignature.prototype.sigs = null;

        /**
         * Creates a new ThresholdSignature instance using the specified properties.
         * @function create
         * @memberof proto.ThresholdSignature
         * @static
         * @param {proto.IThresholdSignature=} [properties] Properties to set
         * @returns {proto.ThresholdSignature} ThresholdSignature instance
         */
        ThresholdSignature.create = function create(properties) {
            return new ThresholdSignature(properties);
        };

        /**
         * Encodes the specified ThresholdSignature message. Does not implicitly {@link proto.ThresholdSignature.verify|verify} messages.
         * @function encode
         * @memberof proto.ThresholdSignature
         * @static
         * @param {proto.IThresholdSignature} m ThresholdSignature message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ThresholdSignature.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.sigs != null && Object.hasOwnProperty.call(m, "sigs"))
                $root.proto.SignatureList.encode(m.sigs, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ThresholdSignature message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ThresholdSignature
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ThresholdSignature} ThresholdSignature
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ThresholdSignature.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ThresholdSignature();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 2:
                    m.sigs = $root.proto.SignatureList.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ThresholdSignature;
    })();

    proto.SignatureList = (function() {

        /**
         * Properties of a SignatureList.
         * @memberof proto
         * @interface ISignatureList
         * @property {Array.<proto.ISignature>|null} [sigs] SignatureList sigs
         */

        /**
         * Constructs a new SignatureList.
         * @memberof proto
         * @classdesc Represents a SignatureList.
         * @implements ISignatureList
         * @constructor
         * @param {proto.ISignatureList=} [p] Properties to set
         */
        function SignatureList(p) {
            this.sigs = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * SignatureList sigs.
         * @member {Array.<proto.ISignature>} sigs
         * @memberof proto.SignatureList
         * @instance
         */
        SignatureList.prototype.sigs = $util.emptyArray;

        /**
         * Creates a new SignatureList instance using the specified properties.
         * @function create
         * @memberof proto.SignatureList
         * @static
         * @param {proto.ISignatureList=} [properties] Properties to set
         * @returns {proto.SignatureList} SignatureList instance
         */
        SignatureList.create = function create(properties) {
            return new SignatureList(properties);
        };

        /**
         * Encodes the specified SignatureList message. Does not implicitly {@link proto.SignatureList.verify|verify} messages.
         * @function encode
         * @memberof proto.SignatureList
         * @static
         * @param {proto.ISignatureList} m SignatureList message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignatureList.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.sigs != null && m.sigs.length) {
                for (var i = 0; i < m.sigs.length; ++i)
                    $root.proto.Signature.encode(m.sigs[i], w.uint32(18).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a SignatureList message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignatureList
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.SignatureList} SignatureList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignatureList.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.SignatureList();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 2:
                    if (!(m.sigs && m.sigs.length))
                        m.sigs = [];
                    m.sigs.push($root.proto.Signature.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return SignatureList;
    })();

    proto.SignaturePair = (function() {

        /**
         * Properties of a SignaturePair.
         * @memberof proto
         * @interface ISignaturePair
         * @property {Uint8Array|null} [pubKeyPrefix] SignaturePair pubKeyPrefix
         * @property {Uint8Array|null} [contract] SignaturePair contract
         * @property {Uint8Array|null} [ed25519] SignaturePair ed25519
         * @property {Uint8Array|null} [RSA_3072] SignaturePair RSA_3072
         * @property {Uint8Array|null} [ECDSA_384] SignaturePair ECDSA_384
         */

        /**
         * Constructs a new SignaturePair.
         * @memberof proto
         * @classdesc Represents a SignaturePair.
         * @implements ISignaturePair
         * @constructor
         * @param {proto.ISignaturePair=} [p] Properties to set
         */
        function SignaturePair(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * SignaturePair pubKeyPrefix.
         * @member {Uint8Array} pubKeyPrefix
         * @memberof proto.SignaturePair
         * @instance
         */
        SignaturePair.prototype.pubKeyPrefix = $util.newBuffer([]);

        /**
         * SignaturePair contract.
         * @member {Uint8Array|null|undefined} contract
         * @memberof proto.SignaturePair
         * @instance
         */
        SignaturePair.prototype.contract = null;

        /**
         * SignaturePair ed25519.
         * @member {Uint8Array|null|undefined} ed25519
         * @memberof proto.SignaturePair
         * @instance
         */
        SignaturePair.prototype.ed25519 = null;

        /**
         * SignaturePair RSA_3072.
         * @member {Uint8Array|null|undefined} RSA_3072
         * @memberof proto.SignaturePair
         * @instance
         */
        SignaturePair.prototype.RSA_3072 = null;

        /**
         * SignaturePair ECDSA_384.
         * @member {Uint8Array|null|undefined} ECDSA_384
         * @memberof proto.SignaturePair
         * @instance
         */
        SignaturePair.prototype.ECDSA_384 = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * SignaturePair signature.
         * @member {"contract"|"ed25519"|"RSA_3072"|"ECDSA_384"|undefined} signature
         * @memberof proto.SignaturePair
         * @instance
         */
        Object.defineProperty(SignaturePair.prototype, "signature", {
            get: $util.oneOfGetter($oneOfFields = ["contract", "ed25519", "RSA_3072", "ECDSA_384"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new SignaturePair instance using the specified properties.
         * @function create
         * @memberof proto.SignaturePair
         * @static
         * @param {proto.ISignaturePair=} [properties] Properties to set
         * @returns {proto.SignaturePair} SignaturePair instance
         */
        SignaturePair.create = function create(properties) {
            return new SignaturePair(properties);
        };

        /**
         * Encodes the specified SignaturePair message. Does not implicitly {@link proto.SignaturePair.verify|verify} messages.
         * @function encode
         * @memberof proto.SignaturePair
         * @static
         * @param {proto.ISignaturePair} m SignaturePair message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignaturePair.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.pubKeyPrefix != null && Object.hasOwnProperty.call(m, "pubKeyPrefix"))
                w.uint32(10).bytes(m.pubKeyPrefix);
            if (m.contract != null && Object.hasOwnProperty.call(m, "contract"))
                w.uint32(18).bytes(m.contract);
            if (m.ed25519 != null && Object.hasOwnProperty.call(m, "ed25519"))
                w.uint32(26).bytes(m.ed25519);
            if (m.RSA_3072 != null && Object.hasOwnProperty.call(m, "RSA_3072"))
                w.uint32(34).bytes(m.RSA_3072);
            if (m.ECDSA_384 != null && Object.hasOwnProperty.call(m, "ECDSA_384"))
                w.uint32(42).bytes(m.ECDSA_384);
            return w;
        };

        /**
         * Decodes a SignaturePair message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignaturePair
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.SignaturePair} SignaturePair
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignaturePair.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.SignaturePair();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.pubKeyPrefix = r.bytes();
                    break;
                case 2:
                    m.contract = r.bytes();
                    break;
                case 3:
                    m.ed25519 = r.bytes();
                    break;
                case 4:
                    m.RSA_3072 = r.bytes();
                    break;
                case 5:
                    m.ECDSA_384 = r.bytes();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return SignaturePair;
    })();

    proto.SignatureMap = (function() {

        /**
         * Properties of a SignatureMap.
         * @memberof proto
         * @interface ISignatureMap
         * @property {Array.<proto.ISignaturePair>|null} [sigPair] SignatureMap sigPair
         */

        /**
         * Constructs a new SignatureMap.
         * @memberof proto
         * @classdesc Represents a SignatureMap.
         * @implements ISignatureMap
         * @constructor
         * @param {proto.ISignatureMap=} [p] Properties to set
         */
        function SignatureMap(p) {
            this.sigPair = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * SignatureMap sigPair.
         * @member {Array.<proto.ISignaturePair>} sigPair
         * @memberof proto.SignatureMap
         * @instance
         */
        SignatureMap.prototype.sigPair = $util.emptyArray;

        /**
         * Creates a new SignatureMap instance using the specified properties.
         * @function create
         * @memberof proto.SignatureMap
         * @static
         * @param {proto.ISignatureMap=} [properties] Properties to set
         * @returns {proto.SignatureMap} SignatureMap instance
         */
        SignatureMap.create = function create(properties) {
            return new SignatureMap(properties);
        };

        /**
         * Encodes the specified SignatureMap message. Does not implicitly {@link proto.SignatureMap.verify|verify} messages.
         * @function encode
         * @memberof proto.SignatureMap
         * @static
         * @param {proto.ISignatureMap} m SignatureMap message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignatureMap.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.sigPair != null && m.sigPair.length) {
                for (var i = 0; i < m.sigPair.length; ++i)
                    $root.proto.SignaturePair.encode(m.sigPair[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a SignatureMap message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignatureMap
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.SignatureMap} SignatureMap
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignatureMap.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.SignatureMap();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    if (!(m.sigPair && m.sigPair.length))
                        m.sigPair = [];
                    m.sigPair.push($root.proto.SignaturePair.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return SignatureMap;
    })();

    /**
     * HederaFunctionality enum.
     * @name proto.HederaFunctionality
     * @enum {number}
     * @property {number} NONE=0 NONE value
     * @property {number} CryptoTransfer=1 CryptoTransfer value
     * @property {number} CryptoUpdate=2 CryptoUpdate value
     * @property {number} CryptoDelete=3 CryptoDelete value
     * @property {number} CryptoAddLiveHash=4 CryptoAddLiveHash value
     * @property {number} CryptoDeleteLiveHash=5 CryptoDeleteLiveHash value
     * @property {number} ContractCall=6 ContractCall value
     * @property {number} ContractCreate=7 ContractCreate value
     * @property {number} ContractUpdate=8 ContractUpdate value
     * @property {number} FileCreate=9 FileCreate value
     * @property {number} FileAppend=10 FileAppend value
     * @property {number} FileUpdate=11 FileUpdate value
     * @property {number} FileDelete=12 FileDelete value
     * @property {number} CryptoGetAccountBalance=13 CryptoGetAccountBalance value
     * @property {number} CryptoGetAccountRecords=14 CryptoGetAccountRecords value
     * @property {number} CryptoGetInfo=15 CryptoGetInfo value
     * @property {number} ContractCallLocal=16 ContractCallLocal value
     * @property {number} ContractGetInfo=17 ContractGetInfo value
     * @property {number} ContractGetBytecode=18 ContractGetBytecode value
     * @property {number} GetBySolidityID=19 GetBySolidityID value
     * @property {number} GetByKey=20 GetByKey value
     * @property {number} CryptoGetLiveHash=21 CryptoGetLiveHash value
     * @property {number} CryptoGetStakers=22 CryptoGetStakers value
     * @property {number} FileGetContents=23 FileGetContents value
     * @property {number} FileGetInfo=24 FileGetInfo value
     * @property {number} TransactionGetRecord=25 TransactionGetRecord value
     * @property {number} ContractGetRecords=26 ContractGetRecords value
     * @property {number} CryptoCreate=27 CryptoCreate value
     * @property {number} SystemDelete=28 SystemDelete value
     * @property {number} SystemUndelete=29 SystemUndelete value
     * @property {number} ContractDelete=30 ContractDelete value
     * @property {number} Freeze=31 Freeze value
     * @property {number} CreateTransactionRecord=32 CreateTransactionRecord value
     * @property {number} CryptoAccountAutoRenew=33 CryptoAccountAutoRenew value
     * @property {number} ContractAutoRenew=34 ContractAutoRenew value
     * @property {number} GetVersionInfo=35 GetVersionInfo value
     * @property {number} TransactionGetReceipt=36 TransactionGetReceipt value
     * @property {number} ConsensusCreateTopic=50 ConsensusCreateTopic value
     * @property {number} ConsensusUpdateTopic=51 ConsensusUpdateTopic value
     * @property {number} ConsensusDeleteTopic=52 ConsensusDeleteTopic value
     * @property {number} ConsensusGetTopicInfo=53 ConsensusGetTopicInfo value
     * @property {number} ConsensusSubmitMessage=54 ConsensusSubmitMessage value
     * @property {number} UncheckedSubmit=55 UncheckedSubmit value
     * @property {number} TokenCreate=56 TokenCreate value
     * @property {number} TokenGetInfo=58 TokenGetInfo value
     * @property {number} TokenFreezeAccount=59 TokenFreezeAccount value
     * @property {number} TokenUnfreezeAccount=60 TokenUnfreezeAccount value
     * @property {number} TokenGrantKycToAccount=61 TokenGrantKycToAccount value
     * @property {number} TokenRevokeKycFromAccount=62 TokenRevokeKycFromAccount value
     * @property {number} TokenDelete=63 TokenDelete value
     * @property {number} TokenUpdate=64 TokenUpdate value
     * @property {number} TokenMint=65 TokenMint value
     * @property {number} TokenBurn=66 TokenBurn value
     * @property {number} TokenAccountWipe=67 TokenAccountWipe value
     * @property {number} TokenAssociateToAccount=68 TokenAssociateToAccount value
     * @property {number} TokenDissociateFromAccount=69 TokenDissociateFromAccount value
     * @property {number} ScheduleCreate=70 ScheduleCreate value
     * @property {number} ScheduleDelete=71 ScheduleDelete value
     * @property {number} ScheduleSign=72 ScheduleSign value
     * @property {number} ScheduleGetInfo=73 ScheduleGetInfo value
     * @property {number} TokenGetAccountNftInfos=74 TokenGetAccountNftInfos value
     * @property {number} TokenGetNftInfo=75 TokenGetNftInfo value
     * @property {number} TokenGetNftInfos=76 TokenGetNftInfos value
     * @property {number} TokenFeeScheduleUpdate=77 TokenFeeScheduleUpdate value
     */
    proto.HederaFunctionality = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NONE"] = 0;
        values[valuesById[1] = "CryptoTransfer"] = 1;
        values[valuesById[2] = "CryptoUpdate"] = 2;
        values[valuesById[3] = "CryptoDelete"] = 3;
        values[valuesById[4] = "CryptoAddLiveHash"] = 4;
        values[valuesById[5] = "CryptoDeleteLiveHash"] = 5;
        values[valuesById[6] = "ContractCall"] = 6;
        values[valuesById[7] = "ContractCreate"] = 7;
        values[valuesById[8] = "ContractUpdate"] = 8;
        values[valuesById[9] = "FileCreate"] = 9;
        values[valuesById[10] = "FileAppend"] = 10;
        values[valuesById[11] = "FileUpdate"] = 11;
        values[valuesById[12] = "FileDelete"] = 12;
        values[valuesById[13] = "CryptoGetAccountBalance"] = 13;
        values[valuesById[14] = "CryptoGetAccountRecords"] = 14;
        values[valuesById[15] = "CryptoGetInfo"] = 15;
        values[valuesById[16] = "ContractCallLocal"] = 16;
        values[valuesById[17] = "ContractGetInfo"] = 17;
        values[valuesById[18] = "ContractGetBytecode"] = 18;
        values[valuesById[19] = "GetBySolidityID"] = 19;
        values[valuesById[20] = "GetByKey"] = 20;
        values[valuesById[21] = "CryptoGetLiveHash"] = 21;
        values[valuesById[22] = "CryptoGetStakers"] = 22;
        values[valuesById[23] = "FileGetContents"] = 23;
        values[valuesById[24] = "FileGetInfo"] = 24;
        values[valuesById[25] = "TransactionGetRecord"] = 25;
        values[valuesById[26] = "ContractGetRecords"] = 26;
        values[valuesById[27] = "CryptoCreate"] = 27;
        values[valuesById[28] = "SystemDelete"] = 28;
        values[valuesById[29] = "SystemUndelete"] = 29;
        values[valuesById[30] = "ContractDelete"] = 30;
        values[valuesById[31] = "Freeze"] = 31;
        values[valuesById[32] = "CreateTransactionRecord"] = 32;
        values[valuesById[33] = "CryptoAccountAutoRenew"] = 33;
        values[valuesById[34] = "ContractAutoRenew"] = 34;
        values[valuesById[35] = "GetVersionInfo"] = 35;
        values[valuesById[36] = "TransactionGetReceipt"] = 36;
        values[valuesById[50] = "ConsensusCreateTopic"] = 50;
        values[valuesById[51] = "ConsensusUpdateTopic"] = 51;
        values[valuesById[52] = "ConsensusDeleteTopic"] = 52;
        values[valuesById[53] = "ConsensusGetTopicInfo"] = 53;
        values[valuesById[54] = "ConsensusSubmitMessage"] = 54;
        values[valuesById[55] = "UncheckedSubmit"] = 55;
        values[valuesById[56] = "TokenCreate"] = 56;
        values[valuesById[58] = "TokenGetInfo"] = 58;
        values[valuesById[59] = "TokenFreezeAccount"] = 59;
        values[valuesById[60] = "TokenUnfreezeAccount"] = 60;
        values[valuesById[61] = "TokenGrantKycToAccount"] = 61;
        values[valuesById[62] = "TokenRevokeKycFromAccount"] = 62;
        values[valuesById[63] = "TokenDelete"] = 63;
        values[valuesById[64] = "TokenUpdate"] = 64;
        values[valuesById[65] = "TokenMint"] = 65;
        values[valuesById[66] = "TokenBurn"] = 66;
        values[valuesById[67] = "TokenAccountWipe"] = 67;
        values[valuesById[68] = "TokenAssociateToAccount"] = 68;
        values[valuesById[69] = "TokenDissociateFromAccount"] = 69;
        values[valuesById[70] = "ScheduleCreate"] = 70;
        values[valuesById[71] = "ScheduleDelete"] = 71;
        values[valuesById[72] = "ScheduleSign"] = 72;
        values[valuesById[73] = "ScheduleGetInfo"] = 73;
        values[valuesById[74] = "TokenGetAccountNftInfos"] = 74;
        values[valuesById[75] = "TokenGetNftInfo"] = 75;
        values[valuesById[76] = "TokenGetNftInfos"] = 76;
        values[valuesById[77] = "TokenFeeScheduleUpdate"] = 77;
        return values;
    })();

    proto.FeeComponents = (function() {

        /**
         * Properties of a FeeComponents.
         * @memberof proto
         * @interface IFeeComponents
         * @property {Long|null} [min] FeeComponents min
         * @property {Long|null} [max] FeeComponents max
         * @property {Long|null} [constant] FeeComponents constant
         * @property {Long|null} [bpt] FeeComponents bpt
         * @property {Long|null} [vpt] FeeComponents vpt
         * @property {Long|null} [rbh] FeeComponents rbh
         * @property {Long|null} [sbh] FeeComponents sbh
         * @property {Long|null} [gas] FeeComponents gas
         * @property {Long|null} [tv] FeeComponents tv
         * @property {Long|null} [bpr] FeeComponents bpr
         * @property {Long|null} [sbpr] FeeComponents sbpr
         */

        /**
         * Constructs a new FeeComponents.
         * @memberof proto
         * @classdesc Represents a FeeComponents.
         * @implements IFeeComponents
         * @constructor
         * @param {proto.IFeeComponents=} [p] Properties to set
         */
        function FeeComponents(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * FeeComponents min.
         * @member {Long} min
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.min = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FeeComponents max.
         * @member {Long} max
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.max = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FeeComponents constant.
         * @member {Long} constant
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.constant = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FeeComponents bpt.
         * @member {Long} bpt
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.bpt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FeeComponents vpt.
         * @member {Long} vpt
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.vpt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FeeComponents rbh.
         * @member {Long} rbh
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.rbh = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FeeComponents sbh.
         * @member {Long} sbh
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.sbh = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FeeComponents gas.
         * @member {Long} gas
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.gas = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FeeComponents tv.
         * @member {Long} tv
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.tv = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FeeComponents bpr.
         * @member {Long} bpr
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.bpr = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FeeComponents sbpr.
         * @member {Long} sbpr
         * @memberof proto.FeeComponents
         * @instance
         */
        FeeComponents.prototype.sbpr = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new FeeComponents instance using the specified properties.
         * @function create
         * @memberof proto.FeeComponents
         * @static
         * @param {proto.IFeeComponents=} [properties] Properties to set
         * @returns {proto.FeeComponents} FeeComponents instance
         */
        FeeComponents.create = function create(properties) {
            return new FeeComponents(properties);
        };

        /**
         * Encodes the specified FeeComponents message. Does not implicitly {@link proto.FeeComponents.verify|verify} messages.
         * @function encode
         * @memberof proto.FeeComponents
         * @static
         * @param {proto.IFeeComponents} m FeeComponents message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeComponents.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.min != null && Object.hasOwnProperty.call(m, "min"))
                w.uint32(8).int64(m.min);
            if (m.max != null && Object.hasOwnProperty.call(m, "max"))
                w.uint32(16).int64(m.max);
            if (m.constant != null && Object.hasOwnProperty.call(m, "constant"))
                w.uint32(24).int64(m.constant);
            if (m.bpt != null && Object.hasOwnProperty.call(m, "bpt"))
                w.uint32(32).int64(m.bpt);
            if (m.vpt != null && Object.hasOwnProperty.call(m, "vpt"))
                w.uint32(40).int64(m.vpt);
            if (m.rbh != null && Object.hasOwnProperty.call(m, "rbh"))
                w.uint32(48).int64(m.rbh);
            if (m.sbh != null && Object.hasOwnProperty.call(m, "sbh"))
                w.uint32(56).int64(m.sbh);
            if (m.gas != null && Object.hasOwnProperty.call(m, "gas"))
                w.uint32(64).int64(m.gas);
            if (m.tv != null && Object.hasOwnProperty.call(m, "tv"))
                w.uint32(72).int64(m.tv);
            if (m.bpr != null && Object.hasOwnProperty.call(m, "bpr"))
                w.uint32(80).int64(m.bpr);
            if (m.sbpr != null && Object.hasOwnProperty.call(m, "sbpr"))
                w.uint32(88).int64(m.sbpr);
            return w;
        };

        /**
         * Decodes a FeeComponents message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FeeComponents
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FeeComponents} FeeComponents
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeComponents.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.FeeComponents();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.min = r.int64();
                    break;
                case 2:
                    m.max = r.int64();
                    break;
                case 3:
                    m.constant = r.int64();
                    break;
                case 4:
                    m.bpt = r.int64();
                    break;
                case 5:
                    m.vpt = r.int64();
                    break;
                case 6:
                    m.rbh = r.int64();
                    break;
                case 7:
                    m.sbh = r.int64();
                    break;
                case 8:
                    m.gas = r.int64();
                    break;
                case 9:
                    m.tv = r.int64();
                    break;
                case 10:
                    m.bpr = r.int64();
                    break;
                case 11:
                    m.sbpr = r.int64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return FeeComponents;
    })();

    proto.TransactionFeeSchedule = (function() {

        /**
         * Properties of a TransactionFeeSchedule.
         * @memberof proto
         * @interface ITransactionFeeSchedule
         * @property {proto.HederaFunctionality|null} [hederaFunctionality] TransactionFeeSchedule hederaFunctionality
         * @property {proto.IFeeData|null} [feeData] TransactionFeeSchedule feeData
         * @property {Array.<proto.IFeeData>|null} [fees] TransactionFeeSchedule fees
         */

        /**
         * Constructs a new TransactionFeeSchedule.
         * @memberof proto
         * @classdesc Represents a TransactionFeeSchedule.
         * @implements ITransactionFeeSchedule
         * @constructor
         * @param {proto.ITransactionFeeSchedule=} [p] Properties to set
         */
        function TransactionFeeSchedule(p) {
            this.fees = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TransactionFeeSchedule hederaFunctionality.
         * @member {proto.HederaFunctionality} hederaFunctionality
         * @memberof proto.TransactionFeeSchedule
         * @instance
         */
        TransactionFeeSchedule.prototype.hederaFunctionality = 0;

        /**
         * TransactionFeeSchedule feeData.
         * @member {proto.IFeeData|null|undefined} feeData
         * @memberof proto.TransactionFeeSchedule
         * @instance
         */
        TransactionFeeSchedule.prototype.feeData = null;

        /**
         * TransactionFeeSchedule fees.
         * @member {Array.<proto.IFeeData>} fees
         * @memberof proto.TransactionFeeSchedule
         * @instance
         */
        TransactionFeeSchedule.prototype.fees = $util.emptyArray;

        /**
         * Creates a new TransactionFeeSchedule instance using the specified properties.
         * @function create
         * @memberof proto.TransactionFeeSchedule
         * @static
         * @param {proto.ITransactionFeeSchedule=} [properties] Properties to set
         * @returns {proto.TransactionFeeSchedule} TransactionFeeSchedule instance
         */
        TransactionFeeSchedule.create = function create(properties) {
            return new TransactionFeeSchedule(properties);
        };

        /**
         * Encodes the specified TransactionFeeSchedule message. Does not implicitly {@link proto.TransactionFeeSchedule.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionFeeSchedule
         * @static
         * @param {proto.ITransactionFeeSchedule} m TransactionFeeSchedule message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionFeeSchedule.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.hederaFunctionality != null && Object.hasOwnProperty.call(m, "hederaFunctionality"))
                w.uint32(8).int32(m.hederaFunctionality);
            if (m.feeData != null && Object.hasOwnProperty.call(m, "feeData"))
                $root.proto.FeeData.encode(m.feeData, w.uint32(18).fork()).ldelim();
            if (m.fees != null && m.fees.length) {
                for (var i = 0; i < m.fees.length; ++i)
                    $root.proto.FeeData.encode(m.fees[i], w.uint32(26).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TransactionFeeSchedule message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionFeeSchedule
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionFeeSchedule} TransactionFeeSchedule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionFeeSchedule.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TransactionFeeSchedule();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.hederaFunctionality = r.int32();
                    break;
                case 2:
                    m.feeData = $root.proto.FeeData.decode(r, r.uint32());
                    break;
                case 3:
                    if (!(m.fees && m.fees.length))
                        m.fees = [];
                    m.fees.push($root.proto.FeeData.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TransactionFeeSchedule;
    })();

    proto.FeeData = (function() {

        /**
         * Properties of a FeeData.
         * @memberof proto
         * @interface IFeeData
         * @property {proto.IFeeComponents|null} [nodedata] FeeData nodedata
         * @property {proto.IFeeComponents|null} [networkdata] FeeData networkdata
         * @property {proto.IFeeComponents|null} [servicedata] FeeData servicedata
         * @property {proto.SubType|null} [subType] FeeData subType
         */

        /**
         * Constructs a new FeeData.
         * @memberof proto
         * @classdesc Represents a FeeData.
         * @implements IFeeData
         * @constructor
         * @param {proto.IFeeData=} [p] Properties to set
         */
        function FeeData(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * FeeData nodedata.
         * @member {proto.IFeeComponents|null|undefined} nodedata
         * @memberof proto.FeeData
         * @instance
         */
        FeeData.prototype.nodedata = null;

        /**
         * FeeData networkdata.
         * @member {proto.IFeeComponents|null|undefined} networkdata
         * @memberof proto.FeeData
         * @instance
         */
        FeeData.prototype.networkdata = null;

        /**
         * FeeData servicedata.
         * @member {proto.IFeeComponents|null|undefined} servicedata
         * @memberof proto.FeeData
         * @instance
         */
        FeeData.prototype.servicedata = null;

        /**
         * FeeData subType.
         * @member {proto.SubType} subType
         * @memberof proto.FeeData
         * @instance
         */
        FeeData.prototype.subType = 0;

        /**
         * Creates a new FeeData instance using the specified properties.
         * @function create
         * @memberof proto.FeeData
         * @static
         * @param {proto.IFeeData=} [properties] Properties to set
         * @returns {proto.FeeData} FeeData instance
         */
        FeeData.create = function create(properties) {
            return new FeeData(properties);
        };

        /**
         * Encodes the specified FeeData message. Does not implicitly {@link proto.FeeData.verify|verify} messages.
         * @function encode
         * @memberof proto.FeeData
         * @static
         * @param {proto.IFeeData} m FeeData message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeData.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.nodedata != null && Object.hasOwnProperty.call(m, "nodedata"))
                $root.proto.FeeComponents.encode(m.nodedata, w.uint32(10).fork()).ldelim();
            if (m.networkdata != null && Object.hasOwnProperty.call(m, "networkdata"))
                $root.proto.FeeComponents.encode(m.networkdata, w.uint32(18).fork()).ldelim();
            if (m.servicedata != null && Object.hasOwnProperty.call(m, "servicedata"))
                $root.proto.FeeComponents.encode(m.servicedata, w.uint32(26).fork()).ldelim();
            if (m.subType != null && Object.hasOwnProperty.call(m, "subType"))
                w.uint32(32).int32(m.subType);
            return w;
        };

        /**
         * Decodes a FeeData message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FeeData
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FeeData} FeeData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeData.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.FeeData();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.nodedata = $root.proto.FeeComponents.decode(r, r.uint32());
                    break;
                case 2:
                    m.networkdata = $root.proto.FeeComponents.decode(r, r.uint32());
                    break;
                case 3:
                    m.servicedata = $root.proto.FeeComponents.decode(r, r.uint32());
                    break;
                case 4:
                    m.subType = r.int32();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return FeeData;
    })();

    proto.FeeSchedule = (function() {

        /**
         * Properties of a FeeSchedule.
         * @memberof proto
         * @interface IFeeSchedule
         * @property {Array.<proto.ITransactionFeeSchedule>|null} [transactionFeeSchedule] FeeSchedule transactionFeeSchedule
         * @property {proto.ITimestampSeconds|null} [expiryTime] FeeSchedule expiryTime
         */

        /**
         * Constructs a new FeeSchedule.
         * @memberof proto
         * @classdesc Represents a FeeSchedule.
         * @implements IFeeSchedule
         * @constructor
         * @param {proto.IFeeSchedule=} [p] Properties to set
         */
        function FeeSchedule(p) {
            this.transactionFeeSchedule = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * FeeSchedule transactionFeeSchedule.
         * @member {Array.<proto.ITransactionFeeSchedule>} transactionFeeSchedule
         * @memberof proto.FeeSchedule
         * @instance
         */
        FeeSchedule.prototype.transactionFeeSchedule = $util.emptyArray;

        /**
         * FeeSchedule expiryTime.
         * @member {proto.ITimestampSeconds|null|undefined} expiryTime
         * @memberof proto.FeeSchedule
         * @instance
         */
        FeeSchedule.prototype.expiryTime = null;

        /**
         * Creates a new FeeSchedule instance using the specified properties.
         * @function create
         * @memberof proto.FeeSchedule
         * @static
         * @param {proto.IFeeSchedule=} [properties] Properties to set
         * @returns {proto.FeeSchedule} FeeSchedule instance
         */
        FeeSchedule.create = function create(properties) {
            return new FeeSchedule(properties);
        };

        /**
         * Encodes the specified FeeSchedule message. Does not implicitly {@link proto.FeeSchedule.verify|verify} messages.
         * @function encode
         * @memberof proto.FeeSchedule
         * @static
         * @param {proto.IFeeSchedule} m FeeSchedule message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeSchedule.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.transactionFeeSchedule != null && m.transactionFeeSchedule.length) {
                for (var i = 0; i < m.transactionFeeSchedule.length; ++i)
                    $root.proto.TransactionFeeSchedule.encode(m.transactionFeeSchedule[i], w.uint32(10).fork()).ldelim();
            }
            if (m.expiryTime != null && Object.hasOwnProperty.call(m, "expiryTime"))
                $root.proto.TimestampSeconds.encode(m.expiryTime, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a FeeSchedule message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FeeSchedule
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FeeSchedule} FeeSchedule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeSchedule.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.FeeSchedule();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    if (!(m.transactionFeeSchedule && m.transactionFeeSchedule.length))
                        m.transactionFeeSchedule = [];
                    m.transactionFeeSchedule.push($root.proto.TransactionFeeSchedule.decode(r, r.uint32()));
                    break;
                case 2:
                    m.expiryTime = $root.proto.TimestampSeconds.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return FeeSchedule;
    })();

    proto.CurrentAndNextFeeSchedule = (function() {

        /**
         * Properties of a CurrentAndNextFeeSchedule.
         * @memberof proto
         * @interface ICurrentAndNextFeeSchedule
         * @property {proto.IFeeSchedule|null} [currentFeeSchedule] CurrentAndNextFeeSchedule currentFeeSchedule
         * @property {proto.IFeeSchedule|null} [nextFeeSchedule] CurrentAndNextFeeSchedule nextFeeSchedule
         */

        /**
         * Constructs a new CurrentAndNextFeeSchedule.
         * @memberof proto
         * @classdesc Represents a CurrentAndNextFeeSchedule.
         * @implements ICurrentAndNextFeeSchedule
         * @constructor
         * @param {proto.ICurrentAndNextFeeSchedule=} [p] Properties to set
         */
        function CurrentAndNextFeeSchedule(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * CurrentAndNextFeeSchedule currentFeeSchedule.
         * @member {proto.IFeeSchedule|null|undefined} currentFeeSchedule
         * @memberof proto.CurrentAndNextFeeSchedule
         * @instance
         */
        CurrentAndNextFeeSchedule.prototype.currentFeeSchedule = null;

        /**
         * CurrentAndNextFeeSchedule nextFeeSchedule.
         * @member {proto.IFeeSchedule|null|undefined} nextFeeSchedule
         * @memberof proto.CurrentAndNextFeeSchedule
         * @instance
         */
        CurrentAndNextFeeSchedule.prototype.nextFeeSchedule = null;

        /**
         * Creates a new CurrentAndNextFeeSchedule instance using the specified properties.
         * @function create
         * @memberof proto.CurrentAndNextFeeSchedule
         * @static
         * @param {proto.ICurrentAndNextFeeSchedule=} [properties] Properties to set
         * @returns {proto.CurrentAndNextFeeSchedule} CurrentAndNextFeeSchedule instance
         */
        CurrentAndNextFeeSchedule.create = function create(properties) {
            return new CurrentAndNextFeeSchedule(properties);
        };

        /**
         * Encodes the specified CurrentAndNextFeeSchedule message. Does not implicitly {@link proto.CurrentAndNextFeeSchedule.verify|verify} messages.
         * @function encode
         * @memberof proto.CurrentAndNextFeeSchedule
         * @static
         * @param {proto.ICurrentAndNextFeeSchedule} m CurrentAndNextFeeSchedule message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CurrentAndNextFeeSchedule.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.currentFeeSchedule != null && Object.hasOwnProperty.call(m, "currentFeeSchedule"))
                $root.proto.FeeSchedule.encode(m.currentFeeSchedule, w.uint32(10).fork()).ldelim();
            if (m.nextFeeSchedule != null && Object.hasOwnProperty.call(m, "nextFeeSchedule"))
                $root.proto.FeeSchedule.encode(m.nextFeeSchedule, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a CurrentAndNextFeeSchedule message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CurrentAndNextFeeSchedule
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CurrentAndNextFeeSchedule} CurrentAndNextFeeSchedule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CurrentAndNextFeeSchedule.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CurrentAndNextFeeSchedule();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.currentFeeSchedule = $root.proto.FeeSchedule.decode(r, r.uint32());
                    break;
                case 2:
                    m.nextFeeSchedule = $root.proto.FeeSchedule.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return CurrentAndNextFeeSchedule;
    })();

    proto.ServiceEndpoint = (function() {

        /**
         * Properties of a ServiceEndpoint.
         * @memberof proto
         * @interface IServiceEndpoint
         * @property {Uint8Array|null} [ipAddressV4] ServiceEndpoint ipAddressV4
         * @property {number|null} [port] ServiceEndpoint port
         */

        /**
         * Constructs a new ServiceEndpoint.
         * @memberof proto
         * @classdesc Represents a ServiceEndpoint.
         * @implements IServiceEndpoint
         * @constructor
         * @param {proto.IServiceEndpoint=} [p] Properties to set
         */
        function ServiceEndpoint(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ServiceEndpoint ipAddressV4.
         * @member {Uint8Array} ipAddressV4
         * @memberof proto.ServiceEndpoint
         * @instance
         */
        ServiceEndpoint.prototype.ipAddressV4 = $util.newBuffer([]);

        /**
         * ServiceEndpoint port.
         * @member {number} port
         * @memberof proto.ServiceEndpoint
         * @instance
         */
        ServiceEndpoint.prototype.port = 0;

        /**
         * Creates a new ServiceEndpoint instance using the specified properties.
         * @function create
         * @memberof proto.ServiceEndpoint
         * @static
         * @param {proto.IServiceEndpoint=} [properties] Properties to set
         * @returns {proto.ServiceEndpoint} ServiceEndpoint instance
         */
        ServiceEndpoint.create = function create(properties) {
            return new ServiceEndpoint(properties);
        };

        /**
         * Encodes the specified ServiceEndpoint message. Does not implicitly {@link proto.ServiceEndpoint.verify|verify} messages.
         * @function encode
         * @memberof proto.ServiceEndpoint
         * @static
         * @param {proto.IServiceEndpoint} m ServiceEndpoint message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceEndpoint.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.ipAddressV4 != null && Object.hasOwnProperty.call(m, "ipAddressV4"))
                w.uint32(10).bytes(m.ipAddressV4);
            if (m.port != null && Object.hasOwnProperty.call(m, "port"))
                w.uint32(16).int32(m.port);
            return w;
        };

        /**
         * Decodes a ServiceEndpoint message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ServiceEndpoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ServiceEndpoint} ServiceEndpoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceEndpoint.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ServiceEndpoint();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.ipAddressV4 = r.bytes();
                    break;
                case 2:
                    m.port = r.int32();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ServiceEndpoint;
    })();

    proto.NodeAddress = (function() {

        /**
         * Properties of a NodeAddress.
         * @memberof proto
         * @interface INodeAddress
         * @property {Uint8Array|null} [ipAddress] NodeAddress ipAddress
         * @property {number|null} [portno] NodeAddress portno
         * @property {Uint8Array|null} [memo] NodeAddress memo
         * @property {string|null} [RSA_PubKey] NodeAddress RSA_PubKey
         * @property {Long|null} [nodeId] NodeAddress nodeId
         * @property {proto.IAccountID|null} [nodeAccountId] NodeAddress nodeAccountId
         * @property {Uint8Array|null} [nodeCertHash] NodeAddress nodeCertHash
         * @property {Array.<proto.IServiceEndpoint>|null} [serviceEndpoint] NodeAddress serviceEndpoint
         * @property {string|null} [description] NodeAddress description
         * @property {Long|null} [stake] NodeAddress stake
         */

        /**
         * Constructs a new NodeAddress.
         * @memberof proto
         * @classdesc Represents a NodeAddress.
         * @implements INodeAddress
         * @constructor
         * @param {proto.INodeAddress=} [p] Properties to set
         */
        function NodeAddress(p) {
            this.serviceEndpoint = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * NodeAddress ipAddress.
         * @member {Uint8Array} ipAddress
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.ipAddress = $util.newBuffer([]);

        /**
         * NodeAddress portno.
         * @member {number} portno
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.portno = 0;

        /**
         * NodeAddress memo.
         * @member {Uint8Array} memo
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.memo = $util.newBuffer([]);

        /**
         * NodeAddress RSA_PubKey.
         * @member {string} RSA_PubKey
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.RSA_PubKey = "";

        /**
         * NodeAddress nodeId.
         * @member {Long} nodeId
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.nodeId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * NodeAddress nodeAccountId.
         * @member {proto.IAccountID|null|undefined} nodeAccountId
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.nodeAccountId = null;

        /**
         * NodeAddress nodeCertHash.
         * @member {Uint8Array} nodeCertHash
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.nodeCertHash = $util.newBuffer([]);

        /**
         * NodeAddress serviceEndpoint.
         * @member {Array.<proto.IServiceEndpoint>} serviceEndpoint
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.serviceEndpoint = $util.emptyArray;

        /**
         * NodeAddress description.
         * @member {string} description
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.description = "";

        /**
         * NodeAddress stake.
         * @member {Long} stake
         * @memberof proto.NodeAddress
         * @instance
         */
        NodeAddress.prototype.stake = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new NodeAddress instance using the specified properties.
         * @function create
         * @memberof proto.NodeAddress
         * @static
         * @param {proto.INodeAddress=} [properties] Properties to set
         * @returns {proto.NodeAddress} NodeAddress instance
         */
        NodeAddress.create = function create(properties) {
            return new NodeAddress(properties);
        };

        /**
         * Encodes the specified NodeAddress message. Does not implicitly {@link proto.NodeAddress.verify|verify} messages.
         * @function encode
         * @memberof proto.NodeAddress
         * @static
         * @param {proto.INodeAddress} m NodeAddress message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeAddress.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.ipAddress != null && Object.hasOwnProperty.call(m, "ipAddress"))
                w.uint32(10).bytes(m.ipAddress);
            if (m.portno != null && Object.hasOwnProperty.call(m, "portno"))
                w.uint32(16).int32(m.portno);
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                w.uint32(26).bytes(m.memo);
            if (m.RSA_PubKey != null && Object.hasOwnProperty.call(m, "RSA_PubKey"))
                w.uint32(34).string(m.RSA_PubKey);
            if (m.nodeId != null && Object.hasOwnProperty.call(m, "nodeId"))
                w.uint32(40).int64(m.nodeId);
            if (m.nodeAccountId != null && Object.hasOwnProperty.call(m, "nodeAccountId"))
                $root.proto.AccountID.encode(m.nodeAccountId, w.uint32(50).fork()).ldelim();
            if (m.nodeCertHash != null && Object.hasOwnProperty.call(m, "nodeCertHash"))
                w.uint32(58).bytes(m.nodeCertHash);
            if (m.serviceEndpoint != null && m.serviceEndpoint.length) {
                for (var i = 0; i < m.serviceEndpoint.length; ++i)
                    $root.proto.ServiceEndpoint.encode(m.serviceEndpoint[i], w.uint32(66).fork()).ldelim();
            }
            if (m.description != null && Object.hasOwnProperty.call(m, "description"))
                w.uint32(74).string(m.description);
            if (m.stake != null && Object.hasOwnProperty.call(m, "stake"))
                w.uint32(80).int64(m.stake);
            return w;
        };

        /**
         * Decodes a NodeAddress message from the specified reader or buffer.
         * @function decode
         * @memberof proto.NodeAddress
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.NodeAddress} NodeAddress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeAddress.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.NodeAddress();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.ipAddress = r.bytes();
                    break;
                case 2:
                    m.portno = r.int32();
                    break;
                case 3:
                    m.memo = r.bytes();
                    break;
                case 4:
                    m.RSA_PubKey = r.string();
                    break;
                case 5:
                    m.nodeId = r.int64();
                    break;
                case 6:
                    m.nodeAccountId = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 7:
                    m.nodeCertHash = r.bytes();
                    break;
                case 8:
                    if (!(m.serviceEndpoint && m.serviceEndpoint.length))
                        m.serviceEndpoint = [];
                    m.serviceEndpoint.push($root.proto.ServiceEndpoint.decode(r, r.uint32()));
                    break;
                case 9:
                    m.description = r.string();
                    break;
                case 10:
                    m.stake = r.int64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return NodeAddress;
    })();

    proto.NodeAddressBook = (function() {

        /**
         * Properties of a NodeAddressBook.
         * @memberof proto
         * @interface INodeAddressBook
         * @property {Array.<proto.INodeAddress>|null} [nodeAddress] NodeAddressBook nodeAddress
         */

        /**
         * Constructs a new NodeAddressBook.
         * @memberof proto
         * @classdesc Represents a NodeAddressBook.
         * @implements INodeAddressBook
         * @constructor
         * @param {proto.INodeAddressBook=} [p] Properties to set
         */
        function NodeAddressBook(p) {
            this.nodeAddress = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * NodeAddressBook nodeAddress.
         * @member {Array.<proto.INodeAddress>} nodeAddress
         * @memberof proto.NodeAddressBook
         * @instance
         */
        NodeAddressBook.prototype.nodeAddress = $util.emptyArray;

        /**
         * Creates a new NodeAddressBook instance using the specified properties.
         * @function create
         * @memberof proto.NodeAddressBook
         * @static
         * @param {proto.INodeAddressBook=} [properties] Properties to set
         * @returns {proto.NodeAddressBook} NodeAddressBook instance
         */
        NodeAddressBook.create = function create(properties) {
            return new NodeAddressBook(properties);
        };

        /**
         * Encodes the specified NodeAddressBook message. Does not implicitly {@link proto.NodeAddressBook.verify|verify} messages.
         * @function encode
         * @memberof proto.NodeAddressBook
         * @static
         * @param {proto.INodeAddressBook} m NodeAddressBook message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeAddressBook.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.nodeAddress != null && m.nodeAddress.length) {
                for (var i = 0; i < m.nodeAddress.length; ++i)
                    $root.proto.NodeAddress.encode(m.nodeAddress[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a NodeAddressBook message from the specified reader or buffer.
         * @function decode
         * @memberof proto.NodeAddressBook
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.NodeAddressBook} NodeAddressBook
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeAddressBook.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.NodeAddressBook();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    if (!(m.nodeAddress && m.nodeAddress.length))
                        m.nodeAddress = [];
                    m.nodeAddress.push($root.proto.NodeAddress.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return NodeAddressBook;
    })();

    proto.SemanticVersion = (function() {

        /**
         * Properties of a SemanticVersion.
         * @memberof proto
         * @interface ISemanticVersion
         * @property {number|null} [major] SemanticVersion major
         * @property {number|null} [minor] SemanticVersion minor
         * @property {number|null} [patch] SemanticVersion patch
         * @property {string|null} [pre] SemanticVersion pre
         * @property {string|null} [build] SemanticVersion build
         */

        /**
         * Constructs a new SemanticVersion.
         * @memberof proto
         * @classdesc Represents a SemanticVersion.
         * @implements ISemanticVersion
         * @constructor
         * @param {proto.ISemanticVersion=} [p] Properties to set
         */
        function SemanticVersion(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * SemanticVersion major.
         * @member {number} major
         * @memberof proto.SemanticVersion
         * @instance
         */
        SemanticVersion.prototype.major = 0;

        /**
         * SemanticVersion minor.
         * @member {number} minor
         * @memberof proto.SemanticVersion
         * @instance
         */
        SemanticVersion.prototype.minor = 0;

        /**
         * SemanticVersion patch.
         * @member {number} patch
         * @memberof proto.SemanticVersion
         * @instance
         */
        SemanticVersion.prototype.patch = 0;

        /**
         * SemanticVersion pre.
         * @member {string} pre
         * @memberof proto.SemanticVersion
         * @instance
         */
        SemanticVersion.prototype.pre = "";

        /**
         * SemanticVersion build.
         * @member {string} build
         * @memberof proto.SemanticVersion
         * @instance
         */
        SemanticVersion.prototype.build = "";

        /**
         * Creates a new SemanticVersion instance using the specified properties.
         * @function create
         * @memberof proto.SemanticVersion
         * @static
         * @param {proto.ISemanticVersion=} [properties] Properties to set
         * @returns {proto.SemanticVersion} SemanticVersion instance
         */
        SemanticVersion.create = function create(properties) {
            return new SemanticVersion(properties);
        };

        /**
         * Encodes the specified SemanticVersion message. Does not implicitly {@link proto.SemanticVersion.verify|verify} messages.
         * @function encode
         * @memberof proto.SemanticVersion
         * @static
         * @param {proto.ISemanticVersion} m SemanticVersion message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SemanticVersion.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.major != null && Object.hasOwnProperty.call(m, "major"))
                w.uint32(8).int32(m.major);
            if (m.minor != null && Object.hasOwnProperty.call(m, "minor"))
                w.uint32(16).int32(m.minor);
            if (m.patch != null && Object.hasOwnProperty.call(m, "patch"))
                w.uint32(24).int32(m.patch);
            if (m.pre != null && Object.hasOwnProperty.call(m, "pre"))
                w.uint32(34).string(m.pre);
            if (m.build != null && Object.hasOwnProperty.call(m, "build"))
                w.uint32(42).string(m.build);
            return w;
        };

        /**
         * Decodes a SemanticVersion message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SemanticVersion
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.SemanticVersion} SemanticVersion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SemanticVersion.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.SemanticVersion();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.major = r.int32();
                    break;
                case 2:
                    m.minor = r.int32();
                    break;
                case 3:
                    m.patch = r.int32();
                    break;
                case 4:
                    m.pre = r.string();
                    break;
                case 5:
                    m.build = r.string();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return SemanticVersion;
    })();

    proto.Setting = (function() {

        /**
         * Properties of a Setting.
         * @memberof proto
         * @interface ISetting
         * @property {string|null} [name] Setting name
         * @property {string|null} [value] Setting value
         * @property {Uint8Array|null} [data] Setting data
         */

        /**
         * Constructs a new Setting.
         * @memberof proto
         * @classdesc Represents a Setting.
         * @implements ISetting
         * @constructor
         * @param {proto.ISetting=} [p] Properties to set
         */
        function Setting(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Setting name.
         * @member {string} name
         * @memberof proto.Setting
         * @instance
         */
        Setting.prototype.name = "";

        /**
         * Setting value.
         * @member {string} value
         * @memberof proto.Setting
         * @instance
         */
        Setting.prototype.value = "";

        /**
         * Setting data.
         * @member {Uint8Array} data
         * @memberof proto.Setting
         * @instance
         */
        Setting.prototype.data = $util.newBuffer([]);

        /**
         * Creates a new Setting instance using the specified properties.
         * @function create
         * @memberof proto.Setting
         * @static
         * @param {proto.ISetting=} [properties] Properties to set
         * @returns {proto.Setting} Setting instance
         */
        Setting.create = function create(properties) {
            return new Setting(properties);
        };

        /**
         * Encodes the specified Setting message. Does not implicitly {@link proto.Setting.verify|verify} messages.
         * @function encode
         * @memberof proto.Setting
         * @static
         * @param {proto.ISetting} m Setting message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Setting.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.name != null && Object.hasOwnProperty.call(m, "name"))
                w.uint32(10).string(m.name);
            if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                w.uint32(18).string(m.value);
            if (m.data != null && Object.hasOwnProperty.call(m, "data"))
                w.uint32(26).bytes(m.data);
            return w;
        };

        /**
         * Decodes a Setting message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Setting
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.Setting} Setting
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Setting.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.Setting();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.name = r.string();
                    break;
                case 2:
                    m.value = r.string();
                    break;
                case 3:
                    m.data = r.bytes();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return Setting;
    })();

    proto.ServicesConfigurationList = (function() {

        /**
         * Properties of a ServicesConfigurationList.
         * @memberof proto
         * @interface IServicesConfigurationList
         * @property {Array.<proto.ISetting>|null} [nameValue] ServicesConfigurationList nameValue
         */

        /**
         * Constructs a new ServicesConfigurationList.
         * @memberof proto
         * @classdesc Represents a ServicesConfigurationList.
         * @implements IServicesConfigurationList
         * @constructor
         * @param {proto.IServicesConfigurationList=} [p] Properties to set
         */
        function ServicesConfigurationList(p) {
            this.nameValue = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ServicesConfigurationList nameValue.
         * @member {Array.<proto.ISetting>} nameValue
         * @memberof proto.ServicesConfigurationList
         * @instance
         */
        ServicesConfigurationList.prototype.nameValue = $util.emptyArray;

        /**
         * Creates a new ServicesConfigurationList instance using the specified properties.
         * @function create
         * @memberof proto.ServicesConfigurationList
         * @static
         * @param {proto.IServicesConfigurationList=} [properties] Properties to set
         * @returns {proto.ServicesConfigurationList} ServicesConfigurationList instance
         */
        ServicesConfigurationList.create = function create(properties) {
            return new ServicesConfigurationList(properties);
        };

        /**
         * Encodes the specified ServicesConfigurationList message. Does not implicitly {@link proto.ServicesConfigurationList.verify|verify} messages.
         * @function encode
         * @memberof proto.ServicesConfigurationList
         * @static
         * @param {proto.IServicesConfigurationList} m ServicesConfigurationList message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServicesConfigurationList.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.nameValue != null && m.nameValue.length) {
                for (var i = 0; i < m.nameValue.length; ++i)
                    $root.proto.Setting.encode(m.nameValue[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a ServicesConfigurationList message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ServicesConfigurationList
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ServicesConfigurationList} ServicesConfigurationList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServicesConfigurationList.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ServicesConfigurationList();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    if (!(m.nameValue && m.nameValue.length))
                        m.nameValue = [];
                    m.nameValue.push($root.proto.Setting.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ServicesConfigurationList;
    })();

    proto.TokenRelationship = (function() {

        /**
         * Properties of a TokenRelationship.
         * @memberof proto
         * @interface ITokenRelationship
         * @property {proto.ITokenID|null} [tokenId] TokenRelationship tokenId
         * @property {string|null} [symbol] TokenRelationship symbol
         * @property {Long|null} [balance] TokenRelationship balance
         * @property {proto.TokenKycStatus|null} [kycStatus] TokenRelationship kycStatus
         * @property {proto.TokenFreezeStatus|null} [freezeStatus] TokenRelationship freezeStatus
         * @property {number|null} [decimals] TokenRelationship decimals
         */

        /**
         * Constructs a new TokenRelationship.
         * @memberof proto
         * @classdesc Represents a TokenRelationship.
         * @implements ITokenRelationship
         * @constructor
         * @param {proto.ITokenRelationship=} [p] Properties to set
         */
        function TokenRelationship(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TokenRelationship tokenId.
         * @member {proto.ITokenID|null|undefined} tokenId
         * @memberof proto.TokenRelationship
         * @instance
         */
        TokenRelationship.prototype.tokenId = null;

        /**
         * TokenRelationship symbol.
         * @member {string} symbol
         * @memberof proto.TokenRelationship
         * @instance
         */
        TokenRelationship.prototype.symbol = "";

        /**
         * TokenRelationship balance.
         * @member {Long} balance
         * @memberof proto.TokenRelationship
         * @instance
         */
        TokenRelationship.prototype.balance = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TokenRelationship kycStatus.
         * @member {proto.TokenKycStatus} kycStatus
         * @memberof proto.TokenRelationship
         * @instance
         */
        TokenRelationship.prototype.kycStatus = 0;

        /**
         * TokenRelationship freezeStatus.
         * @member {proto.TokenFreezeStatus} freezeStatus
         * @memberof proto.TokenRelationship
         * @instance
         */
        TokenRelationship.prototype.freezeStatus = 0;

        /**
         * TokenRelationship decimals.
         * @member {number} decimals
         * @memberof proto.TokenRelationship
         * @instance
         */
        TokenRelationship.prototype.decimals = 0;

        /**
         * Creates a new TokenRelationship instance using the specified properties.
         * @function create
         * @memberof proto.TokenRelationship
         * @static
         * @param {proto.ITokenRelationship=} [properties] Properties to set
         * @returns {proto.TokenRelationship} TokenRelationship instance
         */
        TokenRelationship.create = function create(properties) {
            return new TokenRelationship(properties);
        };

        /**
         * Encodes the specified TokenRelationship message. Does not implicitly {@link proto.TokenRelationship.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenRelationship
         * @static
         * @param {proto.ITokenRelationship} m TokenRelationship message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenRelationship.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.tokenId != null && Object.hasOwnProperty.call(m, "tokenId"))
                $root.proto.TokenID.encode(m.tokenId, w.uint32(10).fork()).ldelim();
            if (m.symbol != null && Object.hasOwnProperty.call(m, "symbol"))
                w.uint32(18).string(m.symbol);
            if (m.balance != null && Object.hasOwnProperty.call(m, "balance"))
                w.uint32(24).uint64(m.balance);
            if (m.kycStatus != null && Object.hasOwnProperty.call(m, "kycStatus"))
                w.uint32(32).int32(m.kycStatus);
            if (m.freezeStatus != null && Object.hasOwnProperty.call(m, "freezeStatus"))
                w.uint32(40).int32(m.freezeStatus);
            if (m.decimals != null && Object.hasOwnProperty.call(m, "decimals"))
                w.uint32(48).uint32(m.decimals);
            return w;
        };

        /**
         * Decodes a TokenRelationship message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenRelationship
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenRelationship} TokenRelationship
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenRelationship.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenRelationship();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.tokenId = $root.proto.TokenID.decode(r, r.uint32());
                    break;
                case 2:
                    m.symbol = r.string();
                    break;
                case 3:
                    m.balance = r.uint64();
                    break;
                case 4:
                    m.kycStatus = r.int32();
                    break;
                case 5:
                    m.freezeStatus = r.int32();
                    break;
                case 6:
                    m.decimals = r.uint32();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TokenRelationship;
    })();

    proto.TokenBalance = (function() {

        /**
         * Properties of a TokenBalance.
         * @memberof proto
         * @interface ITokenBalance
         * @property {proto.ITokenID|null} [tokenId] TokenBalance tokenId
         * @property {Long|null} [balance] TokenBalance balance
         * @property {number|null} [decimals] TokenBalance decimals
         */

        /**
         * Constructs a new TokenBalance.
         * @memberof proto
         * @classdesc Represents a TokenBalance.
         * @implements ITokenBalance
         * @constructor
         * @param {proto.ITokenBalance=} [p] Properties to set
         */
        function TokenBalance(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TokenBalance tokenId.
         * @member {proto.ITokenID|null|undefined} tokenId
         * @memberof proto.TokenBalance
         * @instance
         */
        TokenBalance.prototype.tokenId = null;

        /**
         * TokenBalance balance.
         * @member {Long} balance
         * @memberof proto.TokenBalance
         * @instance
         */
        TokenBalance.prototype.balance = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TokenBalance decimals.
         * @member {number} decimals
         * @memberof proto.TokenBalance
         * @instance
         */
        TokenBalance.prototype.decimals = 0;

        /**
         * Creates a new TokenBalance instance using the specified properties.
         * @function create
         * @memberof proto.TokenBalance
         * @static
         * @param {proto.ITokenBalance=} [properties] Properties to set
         * @returns {proto.TokenBalance} TokenBalance instance
         */
        TokenBalance.create = function create(properties) {
            return new TokenBalance(properties);
        };

        /**
         * Encodes the specified TokenBalance message. Does not implicitly {@link proto.TokenBalance.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenBalance
         * @static
         * @param {proto.ITokenBalance} m TokenBalance message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenBalance.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.tokenId != null && Object.hasOwnProperty.call(m, "tokenId"))
                $root.proto.TokenID.encode(m.tokenId, w.uint32(10).fork()).ldelim();
            if (m.balance != null && Object.hasOwnProperty.call(m, "balance"))
                w.uint32(16).uint64(m.balance);
            if (m.decimals != null && Object.hasOwnProperty.call(m, "decimals"))
                w.uint32(24).uint32(m.decimals);
            return w;
        };

        /**
         * Decodes a TokenBalance message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenBalance
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenBalance} TokenBalance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenBalance.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenBalance();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.tokenId = $root.proto.TokenID.decode(r, r.uint32());
                    break;
                case 2:
                    m.balance = r.uint64();
                    break;
                case 3:
                    m.decimals = r.uint32();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TokenBalance;
    })();

    proto.TokenBalances = (function() {

        /**
         * Properties of a TokenBalances.
         * @memberof proto
         * @interface ITokenBalances
         * @property {Array.<proto.ITokenBalance>|null} [tokenBalances] TokenBalances tokenBalances
         */

        /**
         * Constructs a new TokenBalances.
         * @memberof proto
         * @classdesc Represents a TokenBalances.
         * @implements ITokenBalances
         * @constructor
         * @param {proto.ITokenBalances=} [p] Properties to set
         */
        function TokenBalances(p) {
            this.tokenBalances = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TokenBalances tokenBalances.
         * @member {Array.<proto.ITokenBalance>} tokenBalances
         * @memberof proto.TokenBalances
         * @instance
         */
        TokenBalances.prototype.tokenBalances = $util.emptyArray;

        /**
         * Creates a new TokenBalances instance using the specified properties.
         * @function create
         * @memberof proto.TokenBalances
         * @static
         * @param {proto.ITokenBalances=} [properties] Properties to set
         * @returns {proto.TokenBalances} TokenBalances instance
         */
        TokenBalances.create = function create(properties) {
            return new TokenBalances(properties);
        };

        /**
         * Encodes the specified TokenBalances message. Does not implicitly {@link proto.TokenBalances.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenBalances
         * @static
         * @param {proto.ITokenBalances} m TokenBalances message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenBalances.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.tokenBalances != null && m.tokenBalances.length) {
                for (var i = 0; i < m.tokenBalances.length; ++i)
                    $root.proto.TokenBalance.encode(m.tokenBalances[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TokenBalances message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenBalances
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenBalances} TokenBalances
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenBalances.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenBalances();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    if (!(m.tokenBalances && m.tokenBalances.length))
                        m.tokenBalances = [];
                    m.tokenBalances.push($root.proto.TokenBalance.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TokenBalances;
    })();

    proto.Timestamp = (function() {

        /**
         * Properties of a Timestamp.
         * @memberof proto
         * @interface ITimestamp
         * @property {Long|null} [seconds] Timestamp seconds
         * @property {number|null} [nanos] Timestamp nanos
         */

        /**
         * Constructs a new Timestamp.
         * @memberof proto
         * @classdesc Represents a Timestamp.
         * @implements ITimestamp
         * @constructor
         * @param {proto.ITimestamp=} [p] Properties to set
         */
        function Timestamp(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Timestamp seconds.
         * @member {Long} seconds
         * @memberof proto.Timestamp
         * @instance
         */
        Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Timestamp nanos.
         * @member {number} nanos
         * @memberof proto.Timestamp
         * @instance
         */
        Timestamp.prototype.nanos = 0;

        /**
         * Creates a new Timestamp instance using the specified properties.
         * @function create
         * @memberof proto.Timestamp
         * @static
         * @param {proto.ITimestamp=} [properties] Properties to set
         * @returns {proto.Timestamp} Timestamp instance
         */
        Timestamp.create = function create(properties) {
            return new Timestamp(properties);
        };

        /**
         * Encodes the specified Timestamp message. Does not implicitly {@link proto.Timestamp.verify|verify} messages.
         * @function encode
         * @memberof proto.Timestamp
         * @static
         * @param {proto.ITimestamp} m Timestamp message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Timestamp.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.seconds != null && Object.hasOwnProperty.call(m, "seconds"))
                w.uint32(8).int64(m.seconds);
            if (m.nanos != null && Object.hasOwnProperty.call(m, "nanos"))
                w.uint32(16).int32(m.nanos);
            return w;
        };

        /**
         * Decodes a Timestamp message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Timestamp
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.Timestamp} Timestamp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Timestamp.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.Timestamp();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.seconds = r.int64();
                    break;
                case 2:
                    m.nanos = r.int32();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return Timestamp;
    })();

    proto.TimestampSeconds = (function() {

        /**
         * Properties of a TimestampSeconds.
         * @memberof proto
         * @interface ITimestampSeconds
         * @property {Long|null} [seconds] TimestampSeconds seconds
         */

        /**
         * Constructs a new TimestampSeconds.
         * @memberof proto
         * @classdesc Represents a TimestampSeconds.
         * @implements ITimestampSeconds
         * @constructor
         * @param {proto.ITimestampSeconds=} [p] Properties to set
         */
        function TimestampSeconds(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TimestampSeconds seconds.
         * @member {Long} seconds
         * @memberof proto.TimestampSeconds
         * @instance
         */
        TimestampSeconds.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new TimestampSeconds instance using the specified properties.
         * @function create
         * @memberof proto.TimestampSeconds
         * @static
         * @param {proto.ITimestampSeconds=} [properties] Properties to set
         * @returns {proto.TimestampSeconds} TimestampSeconds instance
         */
        TimestampSeconds.create = function create(properties) {
            return new TimestampSeconds(properties);
        };

        /**
         * Encodes the specified TimestampSeconds message. Does not implicitly {@link proto.TimestampSeconds.verify|verify} messages.
         * @function encode
         * @memberof proto.TimestampSeconds
         * @static
         * @param {proto.ITimestampSeconds} m TimestampSeconds message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TimestampSeconds.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.seconds != null && Object.hasOwnProperty.call(m, "seconds"))
                w.uint32(8).int64(m.seconds);
            return w;
        };

        /**
         * Decodes a TimestampSeconds message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TimestampSeconds
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TimestampSeconds} TimestampSeconds
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TimestampSeconds.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TimestampSeconds();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.seconds = r.int64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TimestampSeconds;
    })();

    proto.ConsensusCreateTopicTransactionBody = (function() {

        /**
         * Properties of a ConsensusCreateTopicTransactionBody.
         * @memberof proto
         * @interface IConsensusCreateTopicTransactionBody
         * @property {string|null} [memo] ConsensusCreateTopicTransactionBody memo
         * @property {proto.IKey|null} [adminKey] ConsensusCreateTopicTransactionBody adminKey
         * @property {proto.IKey|null} [submitKey] ConsensusCreateTopicTransactionBody submitKey
         * @property {proto.IDuration|null} [autoRenewPeriod] ConsensusCreateTopicTransactionBody autoRenewPeriod
         * @property {proto.IAccountID|null} [autoRenewAccount] ConsensusCreateTopicTransactionBody autoRenewAccount
         */

        /**
         * Constructs a new ConsensusCreateTopicTransactionBody.
         * @memberof proto
         * @classdesc Represents a ConsensusCreateTopicTransactionBody.
         * @implements IConsensusCreateTopicTransactionBody
         * @constructor
         * @param {proto.IConsensusCreateTopicTransactionBody=} [p] Properties to set
         */
        function ConsensusCreateTopicTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ConsensusCreateTopicTransactionBody memo.
         * @member {string} memo
         * @memberof proto.ConsensusCreateTopicTransactionBody
         * @instance
         */
        ConsensusCreateTopicTransactionBody.prototype.memo = "";

        /**
         * ConsensusCreateTopicTransactionBody adminKey.
         * @member {proto.IKey|null|undefined} adminKey
         * @memberof proto.ConsensusCreateTopicTransactionBody
         * @instance
         */
        ConsensusCreateTopicTransactionBody.prototype.adminKey = null;

        /**
         * ConsensusCreateTopicTransactionBody submitKey.
         * @member {proto.IKey|null|undefined} submitKey
         * @memberof proto.ConsensusCreateTopicTransactionBody
         * @instance
         */
        ConsensusCreateTopicTransactionBody.prototype.submitKey = null;

        /**
         * ConsensusCreateTopicTransactionBody autoRenewPeriod.
         * @member {proto.IDuration|null|undefined} autoRenewPeriod
         * @memberof proto.ConsensusCreateTopicTransactionBody
         * @instance
         */
        ConsensusCreateTopicTransactionBody.prototype.autoRenewPeriod = null;

        /**
         * ConsensusCreateTopicTransactionBody autoRenewAccount.
         * @member {proto.IAccountID|null|undefined} autoRenewAccount
         * @memberof proto.ConsensusCreateTopicTransactionBody
         * @instance
         */
        ConsensusCreateTopicTransactionBody.prototype.autoRenewAccount = null;

        /**
         * Creates a new ConsensusCreateTopicTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.ConsensusCreateTopicTransactionBody
         * @static
         * @param {proto.IConsensusCreateTopicTransactionBody=} [properties] Properties to set
         * @returns {proto.ConsensusCreateTopicTransactionBody} ConsensusCreateTopicTransactionBody instance
         */
        ConsensusCreateTopicTransactionBody.create = function create(properties) {
            return new ConsensusCreateTopicTransactionBody(properties);
        };

        /**
         * Encodes the specified ConsensusCreateTopicTransactionBody message. Does not implicitly {@link proto.ConsensusCreateTopicTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.ConsensusCreateTopicTransactionBody
         * @static
         * @param {proto.IConsensusCreateTopicTransactionBody} m ConsensusCreateTopicTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConsensusCreateTopicTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                w.uint32(10).string(m.memo);
            if (m.adminKey != null && Object.hasOwnProperty.call(m, "adminKey"))
                $root.proto.Key.encode(m.adminKey, w.uint32(18).fork()).ldelim();
            if (m.submitKey != null && Object.hasOwnProperty.call(m, "submitKey"))
                $root.proto.Key.encode(m.submitKey, w.uint32(26).fork()).ldelim();
            if (m.autoRenewPeriod != null && Object.hasOwnProperty.call(m, "autoRenewPeriod"))
                $root.proto.Duration.encode(m.autoRenewPeriod, w.uint32(50).fork()).ldelim();
            if (m.autoRenewAccount != null && Object.hasOwnProperty.call(m, "autoRenewAccount"))
                $root.proto.AccountID.encode(m.autoRenewAccount, w.uint32(58).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ConsensusCreateTopicTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ConsensusCreateTopicTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ConsensusCreateTopicTransactionBody} ConsensusCreateTopicTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConsensusCreateTopicTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ConsensusCreateTopicTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.memo = r.string();
                    break;
                case 2:
                    m.adminKey = $root.proto.Key.decode(r, r.uint32());
                    break;
                case 3:
                    m.submitKey = $root.proto.Key.decode(r, r.uint32());
                    break;
                case 6:
                    m.autoRenewPeriod = $root.proto.Duration.decode(r, r.uint32());
                    break;
                case 7:
                    m.autoRenewAccount = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ConsensusCreateTopicTransactionBody;
    })();

    proto.Duration = (function() {

        /**
         * Properties of a Duration.
         * @memberof proto
         * @interface IDuration
         * @property {Long|null} [seconds] Duration seconds
         */

        /**
         * Constructs a new Duration.
         * @memberof proto
         * @classdesc Represents a Duration.
         * @implements IDuration
         * @constructor
         * @param {proto.IDuration=} [p] Properties to set
         */
        function Duration(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Duration seconds.
         * @member {Long} seconds
         * @memberof proto.Duration
         * @instance
         */
        Duration.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Duration instance using the specified properties.
         * @function create
         * @memberof proto.Duration
         * @static
         * @param {proto.IDuration=} [properties] Properties to set
         * @returns {proto.Duration} Duration instance
         */
        Duration.create = function create(properties) {
            return new Duration(properties);
        };

        /**
         * Encodes the specified Duration message. Does not implicitly {@link proto.Duration.verify|verify} messages.
         * @function encode
         * @memberof proto.Duration
         * @static
         * @param {proto.IDuration} m Duration message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Duration.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.seconds != null && Object.hasOwnProperty.call(m, "seconds"))
                w.uint32(8).int64(m.seconds);
            return w;
        };

        /**
         * Decodes a Duration message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Duration
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.Duration} Duration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Duration.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.Duration();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.seconds = r.int64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return Duration;
    })();

    proto.ConsensusDeleteTopicTransactionBody = (function() {

        /**
         * Properties of a ConsensusDeleteTopicTransactionBody.
         * @memberof proto
         * @interface IConsensusDeleteTopicTransactionBody
         * @property {proto.ITopicID|null} [topicID] ConsensusDeleteTopicTransactionBody topicID
         */

        /**
         * Constructs a new ConsensusDeleteTopicTransactionBody.
         * @memberof proto
         * @classdesc Represents a ConsensusDeleteTopicTransactionBody.
         * @implements IConsensusDeleteTopicTransactionBody
         * @constructor
         * @param {proto.IConsensusDeleteTopicTransactionBody=} [p] Properties to set
         */
        function ConsensusDeleteTopicTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ConsensusDeleteTopicTransactionBody topicID.
         * @member {proto.ITopicID|null|undefined} topicID
         * @memberof proto.ConsensusDeleteTopicTransactionBody
         * @instance
         */
        ConsensusDeleteTopicTransactionBody.prototype.topicID = null;

        /**
         * Creates a new ConsensusDeleteTopicTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.ConsensusDeleteTopicTransactionBody
         * @static
         * @param {proto.IConsensusDeleteTopicTransactionBody=} [properties] Properties to set
         * @returns {proto.ConsensusDeleteTopicTransactionBody} ConsensusDeleteTopicTransactionBody instance
         */
        ConsensusDeleteTopicTransactionBody.create = function create(properties) {
            return new ConsensusDeleteTopicTransactionBody(properties);
        };

        /**
         * Encodes the specified ConsensusDeleteTopicTransactionBody message. Does not implicitly {@link proto.ConsensusDeleteTopicTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.ConsensusDeleteTopicTransactionBody
         * @static
         * @param {proto.IConsensusDeleteTopicTransactionBody} m ConsensusDeleteTopicTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConsensusDeleteTopicTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
                $root.proto.TopicID.encode(m.topicID, w.uint32(10).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ConsensusDeleteTopicTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ConsensusDeleteTopicTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ConsensusDeleteTopicTransactionBody} ConsensusDeleteTopicTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConsensusDeleteTopicTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ConsensusDeleteTopicTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.topicID = $root.proto.TopicID.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ConsensusDeleteTopicTransactionBody;
    })();

    proto.ConsensusGetTopicInfoQuery = (function() {

        /**
         * Properties of a ConsensusGetTopicInfoQuery.
         * @memberof proto
         * @interface IConsensusGetTopicInfoQuery
         * @property {proto.IQueryHeader|null} [header] ConsensusGetTopicInfoQuery header
         * @property {proto.ITopicID|null} [topicID] ConsensusGetTopicInfoQuery topicID
         */

        /**
         * Constructs a new ConsensusGetTopicInfoQuery.
         * @memberof proto
         * @classdesc Represents a ConsensusGetTopicInfoQuery.
         * @implements IConsensusGetTopicInfoQuery
         * @constructor
         * @param {proto.IConsensusGetTopicInfoQuery=} [p] Properties to set
         */
        function ConsensusGetTopicInfoQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ConsensusGetTopicInfoQuery header.
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.ConsensusGetTopicInfoQuery
         * @instance
         */
        ConsensusGetTopicInfoQuery.prototype.header = null;

        /**
         * ConsensusGetTopicInfoQuery topicID.
         * @member {proto.ITopicID|null|undefined} topicID
         * @memberof proto.ConsensusGetTopicInfoQuery
         * @instance
         */
        ConsensusGetTopicInfoQuery.prototype.topicID = null;

        /**
         * Creates a new ConsensusGetTopicInfoQuery instance using the specified properties.
         * @function create
         * @memberof proto.ConsensusGetTopicInfoQuery
         * @static
         * @param {proto.IConsensusGetTopicInfoQuery=} [properties] Properties to set
         * @returns {proto.ConsensusGetTopicInfoQuery} ConsensusGetTopicInfoQuery instance
         */
        ConsensusGetTopicInfoQuery.create = function create(properties) {
            return new ConsensusGetTopicInfoQuery(properties);
        };

        /**
         * Encodes the specified ConsensusGetTopicInfoQuery message. Does not implicitly {@link proto.ConsensusGetTopicInfoQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.ConsensusGetTopicInfoQuery
         * @static
         * @param {proto.IConsensusGetTopicInfoQuery} m ConsensusGetTopicInfoQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConsensusGetTopicInfoQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
                $root.proto.TopicID.encode(m.topicID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ConsensusGetTopicInfoQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ConsensusGetTopicInfoQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ConsensusGetTopicInfoQuery} ConsensusGetTopicInfoQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConsensusGetTopicInfoQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ConsensusGetTopicInfoQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.topicID = $root.proto.TopicID.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ConsensusGetTopicInfoQuery;
    })();

    proto.ConsensusGetTopicInfoResponse = (function() {

        /**
         * Properties of a ConsensusGetTopicInfoResponse.
         * @memberof proto
         * @interface IConsensusGetTopicInfoResponse
         * @property {proto.IResponseHeader|null} [header] ConsensusGetTopicInfoResponse header
         * @property {proto.ITopicID|null} [topicID] ConsensusGetTopicInfoResponse topicID
         * @property {proto.IConsensusTopicInfo|null} [topicInfo] ConsensusGetTopicInfoResponse topicInfo
         */

        /**
         * Constructs a new ConsensusGetTopicInfoResponse.
         * @memberof proto
         * @classdesc Represents a ConsensusGetTopicInfoResponse.
         * @implements IConsensusGetTopicInfoResponse
         * @constructor
         * @param {proto.IConsensusGetTopicInfoResponse=} [p] Properties to set
         */
        function ConsensusGetTopicInfoResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ConsensusGetTopicInfoResponse header.
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.ConsensusGetTopicInfoResponse
         * @instance
         */
        ConsensusGetTopicInfoResponse.prototype.header = null;

        /**
         * ConsensusGetTopicInfoResponse topicID.
         * @member {proto.ITopicID|null|undefined} topicID
         * @memberof proto.ConsensusGetTopicInfoResponse
         * @instance
         */
        ConsensusGetTopicInfoResponse.prototype.topicID = null;

        /**
         * ConsensusGetTopicInfoResponse topicInfo.
         * @member {proto.IConsensusTopicInfo|null|undefined} topicInfo
         * @memberof proto.ConsensusGetTopicInfoResponse
         * @instance
         */
        ConsensusGetTopicInfoResponse.prototype.topicInfo = null;

        /**
         * Creates a new ConsensusGetTopicInfoResponse instance using the specified properties.
         * @function create
         * @memberof proto.ConsensusGetTopicInfoResponse
         * @static
         * @param {proto.IConsensusGetTopicInfoResponse=} [properties] Properties to set
         * @returns {proto.ConsensusGetTopicInfoResponse} ConsensusGetTopicInfoResponse instance
         */
        ConsensusGetTopicInfoResponse.create = function create(properties) {
            return new ConsensusGetTopicInfoResponse(properties);
        };

        /**
         * Encodes the specified ConsensusGetTopicInfoResponse message. Does not implicitly {@link proto.ConsensusGetTopicInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ConsensusGetTopicInfoResponse
         * @static
         * @param {proto.IConsensusGetTopicInfoResponse} m ConsensusGetTopicInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConsensusGetTopicInfoResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
                $root.proto.TopicID.encode(m.topicID, w.uint32(18).fork()).ldelim();
            if (m.topicInfo != null && Object.hasOwnProperty.call(m, "topicInfo"))
                $root.proto.ConsensusTopicInfo.encode(m.topicInfo, w.uint32(42).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ConsensusGetTopicInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ConsensusGetTopicInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ConsensusGetTopicInfoResponse} ConsensusGetTopicInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConsensusGetTopicInfoResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ConsensusGetTopicInfoResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.topicID = $root.proto.TopicID.decode(r, r.uint32());
                    break;
                case 5:
                    m.topicInfo = $root.proto.ConsensusTopicInfo.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ConsensusGetTopicInfoResponse;
    })();

    /**
     * ResponseType enum.
     * @name proto.ResponseType
     * @enum {number}
     * @property {number} ANSWER_ONLY=0 ANSWER_ONLY value
     * @property {number} ANSWER_STATE_PROOF=1 ANSWER_STATE_PROOF value
     * @property {number} COST_ANSWER=2 COST_ANSWER value
     * @property {number} COST_ANSWER_STATE_PROOF=3 COST_ANSWER_STATE_PROOF value
     */
    proto.ResponseType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ANSWER_ONLY"] = 0;
        values[valuesById[1] = "ANSWER_STATE_PROOF"] = 1;
        values[valuesById[2] = "COST_ANSWER"] = 2;
        values[valuesById[3] = "COST_ANSWER_STATE_PROOF"] = 3;
        return values;
    })();

    proto.QueryHeader = (function() {

        /**
         * Properties of a QueryHeader.
         * @memberof proto
         * @interface IQueryHeader
         * @property {proto.ITransaction|null} [payment] QueryHeader payment
         * @property {proto.ResponseType|null} [responseType] QueryHeader responseType
         */

        /**
         * Constructs a new QueryHeader.
         * @memberof proto
         * @classdesc Represents a QueryHeader.
         * @implements IQueryHeader
         * @constructor
         * @param {proto.IQueryHeader=} [p] Properties to set
         */
        function QueryHeader(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * QueryHeader payment.
         * @member {proto.ITransaction|null|undefined} payment
         * @memberof proto.QueryHeader
         * @instance
         */
        QueryHeader.prototype.payment = null;

        /**
         * QueryHeader responseType.
         * @member {proto.ResponseType} responseType
         * @memberof proto.QueryHeader
         * @instance
         */
        QueryHeader.prototype.responseType = 0;

        /**
         * Creates a new QueryHeader instance using the specified properties.
         * @function create
         * @memberof proto.QueryHeader
         * @static
         * @param {proto.IQueryHeader=} [properties] Properties to set
         * @returns {proto.QueryHeader} QueryHeader instance
         */
        QueryHeader.create = function create(properties) {
            return new QueryHeader(properties);
        };

        /**
         * Encodes the specified QueryHeader message. Does not implicitly {@link proto.QueryHeader.verify|verify} messages.
         * @function encode
         * @memberof proto.QueryHeader
         * @static
         * @param {proto.IQueryHeader} m QueryHeader message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryHeader.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.payment != null && Object.hasOwnProperty.call(m, "payment"))
                $root.proto.Transaction.encode(m.payment, w.uint32(10).fork()).ldelim();
            if (m.responseType != null && Object.hasOwnProperty.call(m, "responseType"))
                w.uint32(16).int32(m.responseType);
            return w;
        };

        /**
         * Decodes a QueryHeader message from the specified reader or buffer.
         * @function decode
         * @memberof proto.QueryHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.QueryHeader} QueryHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryHeader.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.QueryHeader();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.payment = $root.proto.Transaction.decode(r, r.uint32());
                    break;
                case 2:
                    m.responseType = r.int32();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return QueryHeader;
    })();

    proto.Transaction = (function() {

        /**
         * Properties of a Transaction.
         * @memberof proto
         * @interface ITransaction
         * @property {proto.ITransactionBody|null} [body] Transaction body
         * @property {proto.ISignatureList|null} [sigs] Transaction sigs
         * @property {proto.ISignatureMap|null} [sigMap] Transaction sigMap
         * @property {Uint8Array|null} [bodyBytes] Transaction bodyBytes
         * @property {Uint8Array|null} [signedTransactionBytes] Transaction signedTransactionBytes
         */

        /**
         * Constructs a new Transaction.
         * @memberof proto
         * @classdesc Represents a Transaction.
         * @implements ITransaction
         * @constructor
         * @param {proto.ITransaction=} [p] Properties to set
         */
        function Transaction(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Transaction body.
         * @member {proto.ITransactionBody|null|undefined} body
         * @memberof proto.Transaction
         * @instance
         */
        Transaction.prototype.body = null;

        /**
         * Transaction sigs.
         * @member {proto.ISignatureList|null|undefined} sigs
         * @memberof proto.Transaction
         * @instance
         */
        Transaction.prototype.sigs = null;

        /**
         * Transaction sigMap.
         * @member {proto.ISignatureMap|null|undefined} sigMap
         * @memberof proto.Transaction
         * @instance
         */
        Transaction.prototype.sigMap = null;

        /**
         * Transaction bodyBytes.
         * @member {Uint8Array} bodyBytes
         * @memberof proto.Transaction
         * @instance
         */
        Transaction.prototype.bodyBytes = $util.newBuffer([]);

        /**
         * Transaction signedTransactionBytes.
         * @member {Uint8Array} signedTransactionBytes
         * @memberof proto.Transaction
         * @instance
         */
        Transaction.prototype.signedTransactionBytes = $util.newBuffer([]);

        /**
         * Creates a new Transaction instance using the specified properties.
         * @function create
         * @memberof proto.Transaction
         * @static
         * @param {proto.ITransaction=} [properties] Properties to set
         * @returns {proto.Transaction} Transaction instance
         */
        Transaction.create = function create(properties) {
            return new Transaction(properties);
        };

        /**
         * Encodes the specified Transaction message. Does not implicitly {@link proto.Transaction.verify|verify} messages.
         * @function encode
         * @memberof proto.Transaction
         * @static
         * @param {proto.ITransaction} m Transaction message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Transaction.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.body != null && Object.hasOwnProperty.call(m, "body"))
                $root.proto.TransactionBody.encode(m.body, w.uint32(10).fork()).ldelim();
            if (m.sigs != null && Object.hasOwnProperty.call(m, "sigs"))
                $root.proto.SignatureList.encode(m.sigs, w.uint32(18).fork()).ldelim();
            if (m.sigMap != null && Object.hasOwnProperty.call(m, "sigMap"))
                $root.proto.SignatureMap.encode(m.sigMap, w.uint32(26).fork()).ldelim();
            if (m.bodyBytes != null && Object.hasOwnProperty.call(m, "bodyBytes"))
                w.uint32(34).bytes(m.bodyBytes);
            if (m.signedTransactionBytes != null && Object.hasOwnProperty.call(m, "signedTransactionBytes"))
                w.uint32(42).bytes(m.signedTransactionBytes);
            return w;
        };

        /**
         * Decodes a Transaction message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Transaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.Transaction} Transaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Transaction.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.Transaction();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.body = $root.proto.TransactionBody.decode(r, r.uint32());
                    break;
                case 2:
                    m.sigs = $root.proto.SignatureList.decode(r, r.uint32());
                    break;
                case 3:
                    m.sigMap = $root.proto.SignatureMap.decode(r, r.uint32());
                    break;
                case 4:
                    m.bodyBytes = r.bytes();
                    break;
                case 5:
                    m.signedTransactionBytes = r.bytes();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return Transaction;
    })();

    proto.TransactionBody = (function() {

        /**
         * Properties of a TransactionBody.
         * @memberof proto
         * @interface ITransactionBody
         * @property {proto.ITransactionID|null} [transactionID] TransactionBody transactionID
         * @property {proto.IAccountID|null} [nodeAccountID] TransactionBody nodeAccountID
         * @property {Long|null} [transactionFee] TransactionBody transactionFee
         * @property {proto.IDuration|null} [transactionValidDuration] TransactionBody transactionValidDuration
         * @property {boolean|null} [generateRecord] TransactionBody generateRecord
         * @property {string|null} [memo] TransactionBody memo
         * @property {proto.IContractCallTransactionBody|null} [contractCall] TransactionBody contractCall
         * @property {proto.IContractCreateTransactionBody|null} [contractCreateInstance] TransactionBody contractCreateInstance
         * @property {proto.IContractUpdateTransactionBody|null} [contractUpdateInstance] TransactionBody contractUpdateInstance
         * @property {proto.IContractDeleteTransactionBody|null} [contractDeleteInstance] TransactionBody contractDeleteInstance
         * @property {proto.ICryptoAddLiveHashTransactionBody|null} [cryptoAddLiveHash] TransactionBody cryptoAddLiveHash
         * @property {proto.ICryptoCreateTransactionBody|null} [cryptoCreateAccount] TransactionBody cryptoCreateAccount
         * @property {proto.ICryptoDeleteTransactionBody|null} [cryptoDelete] TransactionBody cryptoDelete
         * @property {proto.ICryptoDeleteLiveHashTransactionBody|null} [cryptoDeleteLiveHash] TransactionBody cryptoDeleteLiveHash
         * @property {proto.ICryptoTransferTransactionBody|null} [cryptoTransfer] TransactionBody cryptoTransfer
         * @property {proto.ICryptoUpdateTransactionBody|null} [cryptoUpdateAccount] TransactionBody cryptoUpdateAccount
         * @property {proto.IFileAppendTransactionBody|null} [fileAppend] TransactionBody fileAppend
         * @property {proto.IFileCreateTransactionBody|null} [fileCreate] TransactionBody fileCreate
         * @property {proto.IFileDeleteTransactionBody|null} [fileDelete] TransactionBody fileDelete
         * @property {proto.IFileUpdateTransactionBody|null} [fileUpdate] TransactionBody fileUpdate
         * @property {proto.ISystemDeleteTransactionBody|null} [systemDelete] TransactionBody systemDelete
         * @property {proto.ISystemUndeleteTransactionBody|null} [systemUndelete] TransactionBody systemUndelete
         * @property {proto.IFreezeTransactionBody|null} [freeze] TransactionBody freeze
         * @property {proto.IConsensusCreateTopicTransactionBody|null} [consensusCreateTopic] TransactionBody consensusCreateTopic
         * @property {proto.IConsensusUpdateTopicTransactionBody|null} [consensusUpdateTopic] TransactionBody consensusUpdateTopic
         * @property {proto.IConsensusDeleteTopicTransactionBody|null} [consensusDeleteTopic] TransactionBody consensusDeleteTopic
         * @property {proto.IConsensusSubmitMessageTransactionBody|null} [consensusSubmitMessage] TransactionBody consensusSubmitMessage
         * @property {proto.IUncheckedSubmitBody|null} [uncheckedSubmit] TransactionBody uncheckedSubmit
         * @property {proto.ITokenCreateTransactionBody|null} [tokenCreation] TransactionBody tokenCreation
         * @property {proto.ITokenFreezeAccountTransactionBody|null} [tokenFreeze] TransactionBody tokenFreeze
         * @property {proto.ITokenUnfreezeAccountTransactionBody|null} [tokenUnfreeze] TransactionBody tokenUnfreeze
         * @property {proto.ITokenGrantKycTransactionBody|null} [tokenGrantKyc] TransactionBody tokenGrantKyc
         * @property {proto.ITokenRevokeKycTransactionBody|null} [tokenRevokeKyc] TransactionBody tokenRevokeKyc
         * @property {proto.ITokenDeleteTransactionBody|null} [tokenDeletion] TransactionBody tokenDeletion
         * @property {proto.ITokenUpdateTransactionBody|null} [tokenUpdate] TransactionBody tokenUpdate
         * @property {proto.ITokenMintTransactionBody|null} [tokenMint] TransactionBody tokenMint
         * @property {proto.ITokenBurnTransactionBody|null} [tokenBurn] TransactionBody tokenBurn
         * @property {proto.ITokenWipeAccountTransactionBody|null} [tokenWipe] TransactionBody tokenWipe
         * @property {proto.ITokenAssociateTransactionBody|null} [tokenAssociate] TransactionBody tokenAssociate
         * @property {proto.ITokenDissociateTransactionBody|null} [tokenDissociate] TransactionBody tokenDissociate
         * @property {proto.ITokenFeeScheduleUpdateTransactionBody|null} [tokenFeeScheduleUpdate] TransactionBody tokenFeeScheduleUpdate
         * @property {proto.IScheduleCreateTransactionBody|null} [scheduleCreate] TransactionBody scheduleCreate
         * @property {proto.IScheduleDeleteTransactionBody|null} [scheduleDelete] TransactionBody scheduleDelete
         * @property {proto.IScheduleSignTransactionBody|null} [scheduleSign] TransactionBody scheduleSign
         */

        /**
         * Constructs a new TransactionBody.
         * @memberof proto
         * @classdesc Represents a TransactionBody.
         * @implements ITransactionBody
         * @constructor
         * @param {proto.ITransactionBody=} [p] Properties to set
         */
        function TransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TransactionBody transactionID.
         * @member {proto.ITransactionID|null|undefined} transactionID
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.transactionID = null;

        /**
         * TransactionBody nodeAccountID.
         * @member {proto.IAccountID|null|undefined} nodeAccountID
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.nodeAccountID = null;

        /**
         * TransactionBody transactionFee.
         * @member {Long} transactionFee
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.transactionFee = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TransactionBody transactionValidDuration.
         * @member {proto.IDuration|null|undefined} transactionValidDuration
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.transactionValidDuration = null;

        /**
         * TransactionBody generateRecord.
         * @member {boolean} generateRecord
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.generateRecord = false;

        /**
         * TransactionBody memo.
         * @member {string} memo
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.memo = "";

        /**
         * TransactionBody contractCall.
         * @member {proto.IContractCallTransactionBody|null|undefined} contractCall
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.contractCall = null;

        /**
         * TransactionBody contractCreateInstance.
         * @member {proto.IContractCreateTransactionBody|null|undefined} contractCreateInstance
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.contractCreateInstance = null;

        /**
         * TransactionBody contractUpdateInstance.
         * @member {proto.IContractUpdateTransactionBody|null|undefined} contractUpdateInstance
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.contractUpdateInstance = null;

        /**
         * TransactionBody contractDeleteInstance.
         * @member {proto.IContractDeleteTransactionBody|null|undefined} contractDeleteInstance
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.contractDeleteInstance = null;

        /**
         * TransactionBody cryptoAddLiveHash.
         * @member {proto.ICryptoAddLiveHashTransactionBody|null|undefined} cryptoAddLiveHash
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.cryptoAddLiveHash = null;

        /**
         * TransactionBody cryptoCreateAccount.
         * @member {proto.ICryptoCreateTransactionBody|null|undefined} cryptoCreateAccount
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.cryptoCreateAccount = null;

        /**
         * TransactionBody cryptoDelete.
         * @member {proto.ICryptoDeleteTransactionBody|null|undefined} cryptoDelete
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.cryptoDelete = null;

        /**
         * TransactionBody cryptoDeleteLiveHash.
         * @member {proto.ICryptoDeleteLiveHashTransactionBody|null|undefined} cryptoDeleteLiveHash
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.cryptoDeleteLiveHash = null;

        /**
         * TransactionBody cryptoTransfer.
         * @member {proto.ICryptoTransferTransactionBody|null|undefined} cryptoTransfer
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.cryptoTransfer = null;

        /**
         * TransactionBody cryptoUpdateAccount.
         * @member {proto.ICryptoUpdateTransactionBody|null|undefined} cryptoUpdateAccount
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.cryptoUpdateAccount = null;

        /**
         * TransactionBody fileAppend.
         * @member {proto.IFileAppendTransactionBody|null|undefined} fileAppend
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.fileAppend = null;

        /**
         * TransactionBody fileCreate.
         * @member {proto.IFileCreateTransactionBody|null|undefined} fileCreate
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.fileCreate = null;

        /**
         * TransactionBody fileDelete.
         * @member {proto.IFileDeleteTransactionBody|null|undefined} fileDelete
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.fileDelete = null;

        /**
         * TransactionBody fileUpdate.
         * @member {proto.IFileUpdateTransactionBody|null|undefined} fileUpdate
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.fileUpdate = null;

        /**
         * TransactionBody systemDelete.
         * @member {proto.ISystemDeleteTransactionBody|null|undefined} systemDelete
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.systemDelete = null;

        /**
         * TransactionBody systemUndelete.
         * @member {proto.ISystemUndeleteTransactionBody|null|undefined} systemUndelete
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.systemUndelete = null;

        /**
         * TransactionBody freeze.
         * @member {proto.IFreezeTransactionBody|null|undefined} freeze
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.freeze = null;

        /**
         * TransactionBody consensusCreateTopic.
         * @member {proto.IConsensusCreateTopicTransactionBody|null|undefined} consensusCreateTopic
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.consensusCreateTopic = null;

        /**
         * TransactionBody consensusUpdateTopic.
         * @member {proto.IConsensusUpdateTopicTransactionBody|null|undefined} consensusUpdateTopic
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.consensusUpdateTopic = null;

        /**
         * TransactionBody consensusDeleteTopic.
         * @member {proto.IConsensusDeleteTopicTransactionBody|null|undefined} consensusDeleteTopic
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.consensusDeleteTopic = null;

        /**
         * TransactionBody consensusSubmitMessage.
         * @member {proto.IConsensusSubmitMessageTransactionBody|null|undefined} consensusSubmitMessage
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.consensusSubmitMessage = null;

        /**
         * TransactionBody uncheckedSubmit.
         * @member {proto.IUncheckedSubmitBody|null|undefined} uncheckedSubmit
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.uncheckedSubmit = null;

        /**
         * TransactionBody tokenCreation.
         * @member {proto.ITokenCreateTransactionBody|null|undefined} tokenCreation
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenCreation = null;

        /**
         * TransactionBody tokenFreeze.
         * @member {proto.ITokenFreezeAccountTransactionBody|null|undefined} tokenFreeze
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenFreeze = null;

        /**
         * TransactionBody tokenUnfreeze.
         * @member {proto.ITokenUnfreezeAccountTransactionBody|null|undefined} tokenUnfreeze
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenUnfreeze = null;

        /**
         * TransactionBody tokenGrantKyc.
         * @member {proto.ITokenGrantKycTransactionBody|null|undefined} tokenGrantKyc
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenGrantKyc = null;

        /**
         * TransactionBody tokenRevokeKyc.
         * @member {proto.ITokenRevokeKycTransactionBody|null|undefined} tokenRevokeKyc
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenRevokeKyc = null;

        /**
         * TransactionBody tokenDeletion.
         * @member {proto.ITokenDeleteTransactionBody|null|undefined} tokenDeletion
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenDeletion = null;

        /**
         * TransactionBody tokenUpdate.
         * @member {proto.ITokenUpdateTransactionBody|null|undefined} tokenUpdate
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenUpdate = null;

        /**
         * TransactionBody tokenMint.
         * @member {proto.ITokenMintTransactionBody|null|undefined} tokenMint
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenMint = null;

        /**
         * TransactionBody tokenBurn.
         * @member {proto.ITokenBurnTransactionBody|null|undefined} tokenBurn
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenBurn = null;

        /**
         * TransactionBody tokenWipe.
         * @member {proto.ITokenWipeAccountTransactionBody|null|undefined} tokenWipe
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenWipe = null;

        /**
         * TransactionBody tokenAssociate.
         * @member {proto.ITokenAssociateTransactionBody|null|undefined} tokenAssociate
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenAssociate = null;

        /**
         * TransactionBody tokenDissociate.
         * @member {proto.ITokenDissociateTransactionBody|null|undefined} tokenDissociate
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenDissociate = null;

        /**
         * TransactionBody tokenFeeScheduleUpdate.
         * @member {proto.ITokenFeeScheduleUpdateTransactionBody|null|undefined} tokenFeeScheduleUpdate
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.tokenFeeScheduleUpdate = null;

        /**
         * TransactionBody scheduleCreate.
         * @member {proto.IScheduleCreateTransactionBody|null|undefined} scheduleCreate
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.scheduleCreate = null;

        /**
         * TransactionBody scheduleDelete.
         * @member {proto.IScheduleDeleteTransactionBody|null|undefined} scheduleDelete
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.scheduleDelete = null;

        /**
         * TransactionBody scheduleSign.
         * @member {proto.IScheduleSignTransactionBody|null|undefined} scheduleSign
         * @memberof proto.TransactionBody
         * @instance
         */
        TransactionBody.prototype.scheduleSign = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * TransactionBody data.
         * @member {"contractCall"|"contractCreateInstance"|"contractUpdateInstance"|"contractDeleteInstance"|"cryptoAddLiveHash"|"cryptoCreateAccount"|"cryptoDelete"|"cryptoDeleteLiveHash"|"cryptoTransfer"|"cryptoUpdateAccount"|"fileAppend"|"fileCreate"|"fileDelete"|"fileUpdate"|"systemDelete"|"systemUndelete"|"freeze"|"consensusCreateTopic"|"consensusUpdateTopic"|"consensusDeleteTopic"|"consensusSubmitMessage"|"uncheckedSubmit"|"tokenCreation"|"tokenFreeze"|"tokenUnfreeze"|"tokenGrantKyc"|"tokenRevokeKyc"|"tokenDeletion"|"tokenUpdate"|"tokenMint"|"tokenBurn"|"tokenWipe"|"tokenAssociate"|"tokenDissociate"|"tokenFeeScheduleUpdate"|"scheduleCreate"|"scheduleDelete"|"scheduleSign"|undefined} data
         * @memberof proto.TransactionBody
         * @instance
         */
        Object.defineProperty(TransactionBody.prototype, "data", {
            get: $util.oneOfGetter($oneOfFields = ["contractCall", "contractCreateInstance", "contractUpdateInstance", "contractDeleteInstance", "cryptoAddLiveHash", "cryptoCreateAccount", "cryptoDelete", "cryptoDeleteLiveHash", "cryptoTransfer", "cryptoUpdateAccount", "fileAppend", "fileCreate", "fileDelete", "fileUpdate", "systemDelete", "systemUndelete", "freeze", "consensusCreateTopic", "consensusUpdateTopic", "consensusDeleteTopic", "consensusSubmitMessage", "uncheckedSubmit", "tokenCreation", "tokenFreeze", "tokenUnfreeze", "tokenGrantKyc", "tokenRevokeKyc", "tokenDeletion", "tokenUpdate", "tokenMint", "tokenBurn", "tokenWipe", "tokenAssociate", "tokenDissociate", "tokenFeeScheduleUpdate", "scheduleCreate", "scheduleDelete", "scheduleSign"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new TransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TransactionBody
         * @static
         * @param {proto.ITransactionBody=} [properties] Properties to set
         * @returns {proto.TransactionBody} TransactionBody instance
         */
        TransactionBody.create = function create(properties) {
            return new TransactionBody(properties);
        };

        /**
         * Encodes the specified TransactionBody message. Does not implicitly {@link proto.TransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionBody
         * @static
         * @param {proto.ITransactionBody} m TransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.transactionID != null && Object.hasOwnProperty.call(m, "transactionID"))
                $root.proto.TransactionID.encode(m.transactionID, w.uint32(10).fork()).ldelim();
            if (m.nodeAccountID != null && Object.hasOwnProperty.call(m, "nodeAccountID"))
                $root.proto.AccountID.encode(m.nodeAccountID, w.uint32(18).fork()).ldelim();
            if (m.transactionFee != null && Object.hasOwnProperty.call(m, "transactionFee"))
                w.uint32(24).uint64(m.transactionFee);
            if (m.transactionValidDuration != null && Object.hasOwnProperty.call(m, "transactionValidDuration"))
                $root.proto.Duration.encode(m.transactionValidDuration, w.uint32(34).fork()).ldelim();
            if (m.generateRecord != null && Object.hasOwnProperty.call(m, "generateRecord"))
                w.uint32(40).bool(m.generateRecord);
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                w.uint32(50).string(m.memo);
            if (m.contractCall != null && Object.hasOwnProperty.call(m, "contractCall"))
                $root.proto.ContractCallTransactionBody.encode(m.contractCall, w.uint32(58).fork()).ldelim();
            if (m.contractCreateInstance != null && Object.hasOwnProperty.call(m, "contractCreateInstance"))
                $root.proto.ContractCreateTransactionBody.encode(m.contractCreateInstance, w.uint32(66).fork()).ldelim();
            if (m.contractUpdateInstance != null && Object.hasOwnProperty.call(m, "contractUpdateInstance"))
                $root.proto.ContractUpdateTransactionBody.encode(m.contractUpdateInstance, w.uint32(74).fork()).ldelim();
            if (m.cryptoAddLiveHash != null && Object.hasOwnProperty.call(m, "cryptoAddLiveHash"))
                $root.proto.CryptoAddLiveHashTransactionBody.encode(m.cryptoAddLiveHash, w.uint32(82).fork()).ldelim();
            if (m.cryptoCreateAccount != null && Object.hasOwnProperty.call(m, "cryptoCreateAccount"))
                $root.proto.CryptoCreateTransactionBody.encode(m.cryptoCreateAccount, w.uint32(90).fork()).ldelim();
            if (m.cryptoDelete != null && Object.hasOwnProperty.call(m, "cryptoDelete"))
                $root.proto.CryptoDeleteTransactionBody.encode(m.cryptoDelete, w.uint32(98).fork()).ldelim();
            if (m.cryptoDeleteLiveHash != null && Object.hasOwnProperty.call(m, "cryptoDeleteLiveHash"))
                $root.proto.CryptoDeleteLiveHashTransactionBody.encode(m.cryptoDeleteLiveHash, w.uint32(106).fork()).ldelim();
            if (m.cryptoTransfer != null && Object.hasOwnProperty.call(m, "cryptoTransfer"))
                $root.proto.CryptoTransferTransactionBody.encode(m.cryptoTransfer, w.uint32(114).fork()).ldelim();
            if (m.cryptoUpdateAccount != null && Object.hasOwnProperty.call(m, "cryptoUpdateAccount"))
                $root.proto.CryptoUpdateTransactionBody.encode(m.cryptoUpdateAccount, w.uint32(122).fork()).ldelim();
            if (m.fileAppend != null && Object.hasOwnProperty.call(m, "fileAppend"))
                $root.proto.FileAppendTransactionBody.encode(m.fileAppend, w.uint32(130).fork()).ldelim();
            if (m.fileCreate != null && Object.hasOwnProperty.call(m, "fileCreate"))
                $root.proto.FileCreateTransactionBody.encode(m.fileCreate, w.uint32(138).fork()).ldelim();
            if (m.fileDelete != null && Object.hasOwnProperty.call(m, "fileDelete"))
                $root.proto.FileDeleteTransactionBody.encode(m.fileDelete, w.uint32(146).fork()).ldelim();
            if (m.fileUpdate != null && Object.hasOwnProperty.call(m, "fileUpdate"))
                $root.proto.FileUpdateTransactionBody.encode(m.fileUpdate, w.uint32(154).fork()).ldelim();
            if (m.systemDelete != null && Object.hasOwnProperty.call(m, "systemDelete"))
                $root.proto.SystemDeleteTransactionBody.encode(m.systemDelete, w.uint32(162).fork()).ldelim();
            if (m.systemUndelete != null && Object.hasOwnProperty.call(m, "systemUndelete"))
                $root.proto.SystemUndeleteTransactionBody.encode(m.systemUndelete, w.uint32(170).fork()).ldelim();
            if (m.contractDeleteInstance != null && Object.hasOwnProperty.call(m, "contractDeleteInstance"))
                $root.proto.ContractDeleteTransactionBody.encode(m.contractDeleteInstance, w.uint32(178).fork()).ldelim();
            if (m.freeze != null && Object.hasOwnProperty.call(m, "freeze"))
                $root.proto.FreezeTransactionBody.encode(m.freeze, w.uint32(186).fork()).ldelim();
            if (m.consensusCreateTopic != null && Object.hasOwnProperty.call(m, "consensusCreateTopic"))
                $root.proto.ConsensusCreateTopicTransactionBody.encode(m.consensusCreateTopic, w.uint32(194).fork()).ldelim();
            if (m.consensusUpdateTopic != null && Object.hasOwnProperty.call(m, "consensusUpdateTopic"))
                $root.proto.ConsensusUpdateTopicTransactionBody.encode(m.consensusUpdateTopic, w.uint32(202).fork()).ldelim();
            if (m.consensusDeleteTopic != null && Object.hasOwnProperty.call(m, "consensusDeleteTopic"))
                $root.proto.ConsensusDeleteTopicTransactionBody.encode(m.consensusDeleteTopic, w.uint32(210).fork()).ldelim();
            if (m.consensusSubmitMessage != null && Object.hasOwnProperty.call(m, "consensusSubmitMessage"))
                $root.proto.ConsensusSubmitMessageTransactionBody.encode(m.consensusSubmitMessage, w.uint32(218).fork()).ldelim();
            if (m.uncheckedSubmit != null && Object.hasOwnProperty.call(m, "uncheckedSubmit"))
                $root.proto.UncheckedSubmitBody.encode(m.uncheckedSubmit, w.uint32(226).fork()).ldelim();
            if (m.tokenCreation != null && Object.hasOwnProperty.call(m, "tokenCreation"))
                $root.proto.TokenCreateTransactionBody.encode(m.tokenCreation, w.uint32(234).fork()).ldelim();
            if (m.tokenFreeze != null && Object.hasOwnProperty.call(m, "tokenFreeze"))
                $root.proto.TokenFreezeAccountTransactionBody.encode(m.tokenFreeze, w.uint32(250).fork()).ldelim();
            if (m.tokenUnfreeze != null && Object.hasOwnProperty.call(m, "tokenUnfreeze"))
                $root.proto.TokenUnfreezeAccountTransactionBody.encode(m.tokenUnfreeze, w.uint32(258).fork()).ldelim();
            if (m.tokenGrantKyc != null && Object.hasOwnProperty.call(m, "tokenGrantKyc"))
                $root.proto.TokenGrantKycTransactionBody.encode(m.tokenGrantKyc, w.uint32(266).fork()).ldelim();
            if (m.tokenRevokeKyc != null && Object.hasOwnProperty.call(m, "tokenRevokeKyc"))
                $root.proto.TokenRevokeKycTransactionBody.encode(m.tokenRevokeKyc, w.uint32(274).fork()).ldelim();
            if (m.tokenDeletion != null && Object.hasOwnProperty.call(m, "tokenDeletion"))
                $root.proto.TokenDeleteTransactionBody.encode(m.tokenDeletion, w.uint32(282).fork()).ldelim();
            if (m.tokenUpdate != null && Object.hasOwnProperty.call(m, "tokenUpdate"))
                $root.proto.TokenUpdateTransactionBody.encode(m.tokenUpdate, w.uint32(290).fork()).ldelim();
            if (m.tokenMint != null && Object.hasOwnProperty.call(m, "tokenMint"))
                $root.proto.TokenMintTransactionBody.encode(m.tokenMint, w.uint32(298).fork()).ldelim();
            if (m.tokenBurn != null && Object.hasOwnProperty.call(m, "tokenBurn"))
                $root.proto.TokenBurnTransactionBody.encode(m.tokenBurn, w.uint32(306).fork()).ldelim();
            if (m.tokenWipe != null && Object.hasOwnProperty.call(m, "tokenWipe"))
                $root.proto.TokenWipeAccountTransactionBody.encode(m.tokenWipe, w.uint32(314).fork()).ldelim();
            if (m.tokenAssociate != null && Object.hasOwnProperty.call(m, "tokenAssociate"))
                $root.proto.TokenAssociateTransactionBody.encode(m.tokenAssociate, w.uint32(322).fork()).ldelim();
            if (m.tokenDissociate != null && Object.hasOwnProperty.call(m, "tokenDissociate"))
                $root.proto.TokenDissociateTransactionBody.encode(m.tokenDissociate, w.uint32(330).fork()).ldelim();
            if (m.scheduleCreate != null && Object.hasOwnProperty.call(m, "scheduleCreate"))
                $root.proto.ScheduleCreateTransactionBody.encode(m.scheduleCreate, w.uint32(338).fork()).ldelim();
            if (m.scheduleDelete != null && Object.hasOwnProperty.call(m, "scheduleDelete"))
                $root.proto.ScheduleDeleteTransactionBody.encode(m.scheduleDelete, w.uint32(346).fork()).ldelim();
            if (m.scheduleSign != null && Object.hasOwnProperty.call(m, "scheduleSign"))
                $root.proto.ScheduleSignTransactionBody.encode(m.scheduleSign, w.uint32(354).fork()).ldelim();
            if (m.tokenFeeScheduleUpdate != null && Object.hasOwnProperty.call(m, "tokenFeeScheduleUpdate"))
                $root.proto.TokenFeeScheduleUpdateTransactionBody.encode(m.tokenFeeScheduleUpdate, w.uint32(362).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionBody} TransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.transactionID = $root.proto.TransactionID.decode(r, r.uint32());
                    break;
                case 2:
                    m.nodeAccountID = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 3:
                    m.transactionFee = r.uint64();
                    break;
                case 4:
                    m.transactionValidDuration = $root.proto.Duration.decode(r, r.uint32());
                    break;
                case 5:
                    m.generateRecord = r.bool();
                    break;
                case 6:
                    m.memo = r.string();
                    break;
                case 7:
                    m.contractCall = $root.proto.ContractCallTransactionBody.decode(r, r.uint32());
                    break;
                case 8:
                    m.contractCreateInstance = $root.proto.ContractCreateTransactionBody.decode(r, r.uint32());
                    break;
                case 9:
                    m.contractUpdateInstance = $root.proto.ContractUpdateTransactionBody.decode(r, r.uint32());
                    break;
                case 22:
                    m.contractDeleteInstance = $root.proto.ContractDeleteTransactionBody.decode(r, r.uint32());
                    break;
                case 10:
                    m.cryptoAddLiveHash = $root.proto.CryptoAddLiveHashTransactionBody.decode(r, r.uint32());
                    break;
                case 11:
                    m.cryptoCreateAccount = $root.proto.CryptoCreateTransactionBody.decode(r, r.uint32());
                    break;
                case 12:
                    m.cryptoDelete = $root.proto.CryptoDeleteTransactionBody.decode(r, r.uint32());
                    break;
                case 13:
                    m.cryptoDeleteLiveHash = $root.proto.CryptoDeleteLiveHashTransactionBody.decode(r, r.uint32());
                    break;
                case 14:
                    m.cryptoTransfer = $root.proto.CryptoTransferTransactionBody.decode(r, r.uint32());
                    break;
                case 15:
                    m.cryptoUpdateAccount = $root.proto.CryptoUpdateTransactionBody.decode(r, r.uint32());
                    break;
                case 16:
                    m.fileAppend = $root.proto.FileAppendTransactionBody.decode(r, r.uint32());
                    break;
                case 17:
                    m.fileCreate = $root.proto.FileCreateTransactionBody.decode(r, r.uint32());
                    break;
                case 18:
                    m.fileDelete = $root.proto.FileDeleteTransactionBody.decode(r, r.uint32());
                    break;
                case 19:
                    m.fileUpdate = $root.proto.FileUpdateTransactionBody.decode(r, r.uint32());
                    break;
                case 20:
                    m.systemDelete = $root.proto.SystemDeleteTransactionBody.decode(r, r.uint32());
                    break;
                case 21:
                    m.systemUndelete = $root.proto.SystemUndeleteTransactionBody.decode(r, r.uint32());
                    break;
                case 23:
                    m.freeze = $root.proto.FreezeTransactionBody.decode(r, r.uint32());
                    break;
                case 24:
                    m.consensusCreateTopic = $root.proto.ConsensusCreateTopicTransactionBody.decode(r, r.uint32());
                    break;
                case 25:
                    m.consensusUpdateTopic = $root.proto.ConsensusUpdateTopicTransactionBody.decode(r, r.uint32());
                    break;
                case 26:
                    m.consensusDeleteTopic = $root.proto.ConsensusDeleteTopicTransactionBody.decode(r, r.uint32());
                    break;
                case 27:
                    m.consensusSubmitMessage = $root.proto.ConsensusSubmitMessageTransactionBody.decode(r, r.uint32());
                    break;
                case 28:
                    m.uncheckedSubmit = $root.proto.UncheckedSubmitBody.decode(r, r.uint32());
                    break;
                case 29:
                    m.tokenCreation = $root.proto.TokenCreateTransactionBody.decode(r, r.uint32());
                    break;
                case 31:
                    m.tokenFreeze = $root.proto.TokenFreezeAccountTransactionBody.decode(r, r.uint32());
                    break;
                case 32:
                    m.tokenUnfreeze = $root.proto.TokenUnfreezeAccountTransactionBody.decode(r, r.uint32());
                    break;
                case 33:
                    m.tokenGrantKyc = $root.proto.TokenGrantKycTransactionBody.decode(r, r.uint32());
                    break;
                case 34:
                    m.tokenRevokeKyc = $root.proto.TokenRevokeKycTransactionBody.decode(r, r.uint32());
                    break;
                case 35:
                    m.tokenDeletion = $root.proto.TokenDeleteTransactionBody.decode(r, r.uint32());
                    break;
                case 36:
                    m.tokenUpdate = $root.proto.TokenUpdateTransactionBody.decode(r, r.uint32());
                    break;
                case 37:
                    m.tokenMint = $root.proto.TokenMintTransactionBody.decode(r, r.uint32());
                    break;
                case 38:
                    m.tokenBurn = $root.proto.TokenBurnTransactionBody.decode(r, r.uint32());
                    break;
                case 39:
                    m.tokenWipe = $root.proto.TokenWipeAccountTransactionBody.decode(r, r.uint32());
                    break;
                case 40:
                    m.tokenAssociate = $root.proto.TokenAssociateTransactionBody.decode(r, r.uint32());
                    break;
                case 41:
                    m.tokenDissociate = $root.proto.TokenDissociateTransactionBody.decode(r, r.uint32());
                    break;
                case 45:
                    m.tokenFeeScheduleUpdate = $root.proto.TokenFeeScheduleUpdateTransactionBody.decode(r, r.uint32());
                    break;
                case 42:
                    m.scheduleCreate = $root.proto.ScheduleCreateTransactionBody.decode(r, r.uint32());
                    break;
                case 43:
                    m.scheduleDelete = $root.proto.ScheduleDeleteTransactionBody.decode(r, r.uint32());
                    break;
                case 44:
                    m.scheduleSign = $root.proto.ScheduleSignTransactionBody.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TransactionBody;
    })();

    proto.SystemDeleteTransactionBody = (function() {

        /**
         * Properties of a SystemDeleteTransactionBody.
         * @memberof proto
         * @interface ISystemDeleteTransactionBody
         * @property {proto.IFileID|null} [fileID] SystemDeleteTransactionBody fileID
         * @property {proto.IContractID|null} [contractID] SystemDeleteTransactionBody contractID
         * @property {proto.ITimestampSeconds|null} [expirationTime] SystemDeleteTransactionBody expirationTime
         */

        /**
         * Constructs a new SystemDeleteTransactionBody.
         * @memberof proto
         * @classdesc Represents a SystemDeleteTransactionBody.
         * @implements ISystemDeleteTransactionBody
         * @constructor
         * @param {proto.ISystemDeleteTransactionBody=} [p] Properties to set
         */
        function SystemDeleteTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * SystemDeleteTransactionBody fileID.
         * @member {proto.IFileID|null|undefined} fileID
         * @memberof proto.SystemDeleteTransactionBody
         * @instance
         */
        SystemDeleteTransactionBody.prototype.fileID = null;

        /**
         * SystemDeleteTransactionBody contractID.
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.SystemDeleteTransactionBody
         * @instance
         */
        SystemDeleteTransactionBody.prototype.contractID = null;

        /**
         * SystemDeleteTransactionBody expirationTime.
         * @member {proto.ITimestampSeconds|null|undefined} expirationTime
         * @memberof proto.SystemDeleteTransactionBody
         * @instance
         */
        SystemDeleteTransactionBody.prototype.expirationTime = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * SystemDeleteTransactionBody id.
         * @member {"fileID"|"contractID"|undefined} id
         * @memberof proto.SystemDeleteTransactionBody
         * @instance
         */
        Object.defineProperty(SystemDeleteTransactionBody.prototype, "id", {
            get: $util.oneOfGetter($oneOfFields = ["fileID", "contractID"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new SystemDeleteTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.SystemDeleteTransactionBody
         * @static
         * @param {proto.ISystemDeleteTransactionBody=} [properties] Properties to set
         * @returns {proto.SystemDeleteTransactionBody} SystemDeleteTransactionBody instance
         */
        SystemDeleteTransactionBody.create = function create(properties) {
            return new SystemDeleteTransactionBody(properties);
        };

        /**
         * Encodes the specified SystemDeleteTransactionBody message. Does not implicitly {@link proto.SystemDeleteTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.SystemDeleteTransactionBody
         * @static
         * @param {proto.ISystemDeleteTransactionBody} m SystemDeleteTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SystemDeleteTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                $root.proto.FileID.encode(m.fileID, w.uint32(10).fork()).ldelim();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(18).fork()).ldelim();
            if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                $root.proto.TimestampSeconds.encode(m.expirationTime, w.uint32(26).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a SystemDeleteTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SystemDeleteTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.SystemDeleteTransactionBody} SystemDeleteTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SystemDeleteTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.SystemDeleteTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.fileID = $root.proto.FileID.decode(r, r.uint32());
                    break;
                case 2:
                    m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                    break;
                case 3:
                    m.expirationTime = $root.proto.TimestampSeconds.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return SystemDeleteTransactionBody;
    })();

    proto.SystemUndeleteTransactionBody = (function() {

        /**
         * Properties of a SystemUndeleteTransactionBody.
         * @memberof proto
         * @interface ISystemUndeleteTransactionBody
         * @property {proto.IFileID|null} [fileID] SystemUndeleteTransactionBody fileID
         * @property {proto.IContractID|null} [contractID] SystemUndeleteTransactionBody contractID
         */

        /**
         * Constructs a new SystemUndeleteTransactionBody.
         * @memberof proto
         * @classdesc Represents a SystemUndeleteTransactionBody.
         * @implements ISystemUndeleteTransactionBody
         * @constructor
         * @param {proto.ISystemUndeleteTransactionBody=} [p] Properties to set
         */
        function SystemUndeleteTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * SystemUndeleteTransactionBody fileID.
         * @member {proto.IFileID|null|undefined} fileID
         * @memberof proto.SystemUndeleteTransactionBody
         * @instance
         */
        SystemUndeleteTransactionBody.prototype.fileID = null;

        /**
         * SystemUndeleteTransactionBody contractID.
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.SystemUndeleteTransactionBody
         * @instance
         */
        SystemUndeleteTransactionBody.prototype.contractID = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * SystemUndeleteTransactionBody id.
         * @member {"fileID"|"contractID"|undefined} id
         * @memberof proto.SystemUndeleteTransactionBody
         * @instance
         */
        Object.defineProperty(SystemUndeleteTransactionBody.prototype, "id", {
            get: $util.oneOfGetter($oneOfFields = ["fileID", "contractID"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new SystemUndeleteTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.SystemUndeleteTransactionBody
         * @static
         * @param {proto.ISystemUndeleteTransactionBody=} [properties] Properties to set
         * @returns {proto.SystemUndeleteTransactionBody} SystemUndeleteTransactionBody instance
         */
        SystemUndeleteTransactionBody.create = function create(properties) {
            return new SystemUndeleteTransactionBody(properties);
        };

        /**
         * Encodes the specified SystemUndeleteTransactionBody message. Does not implicitly {@link proto.SystemUndeleteTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.SystemUndeleteTransactionBody
         * @static
         * @param {proto.ISystemUndeleteTransactionBody} m SystemUndeleteTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SystemUndeleteTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                $root.proto.FileID.encode(m.fileID, w.uint32(10).fork()).ldelim();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a SystemUndeleteTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SystemUndeleteTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.SystemUndeleteTransactionBody} SystemUndeleteTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SystemUndeleteTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.SystemUndeleteTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.fileID = $root.proto.FileID.decode(r, r.uint32());
                    break;
                case 2:
                    m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return SystemUndeleteTransactionBody;
    })();

    proto.FreezeTransactionBody = (function() {

        /**
         * Properties of a FreezeTransactionBody.
         * @memberof proto
         * @interface IFreezeTransactionBody
         * @property {number|null} [startHour] FreezeTransactionBody startHour
         * @property {number|null} [startMin] FreezeTransactionBody startMin
         * @property {number|null} [endHour] FreezeTransactionBody endHour
         * @property {number|null} [endMin] FreezeTransactionBody endMin
         * @property {proto.IFileID|null} [updateFile] FreezeTransactionBody updateFile
         * @property {Uint8Array|null} [fileHash] FreezeTransactionBody fileHash
         */

        /**
         * Constructs a new FreezeTransactionBody.
         * @memberof proto
         * @classdesc Represents a FreezeTransactionBody.
         * @implements IFreezeTransactionBody
         * @constructor
         * @param {proto.IFreezeTransactionBody=} [p] Properties to set
         */
        function FreezeTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * FreezeTransactionBody startHour.
         * @member {number} startHour
         * @memberof proto.FreezeTransactionBody
         * @instance
         */
        FreezeTransactionBody.prototype.startHour = 0;

        /**
         * FreezeTransactionBody startMin.
         * @member {number} startMin
         * @memberof proto.FreezeTransactionBody
         * @instance
         */
        FreezeTransactionBody.prototype.startMin = 0;

        /**
         * FreezeTransactionBody endHour.
         * @member {number} endHour
         * @memberof proto.FreezeTransactionBody
         * @instance
         */
        FreezeTransactionBody.prototype.endHour = 0;

        /**
         * FreezeTransactionBody endMin.
         * @member {number} endMin
         * @memberof proto.FreezeTransactionBody
         * @instance
         */
        FreezeTransactionBody.prototype.endMin = 0;

        /**
         * FreezeTransactionBody updateFile.
         * @member {proto.IFileID|null|undefined} updateFile
         * @memberof proto.FreezeTransactionBody
         * @instance
         */
        FreezeTransactionBody.prototype.updateFile = null;

        /**
         * FreezeTransactionBody fileHash.
         * @member {Uint8Array} fileHash
         * @memberof proto.FreezeTransactionBody
         * @instance
         */
        FreezeTransactionBody.prototype.fileHash = $util.newBuffer([]);

        /**
         * Creates a new FreezeTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.FreezeTransactionBody
         * @static
         * @param {proto.IFreezeTransactionBody=} [properties] Properties to set
         * @returns {proto.FreezeTransactionBody} FreezeTransactionBody instance
         */
        FreezeTransactionBody.create = function create(properties) {
            return new FreezeTransactionBody(properties);
        };

        /**
         * Encodes the specified FreezeTransactionBody message. Does not implicitly {@link proto.FreezeTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.FreezeTransactionBody
         * @static
         * @param {proto.IFreezeTransactionBody} m FreezeTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FreezeTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.startHour != null && Object.hasOwnProperty.call(m, "startHour"))
                w.uint32(8).int32(m.startHour);
            if (m.startMin != null && Object.hasOwnProperty.call(m, "startMin"))
                w.uint32(16).int32(m.startMin);
            if (m.endHour != null && Object.hasOwnProperty.call(m, "endHour"))
                w.uint32(24).int32(m.endHour);
            if (m.endMin != null && Object.hasOwnProperty.call(m, "endMin"))
                w.uint32(32).int32(m.endMin);
            if (m.updateFile != null && Object.hasOwnProperty.call(m, "updateFile"))
                $root.proto.FileID.encode(m.updateFile, w.uint32(42).fork()).ldelim();
            if (m.fileHash != null && Object.hasOwnProperty.call(m, "fileHash"))
                w.uint32(50).bytes(m.fileHash);
            return w;
        };

        /**
         * Decodes a FreezeTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FreezeTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FreezeTransactionBody} FreezeTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FreezeTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.FreezeTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.startHour = r.int32();
                    break;
                case 2:
                    m.startMin = r.int32();
                    break;
                case 3:
                    m.endHour = r.int32();
                    break;
                case 4:
                    m.endMin = r.int32();
                    break;
                case 5:
                    m.updateFile = $root.proto.FileID.decode(r, r.uint32());
                    break;
                case 6:
                    m.fileHash = r.bytes();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return FreezeTransactionBody;
    })();

    proto.ContractCallTransactionBody = (function() {

        /**
         * Properties of a ContractCallTransactionBody.
         * @memberof proto
         * @interface IContractCallTransactionBody
         * @property {proto.IContractID|null} [contractID] ContractCallTransactionBody contractID
         * @property {Long|null} [gas] ContractCallTransactionBody gas
         * @property {Long|null} [amount] ContractCallTransactionBody amount
         * @property {Uint8Array|null} [functionParameters] ContractCallTransactionBody functionParameters
         */

        /**
         * Constructs a new ContractCallTransactionBody.
         * @memberof proto
         * @classdesc Represents a ContractCallTransactionBody.
         * @implements IContractCallTransactionBody
         * @constructor
         * @param {proto.IContractCallTransactionBody=} [p] Properties to set
         */
        function ContractCallTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ContractCallTransactionBody contractID.
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.ContractCallTransactionBody
         * @instance
         */
        ContractCallTransactionBody.prototype.contractID = null;

        /**
         * ContractCallTransactionBody gas.
         * @member {Long} gas
         * @memberof proto.ContractCallTransactionBody
         * @instance
         */
        ContractCallTransactionBody.prototype.gas = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ContractCallTransactionBody amount.
         * @member {Long} amount
         * @memberof proto.ContractCallTransactionBody
         * @instance
         */
        ContractCallTransactionBody.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ContractCallTransactionBody functionParameters.
         * @member {Uint8Array} functionParameters
         * @memberof proto.ContractCallTransactionBody
         * @instance
         */
        ContractCallTransactionBody.prototype.functionParameters = $util.newBuffer([]);

        /**
         * Creates a new ContractCallTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.ContractCallTransactionBody
         * @static
         * @param {proto.IContractCallTransactionBody=} [properties] Properties to set
         * @returns {proto.ContractCallTransactionBody} ContractCallTransactionBody instance
         */
        ContractCallTransactionBody.create = function create(properties) {
            return new ContractCallTransactionBody(properties);
        };

        /**
         * Encodes the specified ContractCallTransactionBody message. Does not implicitly {@link proto.ContractCallTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractCallTransactionBody
         * @static
         * @param {proto.IContractCallTransactionBody} m ContractCallTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractCallTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(10).fork()).ldelim();
            if (m.gas != null && Object.hasOwnProperty.call(m, "gas"))
                w.uint32(16).int64(m.gas);
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                w.uint32(24).int64(m.amount);
            if (m.functionParameters != null && Object.hasOwnProperty.call(m, "functionParameters"))
                w.uint32(34).bytes(m.functionParameters);
            return w;
        };

        /**
         * Decodes a ContractCallTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractCallTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractCallTransactionBody} ContractCallTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractCallTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ContractCallTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                    break;
                case 2:
                    m.gas = r.int64();
                    break;
                case 3:
                    m.amount = r.int64();
                    break;
                case 4:
                    m.functionParameters = r.bytes();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ContractCallTransactionBody;
    })();

    proto.ContractCreateTransactionBody = (function() {

        /**
         * Properties of a ContractCreateTransactionBody.
         * @memberof proto
         * @interface IContractCreateTransactionBody
         * @property {proto.IFileID|null} [fileID] ContractCreateTransactionBody fileID
         * @property {proto.IKey|null} [adminKey] ContractCreateTransactionBody adminKey
         * @property {Long|null} [gas] ContractCreateTransactionBody gas
         * @property {Long|null} [initialBalance] ContractCreateTransactionBody initialBalance
         * @property {proto.IAccountID|null} [proxyAccountID] ContractCreateTransactionBody proxyAccountID
         * @property {proto.IDuration|null} [autoRenewPeriod] ContractCreateTransactionBody autoRenewPeriod
         * @property {Uint8Array|null} [constructorParameters] ContractCreateTransactionBody constructorParameters
         * @property {proto.IShardID|null} [shardID] ContractCreateTransactionBody shardID
         * @property {proto.IRealmID|null} [realmID] ContractCreateTransactionBody realmID
         * @property {proto.IKey|null} [newRealmAdminKey] ContractCreateTransactionBody newRealmAdminKey
         * @property {string|null} [memo] ContractCreateTransactionBody memo
         */

        /**
         * Constructs a new ContractCreateTransactionBody.
         * @memberof proto
         * @classdesc Represents a ContractCreateTransactionBody.
         * @implements IContractCreateTransactionBody
         * @constructor
         * @param {proto.IContractCreateTransactionBody=} [p] Properties to set
         */
        function ContractCreateTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ContractCreateTransactionBody fileID.
         * @member {proto.IFileID|null|undefined} fileID
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.fileID = null;

        /**
         * ContractCreateTransactionBody adminKey.
         * @member {proto.IKey|null|undefined} adminKey
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.adminKey = null;

        /**
         * ContractCreateTransactionBody gas.
         * @member {Long} gas
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.gas = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ContractCreateTransactionBody initialBalance.
         * @member {Long} initialBalance
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.initialBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ContractCreateTransactionBody proxyAccountID.
         * @member {proto.IAccountID|null|undefined} proxyAccountID
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.proxyAccountID = null;

        /**
         * ContractCreateTransactionBody autoRenewPeriod.
         * @member {proto.IDuration|null|undefined} autoRenewPeriod
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.autoRenewPeriod = null;

        /**
         * ContractCreateTransactionBody constructorParameters.
         * @member {Uint8Array} constructorParameters
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.constructorParameters = $util.newBuffer([]);

        /**
         * ContractCreateTransactionBody shardID.
         * @member {proto.IShardID|null|undefined} shardID
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.shardID = null;

        /**
         * ContractCreateTransactionBody realmID.
         * @member {proto.IRealmID|null|undefined} realmID
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.realmID = null;

        /**
         * ContractCreateTransactionBody newRealmAdminKey.
         * @member {proto.IKey|null|undefined} newRealmAdminKey
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.newRealmAdminKey = null;

        /**
         * ContractCreateTransactionBody memo.
         * @member {string} memo
         * @memberof proto.ContractCreateTransactionBody
         * @instance
         */
        ContractCreateTransactionBody.prototype.memo = "";

        /**
         * Creates a new ContractCreateTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.ContractCreateTransactionBody
         * @static
         * @param {proto.IContractCreateTransactionBody=} [properties] Properties to set
         * @returns {proto.ContractCreateTransactionBody} ContractCreateTransactionBody instance
         */
        ContractCreateTransactionBody.create = function create(properties) {
            return new ContractCreateTransactionBody(properties);
        };

        /**
         * Encodes the specified ContractCreateTransactionBody message. Does not implicitly {@link proto.ContractCreateTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractCreateTransactionBody
         * @static
         * @param {proto.IContractCreateTransactionBody} m ContractCreateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractCreateTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                $root.proto.FileID.encode(m.fileID, w.uint32(10).fork()).ldelim();
            if (m.adminKey != null && Object.hasOwnProperty.call(m, "adminKey"))
                $root.proto.Key.encode(m.adminKey, w.uint32(26).fork()).ldelim();
            if (m.gas != null && Object.hasOwnProperty.call(m, "gas"))
                w.uint32(32).int64(m.gas);
            if (m.initialBalance != null && Object.hasOwnProperty.call(m, "initialBalance"))
                w.uint32(40).int64(m.initialBalance);
            if (m.proxyAccountID != null && Object.hasOwnProperty.call(m, "proxyAccountID"))
                $root.proto.AccountID.encode(m.proxyAccountID, w.uint32(50).fork()).ldelim();
            if (m.autoRenewPeriod != null && Object.hasOwnProperty.call(m, "autoRenewPeriod"))
                $root.proto.Duration.encode(m.autoRenewPeriod, w.uint32(66).fork()).ldelim();
            if (m.constructorParameters != null && Object.hasOwnProperty.call(m, "constructorParameters"))
                w.uint32(74).bytes(m.constructorParameters);
            if (m.shardID != null && Object.hasOwnProperty.call(m, "shardID"))
                $root.proto.ShardID.encode(m.shardID, w.uint32(82).fork()).ldelim();
            if (m.realmID != null && Object.hasOwnProperty.call(m, "realmID"))
                $root.proto.RealmID.encode(m.realmID, w.uint32(90).fork()).ldelim();
            if (m.newRealmAdminKey != null && Object.hasOwnProperty.call(m, "newRealmAdminKey"))
                $root.proto.Key.encode(m.newRealmAdminKey, w.uint32(98).fork()).ldelim();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                w.uint32(106).string(m.memo);
            return w;
        };

        /**
         * Decodes a ContractCreateTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractCreateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractCreateTransactionBody} ContractCreateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractCreateTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ContractCreateTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.fileID = $root.proto.FileID.decode(r, r.uint32());
                    break;
                case 3:
                    m.adminKey = $root.proto.Key.decode(r, r.uint32());
                    break;
                case 4:
                    m.gas = r.int64();
                    break;
                case 5:
                    m.initialBalance = r.int64();
                    break;
                case 6:
                    m.proxyAccountID = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 8:
                    m.autoRenewPeriod = $root.proto.Duration.decode(r, r.uint32());
                    break;
                case 9:
                    m.constructorParameters = r.bytes();
                    break;
                case 10:
                    m.shardID = $root.proto.ShardID.decode(r, r.uint32());
                    break;
                case 11:
                    m.realmID = $root.proto.RealmID.decode(r, r.uint32());
                    break;
                case 12:
                    m.newRealmAdminKey = $root.proto.Key.decode(r, r.uint32());
                    break;
                case 13:
                    m.memo = r.string();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ContractCreateTransactionBody;
    })();

    proto.ContractUpdateTransactionBody = (function() {

        /**
         * Properties of a ContractUpdateTransactionBody.
         * @memberof proto
         * @interface IContractUpdateTransactionBody
         * @property {proto.IContractID|null} [contractID] ContractUpdateTransactionBody contractID
         * @property {proto.ITimestamp|null} [expirationTime] ContractUpdateTransactionBody expirationTime
         * @property {proto.IKey|null} [adminKey] ContractUpdateTransactionBody adminKey
         * @property {proto.IAccountID|null} [proxyAccountID] ContractUpdateTransactionBody proxyAccountID
         * @property {proto.IDuration|null} [autoRenewPeriod] ContractUpdateTransactionBody autoRenewPeriod
         * @property {proto.IFileID|null} [fileID] ContractUpdateTransactionBody fileID
         * @property {string|null} [memo] ContractUpdateTransactionBody memo
         * @property {google.protobuf.IStringValue|null} [memoWrapper] ContractUpdateTransactionBody memoWrapper
         */

        /**
         * Constructs a new ContractUpdateTransactionBody.
         * @memberof proto
         * @classdesc Represents a ContractUpdateTransactionBody.
         * @implements IContractUpdateTransactionBody
         * @constructor
         * @param {proto.IContractUpdateTransactionBody=} [p] Properties to set
         */
        function ContractUpdateTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ContractUpdateTransactionBody contractID.
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.ContractUpdateTransactionBody
         * @instance
         */
        ContractUpdateTransactionBody.prototype.contractID = null;

        /**
         * ContractUpdateTransactionBody expirationTime.
         * @member {proto.ITimestamp|null|undefined} expirationTime
         * @memberof proto.ContractUpdateTransactionBody
         * @instance
         */
        ContractUpdateTransactionBody.prototype.expirationTime = null;

        /**
         * ContractUpdateTransactionBody adminKey.
         * @member {proto.IKey|null|undefined} adminKey
         * @memberof proto.ContractUpdateTransactionBody
         * @instance
         */
        ContractUpdateTransactionBody.prototype.adminKey = null;

        /**
         * ContractUpdateTransactionBody proxyAccountID.
         * @member {proto.IAccountID|null|undefined} proxyAccountID
         * @memberof proto.ContractUpdateTransactionBody
         * @instance
         */
        ContractUpdateTransactionBody.prototype.proxyAccountID = null;

        /**
         * ContractUpdateTransactionBody autoRenewPeriod.
         * @member {proto.IDuration|null|undefined} autoRenewPeriod
         * @memberof proto.ContractUpdateTransactionBody
         * @instance
         */
        ContractUpdateTransactionBody.prototype.autoRenewPeriod = null;

        /**
         * ContractUpdateTransactionBody fileID.
         * @member {proto.IFileID|null|undefined} fileID
         * @memberof proto.ContractUpdateTransactionBody
         * @instance
         */
        ContractUpdateTransactionBody.prototype.fileID = null;

        /**
         * ContractUpdateTransactionBody memo.
         * @member {string|null|undefined} memo
         * @memberof proto.ContractUpdateTransactionBody
         * @instance
         */
        ContractUpdateTransactionBody.prototype.memo = null;

        /**
         * ContractUpdateTransactionBody memoWrapper.
         * @member {google.protobuf.IStringValue|null|undefined} memoWrapper
         * @memberof proto.ContractUpdateTransactionBody
         * @instance
         */
        ContractUpdateTransactionBody.prototype.memoWrapper = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * ContractUpdateTransactionBody memoField.
         * @member {"memo"|"memoWrapper"|undefined} memoField
         * @memberof proto.ContractUpdateTransactionBody
         * @instance
         */
        Object.defineProperty(ContractUpdateTransactionBody.prototype, "memoField", {
            get: $util.oneOfGetter($oneOfFields = ["memo", "memoWrapper"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ContractUpdateTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.ContractUpdateTransactionBody
         * @static
         * @param {proto.IContractUpdateTransactionBody=} [properties] Properties to set
         * @returns {proto.ContractUpdateTransactionBody} ContractUpdateTransactionBody instance
         */
        ContractUpdateTransactionBody.create = function create(properties) {
            return new ContractUpdateTransactionBody(properties);
        };

        /**
         * Encodes the specified ContractUpdateTransactionBody message. Does not implicitly {@link proto.ContractUpdateTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractUpdateTransactionBody
         * @static
         * @param {proto.IContractUpdateTransactionBody} m ContractUpdateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractUpdateTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(10).fork()).ldelim();
            if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                $root.proto.Timestamp.encode(m.expirationTime, w.uint32(18).fork()).ldelim();
            if (m.adminKey != null && Object.hasOwnProperty.call(m, "adminKey"))
                $root.proto.Key.encode(m.adminKey, w.uint32(26).fork()).ldelim();
            if (m.proxyAccountID != null && Object.hasOwnProperty.call(m, "proxyAccountID"))
                $root.proto.AccountID.encode(m.proxyAccountID, w.uint32(50).fork()).ldelim();
            if (m.autoRenewPeriod != null && Object.hasOwnProperty.call(m, "autoRenewPeriod"))
                $root.proto.Duration.encode(m.autoRenewPeriod, w.uint32(58).fork()).ldelim();
            if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                $root.proto.FileID.encode(m.fileID, w.uint32(66).fork()).ldelim();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                w.uint32(74).string(m.memo);
            if (m.memoWrapper != null && Object.hasOwnProperty.call(m, "memoWrapper"))
                $root.google.protobuf.StringValue.encode(m.memoWrapper, w.uint32(82).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ContractUpdateTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractUpdateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractUpdateTransactionBody} ContractUpdateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractUpdateTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ContractUpdateTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                    break;
                case 2:
                    m.expirationTime = $root.proto.Timestamp.decode(r, r.uint32());
                    break;
                case 3:
                    m.adminKey = $root.proto.Key.decode(r, r.uint32());
                    break;
                case 6:
                    m.proxyAccountID = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 7:
                    m.autoRenewPeriod = $root.proto.Duration.decode(r, r.uint32());
                    break;
                case 8:
                    m.fileID = $root.proto.FileID.decode(r, r.uint32());
                    break;
                case 9:
                    m.memo = r.string();
                    break;
                case 10:
                    m.memoWrapper = $root.google.protobuf.StringValue.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ContractUpdateTransactionBody;
    })();

    proto.LiveHash = (function() {

        /**
         * Properties of a LiveHash.
         * @memberof proto
         * @interface ILiveHash
         * @property {proto.IAccountID|null} [accountId] LiveHash accountId
         * @property {Uint8Array|null} [hash] LiveHash hash
         * @property {proto.IKeyList|null} [keys] LiveHash keys
         * @property {proto.IDuration|null} [duration] LiveHash duration
         */

        /**
         * Constructs a new LiveHash.
         * @memberof proto
         * @classdesc Represents a LiveHash.
         * @implements ILiveHash
         * @constructor
         * @param {proto.ILiveHash=} [p] Properties to set
         */
        function LiveHash(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * LiveHash accountId.
         * @member {proto.IAccountID|null|undefined} accountId
         * @memberof proto.LiveHash
         * @instance
         */
        LiveHash.prototype.accountId = null;

        /**
         * LiveHash hash.
         * @member {Uint8Array} hash
         * @memberof proto.LiveHash
         * @instance
         */
        LiveHash.prototype.hash = $util.newBuffer([]);

        /**
         * LiveHash keys.
         * @member {proto.IKeyList|null|undefined} keys
         * @memberof proto.LiveHash
         * @instance
         */
        LiveHash.prototype.keys = null;

        /**
         * LiveHash duration.
         * @member {proto.IDuration|null|undefined} duration
         * @memberof proto.LiveHash
         * @instance
         */
        LiveHash.prototype.duration = null;

        /**
         * Creates a new LiveHash instance using the specified properties.
         * @function create
         * @memberof proto.LiveHash
         * @static
         * @param {proto.ILiveHash=} [properties] Properties to set
         * @returns {proto.LiveHash} LiveHash instance
         */
        LiveHash.create = function create(properties) {
            return new LiveHash(properties);
        };

        /**
         * Encodes the specified LiveHash message. Does not implicitly {@link proto.LiveHash.verify|verify} messages.
         * @function encode
         * @memberof proto.LiveHash
         * @static
         * @param {proto.ILiveHash} m LiveHash message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LiveHash.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.accountId != null && Object.hasOwnProperty.call(m, "accountId"))
                $root.proto.AccountID.encode(m.accountId, w.uint32(10).fork()).ldelim();
            if (m.hash != null && Object.hasOwnProperty.call(m, "hash"))
                w.uint32(18).bytes(m.hash);
            if (m.keys != null && Object.hasOwnProperty.call(m, "keys"))
                $root.proto.KeyList.encode(m.keys, w.uint32(26).fork()).ldelim();
            if (m.duration != null && Object.hasOwnProperty.call(m, "duration"))
                $root.proto.Duration.encode(m.duration, w.uint32(42).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a LiveHash message from the specified reader or buffer.
         * @function decode
         * @memberof proto.LiveHash
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.LiveHash} LiveHash
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LiveHash.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.LiveHash();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.accountId = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 2:
                    m.hash = r.bytes();
                    break;
                case 3:
                    m.keys = $root.proto.KeyList.decode(r, r.uint32());
                    break;
                case 5:
                    m.duration = $root.proto.Duration.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return LiveHash;
    })();

    proto.CryptoAddLiveHashTransactionBody = (function() {

        /**
         * Properties of a CryptoAddLiveHashTransactionBody.
         * @memberof proto
         * @interface ICryptoAddLiveHashTransactionBody
         * @property {proto.ILiveHash|null} [liveHash] CryptoAddLiveHashTransactionBody liveHash
         */

        /**
         * Constructs a new CryptoAddLiveHashTransactionBody.
         * @memberof proto
         * @classdesc Represents a CryptoAddLiveHashTransactionBody.
         * @implements ICryptoAddLiveHashTransactionBody
         * @constructor
         * @param {proto.ICryptoAddLiveHashTransactionBody=} [p] Properties to set
         */
        function CryptoAddLiveHashTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * CryptoAddLiveHashTransactionBody liveHash.
         * @member {proto.ILiveHash|null|undefined} liveHash
         * @memberof proto.CryptoAddLiveHashTransactionBody
         * @instance
         */
        CryptoAddLiveHashTransactionBody.prototype.liveHash = null;

        /**
         * Creates a new CryptoAddLiveHashTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.CryptoAddLiveHashTransactionBody
         * @static
         * @param {proto.ICryptoAddLiveHashTransactionBody=} [properties] Properties to set
         * @returns {proto.CryptoAddLiveHashTransactionBody} CryptoAddLiveHashTransactionBody instance
         */
        CryptoAddLiveHashTransactionBody.create = function create(properties) {
            return new CryptoAddLiveHashTransactionBody(properties);
        };

        /**
         * Encodes the specified CryptoAddLiveHashTransactionBody message. Does not implicitly {@link proto.CryptoAddLiveHashTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoAddLiveHashTransactionBody
         * @static
         * @param {proto.ICryptoAddLiveHashTransactionBody} m CryptoAddLiveHashTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoAddLiveHashTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.liveHash != null && Object.hasOwnProperty.call(m, "liveHash"))
                $root.proto.LiveHash.encode(m.liveHash, w.uint32(26).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a CryptoAddLiveHashTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoAddLiveHashTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoAddLiveHashTransactionBody} CryptoAddLiveHashTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoAddLiveHashTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoAddLiveHashTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 3:
                    m.liveHash = $root.proto.LiveHash.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return CryptoAddLiveHashTransactionBody;
    })();

    proto.CryptoCreateTransactionBody = (function() {

        /**
         * Properties of a CryptoCreateTransactionBody.
         * @memberof proto
         * @interface ICryptoCreateTransactionBody
         * @property {proto.IKey|null} [key] CryptoCreateTransactionBody key
         * @property {Long|null} [initialBalance] CryptoCreateTransactionBody initialBalance
         * @property {proto.IAccountID|null} [proxyAccountID] CryptoCreateTransactionBody proxyAccountID
         * @property {Long|null} [sendRecordThreshold] CryptoCreateTransactionBody sendRecordThreshold
         * @property {Long|null} [receiveRecordThreshold] CryptoCreateTransactionBody receiveRecordThreshold
         * @property {boolean|null} [receiverSigRequired] CryptoCreateTransactionBody receiverSigRequired
         * @property {proto.IDuration|null} [autoRenewPeriod] CryptoCreateTransactionBody autoRenewPeriod
         * @property {proto.IShardID|null} [shardID] CryptoCreateTransactionBody shardID
         * @property {proto.IRealmID|null} [realmID] CryptoCreateTransactionBody realmID
         * @property {proto.IKey|null} [newRealmAdminKey] CryptoCreateTransactionBody newRealmAdminKey
         * @property {string|null} [memo] CryptoCreateTransactionBody memo
         */

        /**
         * Constructs a new CryptoCreateTransactionBody.
         * @memberof proto
         * @classdesc Represents a CryptoCreateTransactionBody.
         * @implements ICryptoCreateTransactionBody
         * @constructor
         * @param {proto.ICryptoCreateTransactionBody=} [p] Properties to set
         */
        function CryptoCreateTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * CryptoCreateTransactionBody key.
         * @member {proto.IKey|null|undefined} key
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.key = null;

        /**
         * CryptoCreateTransactionBody initialBalance.
         * @member {Long} initialBalance
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.initialBalance = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * CryptoCreateTransactionBody proxyAccountID.
         * @member {proto.IAccountID|null|undefined} proxyAccountID
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.proxyAccountID = null;

        /**
         * CryptoCreateTransactionBody sendRecordThreshold.
         * @member {Long} sendRecordThreshold
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.sendRecordThreshold = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * CryptoCreateTransactionBody receiveRecordThreshold.
         * @member {Long} receiveRecordThreshold
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.receiveRecordThreshold = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * CryptoCreateTransactionBody receiverSigRequired.
         * @member {boolean} receiverSigRequired
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.receiverSigRequired = false;

        /**
         * CryptoCreateTransactionBody autoRenewPeriod.
         * @member {proto.IDuration|null|undefined} autoRenewPeriod
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.autoRenewPeriod = null;

        /**
         * CryptoCreateTransactionBody shardID.
         * @member {proto.IShardID|null|undefined} shardID
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.shardID = null;

        /**
         * CryptoCreateTransactionBody realmID.
         * @member {proto.IRealmID|null|undefined} realmID
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.realmID = null;

        /**
         * CryptoCreateTransactionBody newRealmAdminKey.
         * @member {proto.IKey|null|undefined} newRealmAdminKey
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.newRealmAdminKey = null;

        /**
         * CryptoCreateTransactionBody memo.
         * @member {string} memo
         * @memberof proto.CryptoCreateTransactionBody
         * @instance
         */
        CryptoCreateTransactionBody.prototype.memo = "";

        /**
         * Creates a new CryptoCreateTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.CryptoCreateTransactionBody
         * @static
         * @param {proto.ICryptoCreateTransactionBody=} [properties] Properties to set
         * @returns {proto.CryptoCreateTransactionBody} CryptoCreateTransactionBody instance
         */
        CryptoCreateTransactionBody.create = function create(properties) {
            return new CryptoCreateTransactionBody(properties);
        };

        /**
         * Encodes the specified CryptoCreateTransactionBody message. Does not implicitly {@link proto.CryptoCreateTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoCreateTransactionBody
         * @static
         * @param {proto.ICryptoCreateTransactionBody} m CryptoCreateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoCreateTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.key != null && Object.hasOwnProperty.call(m, "key"))
                $root.proto.Key.encode(m.key, w.uint32(10).fork()).ldelim();
            if (m.initialBalance != null && Object.hasOwnProperty.call(m, "initialBalance"))
                w.uint32(16).uint64(m.initialBalance);
            if (m.proxyAccountID != null && Object.hasOwnProperty.call(m, "proxyAccountID"))
                $root.proto.AccountID.encode(m.proxyAccountID, w.uint32(26).fork()).ldelim();
            if (m.sendRecordThreshold != null && Object.hasOwnProperty.call(m, "sendRecordThreshold"))
                w.uint32(48).uint64(m.sendRecordThreshold);
            if (m.receiveRecordThreshold != null && Object.hasOwnProperty.call(m, "receiveRecordThreshold"))
                w.uint32(56).uint64(m.receiveRecordThreshold);
            if (m.receiverSigRequired != null && Object.hasOwnProperty.call(m, "receiverSigRequired"))
                w.uint32(64).bool(m.receiverSigRequired);
            if (m.autoRenewPeriod != null && Object.hasOwnProperty.call(m, "autoRenewPeriod"))
                $root.proto.Duration.encode(m.autoRenewPeriod, w.uint32(74).fork()).ldelim();
            if (m.shardID != null && Object.hasOwnProperty.call(m, "shardID"))
                $root.proto.ShardID.encode(m.shardID, w.uint32(82).fork()).ldelim();
            if (m.realmID != null && Object.hasOwnProperty.call(m, "realmID"))
                $root.proto.RealmID.encode(m.realmID, w.uint32(90).fork()).ldelim();
            if (m.newRealmAdminKey != null && Object.hasOwnProperty.call(m, "newRealmAdminKey"))
                $root.proto.Key.encode(m.newRealmAdminKey, w.uint32(98).fork()).ldelim();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                w.uint32(106).string(m.memo);
            return w;
        };

        /**
         * Decodes a CryptoCreateTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoCreateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoCreateTransactionBody} CryptoCreateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoCreateTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoCreateTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.key = $root.proto.Key.decode(r, r.uint32());
                    break;
                case 2:
                    m.initialBalance = r.uint64();
                    break;
                case 3:
                    m.proxyAccountID = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 6:
                    m.sendRecordThreshold = r.uint64();
                    break;
                case 7:
                    m.receiveRecordThreshold = r.uint64();
                    break;
                case 8:
                    m.receiverSigRequired = r.bool();
                    break;
                case 9:
                    m.autoRenewPeriod = $root.proto.Duration.decode(r, r.uint32());
                    break;
                case 10:
                    m.shardID = $root.proto.ShardID.decode(r, r.uint32());
                    break;
                case 11:
                    m.realmID = $root.proto.RealmID.decode(r, r.uint32());
                    break;
                case 12:
                    m.newRealmAdminKey = $root.proto.Key.decode(r, r.uint32());
                    break;
                case 13:
                    m.memo = r.string();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return CryptoCreateTransactionBody;
    })();

    proto.CryptoDeleteTransactionBody = (function() {

        /**
         * Properties of a CryptoDeleteTransactionBody.
         * @memberof proto
         * @interface ICryptoDeleteTransactionBody
         * @property {proto.IAccountID|null} [transferAccountID] CryptoDeleteTransactionBody transferAccountID
         * @property {proto.IAccountID|null} [deleteAccountID] CryptoDeleteTransactionBody deleteAccountID
         */

        /**
         * Constructs a new CryptoDeleteTransactionBody.
         * @memberof proto
         * @classdesc Represents a CryptoDeleteTransactionBody.
         * @implements ICryptoDeleteTransactionBody
         * @constructor
         * @param {proto.ICryptoDeleteTransactionBody=} [p] Properties to set
         */
        function CryptoDeleteTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * CryptoDeleteTransactionBody transferAccountID.
         * @member {proto.IAccountID|null|undefined} transferAccountID
         * @memberof proto.CryptoDeleteTransactionBody
         * @instance
         */
        CryptoDeleteTransactionBody.prototype.transferAccountID = null;

        /**
         * CryptoDeleteTransactionBody deleteAccountID.
         * @member {proto.IAccountID|null|undefined} deleteAccountID
         * @memberof proto.CryptoDeleteTransactionBody
         * @instance
         */
        CryptoDeleteTransactionBody.prototype.deleteAccountID = null;

        /**
         * Creates a new CryptoDeleteTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.CryptoDeleteTransactionBody
         * @static
         * @param {proto.ICryptoDeleteTransactionBody=} [properties] Properties to set
         * @returns {proto.CryptoDeleteTransactionBody} CryptoDeleteTransactionBody instance
         */
        CryptoDeleteTransactionBody.create = function create(properties) {
            return new CryptoDeleteTransactionBody(properties);
        };

        /**
         * Encodes the specified CryptoDeleteTransactionBody message. Does not implicitly {@link proto.CryptoDeleteTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoDeleteTransactionBody
         * @static
         * @param {proto.ICryptoDeleteTransactionBody} m CryptoDeleteTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoDeleteTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.transferAccountID != null && Object.hasOwnProperty.call(m, "transferAccountID"))
                $root.proto.AccountID.encode(m.transferAccountID, w.uint32(10).fork()).ldelim();
            if (m.deleteAccountID != null && Object.hasOwnProperty.call(m, "deleteAccountID"))
                $root.proto.AccountID.encode(m.deleteAccountID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a CryptoDeleteTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoDeleteTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoDeleteTransactionBody} CryptoDeleteTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoDeleteTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoDeleteTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.transferAccountID = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 2:
                    m.deleteAccountID = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return CryptoDeleteTransactionBody;
    })();

    proto.CryptoDeleteLiveHashTransactionBody = (function() {

        /**
         * Properties of a CryptoDeleteLiveHashTransactionBody.
         * @memberof proto
         * @interface ICryptoDeleteLiveHashTransactionBody
         * @property {proto.IAccountID|null} [accountOfLiveHash] CryptoDeleteLiveHashTransactionBody accountOfLiveHash
         * @property {Uint8Array|null} [liveHashToDelete] CryptoDeleteLiveHashTransactionBody liveHashToDelete
         */

        /**
         * Constructs a new CryptoDeleteLiveHashTransactionBody.
         * @memberof proto
         * @classdesc Represents a CryptoDeleteLiveHashTransactionBody.
         * @implements ICryptoDeleteLiveHashTransactionBody
         * @constructor
         * @param {proto.ICryptoDeleteLiveHashTransactionBody=} [p] Properties to set
         */
        function CryptoDeleteLiveHashTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * CryptoDeleteLiveHashTransactionBody accountOfLiveHash.
         * @member {proto.IAccountID|null|undefined} accountOfLiveHash
         * @memberof proto.CryptoDeleteLiveHashTransactionBody
         * @instance
         */
        CryptoDeleteLiveHashTransactionBody.prototype.accountOfLiveHash = null;

        /**
         * CryptoDeleteLiveHashTransactionBody liveHashToDelete.
         * @member {Uint8Array} liveHashToDelete
         * @memberof proto.CryptoDeleteLiveHashTransactionBody
         * @instance
         */
        CryptoDeleteLiveHashTransactionBody.prototype.liveHashToDelete = $util.newBuffer([]);

        /**
         * Creates a new CryptoDeleteLiveHashTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.CryptoDeleteLiveHashTransactionBody
         * @static
         * @param {proto.ICryptoDeleteLiveHashTransactionBody=} [properties] Properties to set
         * @returns {proto.CryptoDeleteLiveHashTransactionBody} CryptoDeleteLiveHashTransactionBody instance
         */
        CryptoDeleteLiveHashTransactionBody.create = function create(properties) {
            return new CryptoDeleteLiveHashTransactionBody(properties);
        };

        /**
         * Encodes the specified CryptoDeleteLiveHashTransactionBody message. Does not implicitly {@link proto.CryptoDeleteLiveHashTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoDeleteLiveHashTransactionBody
         * @static
         * @param {proto.ICryptoDeleteLiveHashTransactionBody} m CryptoDeleteLiveHashTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoDeleteLiveHashTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.accountOfLiveHash != null && Object.hasOwnProperty.call(m, "accountOfLiveHash"))
                $root.proto.AccountID.encode(m.accountOfLiveHash, w.uint32(10).fork()).ldelim();
            if (m.liveHashToDelete != null && Object.hasOwnProperty.call(m, "liveHashToDelete"))
                w.uint32(18).bytes(m.liveHashToDelete);
            return w;
        };

        /**
         * Decodes a CryptoDeleteLiveHashTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoDeleteLiveHashTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoDeleteLiveHashTransactionBody} CryptoDeleteLiveHashTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoDeleteLiveHashTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoDeleteLiveHashTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.accountOfLiveHash = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 2:
                    m.liveHashToDelete = r.bytes();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return CryptoDeleteLiveHashTransactionBody;
    })();

    proto.CryptoTransferTransactionBody = (function() {

        /**
         * Properties of a CryptoTransferTransactionBody.
         * @memberof proto
         * @interface ICryptoTransferTransactionBody
         * @property {proto.ITransferList|null} [transfers] CryptoTransferTransactionBody transfers
         * @property {Array.<proto.ITokenTransferList>|null} [tokenTransfers] CryptoTransferTransactionBody tokenTransfers
         */

        /**
         * Constructs a new CryptoTransferTransactionBody.
         * @memberof proto
         * @classdesc Represents a CryptoTransferTransactionBody.
         * @implements ICryptoTransferTransactionBody
         * @constructor
         * @param {proto.ICryptoTransferTransactionBody=} [p] Properties to set
         */
        function CryptoTransferTransactionBody(p) {
            this.tokenTransfers = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * CryptoTransferTransactionBody transfers.
         * @member {proto.ITransferList|null|undefined} transfers
         * @memberof proto.CryptoTransferTransactionBody
         * @instance
         */
        CryptoTransferTransactionBody.prototype.transfers = null;

        /**
         * CryptoTransferTransactionBody tokenTransfers.
         * @member {Array.<proto.ITokenTransferList>} tokenTransfers
         * @memberof proto.CryptoTransferTransactionBody
         * @instance
         */
        CryptoTransferTransactionBody.prototype.tokenTransfers = $util.emptyArray;

        /**
         * Creates a new CryptoTransferTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.CryptoTransferTransactionBody
         * @static
         * @param {proto.ICryptoTransferTransactionBody=} [properties] Properties to set
         * @returns {proto.CryptoTransferTransactionBody} CryptoTransferTransactionBody instance
         */
        CryptoTransferTransactionBody.create = function create(properties) {
            return new CryptoTransferTransactionBody(properties);
        };

        /**
         * Encodes the specified CryptoTransferTransactionBody message. Does not implicitly {@link proto.CryptoTransferTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoTransferTransactionBody
         * @static
         * @param {proto.ICryptoTransferTransactionBody} m CryptoTransferTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoTransferTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.transfers != null && Object.hasOwnProperty.call(m, "transfers"))
                $root.proto.TransferList.encode(m.transfers, w.uint32(10).fork()).ldelim();
            if (m.tokenTransfers != null && m.tokenTransfers.length) {
                for (var i = 0; i < m.tokenTransfers.length; ++i)
                    $root.proto.TokenTransferList.encode(m.tokenTransfers[i], w.uint32(18).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a CryptoTransferTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoTransferTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoTransferTransactionBody} CryptoTransferTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoTransferTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoTransferTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.transfers = $root.proto.TransferList.decode(r, r.uint32());
                    break;
                case 2:
                    if (!(m.tokenTransfers && m.tokenTransfers.length))
                        m.tokenTransfers = [];
                    m.tokenTransfers.push($root.proto.TokenTransferList.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return CryptoTransferTransactionBody;
    })();

    proto.CryptoUpdateTransactionBody = (function() {

        /**
         * Properties of a CryptoUpdateTransactionBody.
         * @memberof proto
         * @interface ICryptoUpdateTransactionBody
         * @property {proto.IAccountID|null} [accountIDToUpdate] CryptoUpdateTransactionBody accountIDToUpdate
         * @property {proto.IKey|null} [key] CryptoUpdateTransactionBody key
         * @property {proto.IAccountID|null} [proxyAccountID] CryptoUpdateTransactionBody proxyAccountID
         * @property {number|null} [proxyFraction] CryptoUpdateTransactionBody proxyFraction
         * @property {Long|null} [sendRecordThreshold] CryptoUpdateTransactionBody sendRecordThreshold
         * @property {google.protobuf.IUInt64Value|null} [sendRecordThresholdWrapper] CryptoUpdateTransactionBody sendRecordThresholdWrapper
         * @property {Long|null} [receiveRecordThreshold] CryptoUpdateTransactionBody receiveRecordThreshold
         * @property {google.protobuf.IUInt64Value|null} [receiveRecordThresholdWrapper] CryptoUpdateTransactionBody receiveRecordThresholdWrapper
         * @property {proto.IDuration|null} [autoRenewPeriod] CryptoUpdateTransactionBody autoRenewPeriod
         * @property {proto.ITimestamp|null} [expirationTime] CryptoUpdateTransactionBody expirationTime
         * @property {boolean|null} [receiverSigRequired] CryptoUpdateTransactionBody receiverSigRequired
         * @property {google.protobuf.IBoolValue|null} [receiverSigRequiredWrapper] CryptoUpdateTransactionBody receiverSigRequiredWrapper
         * @property {google.protobuf.IStringValue|null} [memo] CryptoUpdateTransactionBody memo
         */

        /**
         * Constructs a new CryptoUpdateTransactionBody.
         * @memberof proto
         * @classdesc Represents a CryptoUpdateTransactionBody.
         * @implements ICryptoUpdateTransactionBody
         * @constructor
         * @param {proto.ICryptoUpdateTransactionBody=} [p] Properties to set
         */
        function CryptoUpdateTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * CryptoUpdateTransactionBody accountIDToUpdate.
         * @member {proto.IAccountID|null|undefined} accountIDToUpdate
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.accountIDToUpdate = null;

        /**
         * CryptoUpdateTransactionBody key.
         * @member {proto.IKey|null|undefined} key
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.key = null;

        /**
         * CryptoUpdateTransactionBody proxyAccountID.
         * @member {proto.IAccountID|null|undefined} proxyAccountID
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.proxyAccountID = null;

        /**
         * CryptoUpdateTransactionBody proxyFraction.
         * @member {number} proxyFraction
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.proxyFraction = 0;

        /**
         * CryptoUpdateTransactionBody sendRecordThreshold.
         * @member {Long|null|undefined} sendRecordThreshold
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.sendRecordThreshold = null;

        /**
         * CryptoUpdateTransactionBody sendRecordThresholdWrapper.
         * @member {google.protobuf.IUInt64Value|null|undefined} sendRecordThresholdWrapper
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.sendRecordThresholdWrapper = null;

        /**
         * CryptoUpdateTransactionBody receiveRecordThreshold.
         * @member {Long|null|undefined} receiveRecordThreshold
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.receiveRecordThreshold = null;

        /**
         * CryptoUpdateTransactionBody receiveRecordThresholdWrapper.
         * @member {google.protobuf.IUInt64Value|null|undefined} receiveRecordThresholdWrapper
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.receiveRecordThresholdWrapper = null;

        /**
         * CryptoUpdateTransactionBody autoRenewPeriod.
         * @member {proto.IDuration|null|undefined} autoRenewPeriod
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.autoRenewPeriod = null;

        /**
         * CryptoUpdateTransactionBody expirationTime.
         * @member {proto.ITimestamp|null|undefined} expirationTime
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.expirationTime = null;

        /**
         * CryptoUpdateTransactionBody receiverSigRequired.
         * @member {boolean|null|undefined} receiverSigRequired
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.receiverSigRequired = null;

        /**
         * CryptoUpdateTransactionBody receiverSigRequiredWrapper.
         * @member {google.protobuf.IBoolValue|null|undefined} receiverSigRequiredWrapper
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.receiverSigRequiredWrapper = null;

        /**
         * CryptoUpdateTransactionBody memo.
         * @member {google.protobuf.IStringValue|null|undefined} memo
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        CryptoUpdateTransactionBody.prototype.memo = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * CryptoUpdateTransactionBody sendRecordThresholdField.
         * @member {"sendRecordThreshold"|"sendRecordThresholdWrapper"|undefined} sendRecordThresholdField
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        Object.defineProperty(CryptoUpdateTransactionBody.prototype, "sendRecordThresholdField", {
            get: $util.oneOfGetter($oneOfFields = ["sendRecordThreshold", "sendRecordThresholdWrapper"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * CryptoUpdateTransactionBody receiveRecordThresholdField.
         * @member {"receiveRecordThreshold"|"receiveRecordThresholdWrapper"|undefined} receiveRecordThresholdField
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        Object.defineProperty(CryptoUpdateTransactionBody.prototype, "receiveRecordThresholdField", {
            get: $util.oneOfGetter($oneOfFields = ["receiveRecordThreshold", "receiveRecordThresholdWrapper"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * CryptoUpdateTransactionBody receiverSigRequiredField.
         * @member {"receiverSigRequired"|"receiverSigRequiredWrapper"|undefined} receiverSigRequiredField
         * @memberof proto.CryptoUpdateTransactionBody
         * @instance
         */
        Object.defineProperty(CryptoUpdateTransactionBody.prototype, "receiverSigRequiredField", {
            get: $util.oneOfGetter($oneOfFields = ["receiverSigRequired", "receiverSigRequiredWrapper"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new CryptoUpdateTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.CryptoUpdateTransactionBody
         * @static
         * @param {proto.ICryptoUpdateTransactionBody=} [properties] Properties to set
         * @returns {proto.CryptoUpdateTransactionBody} CryptoUpdateTransactionBody instance
         */
        CryptoUpdateTransactionBody.create = function create(properties) {
            return new CryptoUpdateTransactionBody(properties);
        };

        /**
         * Encodes the specified CryptoUpdateTransactionBody message. Does not implicitly {@link proto.CryptoUpdateTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoUpdateTransactionBody
         * @static
         * @param {proto.ICryptoUpdateTransactionBody} m CryptoUpdateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoUpdateTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.accountIDToUpdate != null && Object.hasOwnProperty.call(m, "accountIDToUpdate"))
                $root.proto.AccountID.encode(m.accountIDToUpdate, w.uint32(18).fork()).ldelim();
            if (m.key != null && Object.hasOwnProperty.call(m, "key"))
                $root.proto.Key.encode(m.key, w.uint32(26).fork()).ldelim();
            if (m.proxyAccountID != null && Object.hasOwnProperty.call(m, "proxyAccountID"))
                $root.proto.AccountID.encode(m.proxyAccountID, w.uint32(34).fork()).ldelim();
            if (m.proxyFraction != null && Object.hasOwnProperty.call(m, "proxyFraction"))
                w.uint32(40).int32(m.proxyFraction);
            if (m.sendRecordThreshold != null && Object.hasOwnProperty.call(m, "sendRecordThreshold"))
                w.uint32(48).uint64(m.sendRecordThreshold);
            if (m.receiveRecordThreshold != null && Object.hasOwnProperty.call(m, "receiveRecordThreshold"))
                w.uint32(56).uint64(m.receiveRecordThreshold);
            if (m.autoRenewPeriod != null && Object.hasOwnProperty.call(m, "autoRenewPeriod"))
                $root.proto.Duration.encode(m.autoRenewPeriod, w.uint32(66).fork()).ldelim();
            if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                $root.proto.Timestamp.encode(m.expirationTime, w.uint32(74).fork()).ldelim();
            if (m.receiverSigRequired != null && Object.hasOwnProperty.call(m, "receiverSigRequired"))
                w.uint32(80).bool(m.receiverSigRequired);
            if (m.sendRecordThresholdWrapper != null && Object.hasOwnProperty.call(m, "sendRecordThresholdWrapper"))
                $root.google.protobuf.UInt64Value.encode(m.sendRecordThresholdWrapper, w.uint32(90).fork()).ldelim();
            if (m.receiveRecordThresholdWrapper != null && Object.hasOwnProperty.call(m, "receiveRecordThresholdWrapper"))
                $root.google.protobuf.UInt64Value.encode(m.receiveRecordThresholdWrapper, w.uint32(98).fork()).ldelim();
            if (m.receiverSigRequiredWrapper != null && Object.hasOwnProperty.call(m, "receiverSigRequiredWrapper"))
                $root.google.protobuf.BoolValue.encode(m.receiverSigRequiredWrapper, w.uint32(106).fork()).ldelim();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                $root.google.protobuf.StringValue.encode(m.memo, w.uint32(114).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a CryptoUpdateTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoUpdateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoUpdateTransactionBody} CryptoUpdateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoUpdateTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoUpdateTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 2:
                    m.accountIDToUpdate = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 3:
                    m.key = $root.proto.Key.decode(r, r.uint32());
                    break;
                case 4:
                    m.proxyAccountID = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 5:
                    m.proxyFraction = r.int32();
                    break;
                case 6:
                    m.sendRecordThreshold = r.uint64();
                    break;
                case 11:
                    m.sendRecordThresholdWrapper = $root.google.protobuf.UInt64Value.decode(r, r.uint32());
                    break;
                case 7:
                    m.receiveRecordThreshold = r.uint64();
                    break;
                case 12:
                    m.receiveRecordThresholdWrapper = $root.google.protobuf.UInt64Value.decode(r, r.uint32());
                    break;
                case 8:
                    m.autoRenewPeriod = $root.proto.Duration.decode(r, r.uint32());
                    break;
                case 9:
                    m.expirationTime = $root.proto.Timestamp.decode(r, r.uint32());
                    break;
                case 10:
                    m.receiverSigRequired = r.bool();
                    break;
                case 13:
                    m.receiverSigRequiredWrapper = $root.google.protobuf.BoolValue.decode(r, r.uint32());
                    break;
                case 14:
                    m.memo = $root.google.protobuf.StringValue.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return CryptoUpdateTransactionBody;
    })();

    proto.FileAppendTransactionBody = (function() {

        /**
         * Properties of a FileAppendTransactionBody.
         * @memberof proto
         * @interface IFileAppendTransactionBody
         * @property {proto.IFileID|null} [fileID] FileAppendTransactionBody fileID
         * @property {Uint8Array|null} [contents] FileAppendTransactionBody contents
         */

        /**
         * Constructs a new FileAppendTransactionBody.
         * @memberof proto
         * @classdesc Represents a FileAppendTransactionBody.
         * @implements IFileAppendTransactionBody
         * @constructor
         * @param {proto.IFileAppendTransactionBody=} [p] Properties to set
         */
        function FileAppendTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * FileAppendTransactionBody fileID.
         * @member {proto.IFileID|null|undefined} fileID
         * @memberof proto.FileAppendTransactionBody
         * @instance
         */
        FileAppendTransactionBody.prototype.fileID = null;

        /**
         * FileAppendTransactionBody contents.
         * @member {Uint8Array} contents
         * @memberof proto.FileAppendTransactionBody
         * @instance
         */
        FileAppendTransactionBody.prototype.contents = $util.newBuffer([]);

        /**
         * Creates a new FileAppendTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.FileAppendTransactionBody
         * @static
         * @param {proto.IFileAppendTransactionBody=} [properties] Properties to set
         * @returns {proto.FileAppendTransactionBody} FileAppendTransactionBody instance
         */
        FileAppendTransactionBody.create = function create(properties) {
            return new FileAppendTransactionBody(properties);
        };

        /**
         * Encodes the specified FileAppendTransactionBody message. Does not implicitly {@link proto.FileAppendTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.FileAppendTransactionBody
         * @static
         * @param {proto.IFileAppendTransactionBody} m FileAppendTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileAppendTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                $root.proto.FileID.encode(m.fileID, w.uint32(18).fork()).ldelim();
            if (m.contents != null && Object.hasOwnProperty.call(m, "contents"))
                w.uint32(34).bytes(m.contents);
            return w;
        };

        /**
         * Decodes a FileAppendTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileAppendTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FileAppendTransactionBody} FileAppendTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileAppendTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.FileAppendTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 2:
                    m.fileID = $root.proto.FileID.decode(r, r.uint32());
                    break;
                case 4:
                    m.contents = r.bytes();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return FileAppendTransactionBody;
    })();

    proto.FileCreateTransactionBody = (function() {

        /**
         * Properties of a FileCreateTransactionBody.
         * @memberof proto
         * @interface IFileCreateTransactionBody
         * @property {proto.ITimestamp|null} [expirationTime] FileCreateTransactionBody expirationTime
         * @property {proto.IKeyList|null} [keys] FileCreateTransactionBody keys
         * @property {Uint8Array|null} [contents] FileCreateTransactionBody contents
         * @property {proto.IShardID|null} [shardID] FileCreateTransactionBody shardID
         * @property {proto.IRealmID|null} [realmID] FileCreateTransactionBody realmID
         * @property {proto.IKey|null} [newRealmAdminKey] FileCreateTransactionBody newRealmAdminKey
         * @property {string|null} [memo] FileCreateTransactionBody memo
         */

        /**
         * Constructs a new FileCreateTransactionBody.
         * @memberof proto
         * @classdesc Represents a FileCreateTransactionBody.
         * @implements IFileCreateTransactionBody
         * @constructor
         * @param {proto.IFileCreateTransactionBody=} [p] Properties to set
         */
        function FileCreateTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * FileCreateTransactionBody expirationTime.
         * @member {proto.ITimestamp|null|undefined} expirationTime
         * @memberof proto.FileCreateTransactionBody
         * @instance
         */
        FileCreateTransactionBody.prototype.expirationTime = null;

        /**
         * FileCreateTransactionBody keys.
         * @member {proto.IKeyList|null|undefined} keys
         * @memberof proto.FileCreateTransactionBody
         * @instance
         */
        FileCreateTransactionBody.prototype.keys = null;

        /**
         * FileCreateTransactionBody contents.
         * @member {Uint8Array} contents
         * @memberof proto.FileCreateTransactionBody
         * @instance
         */
        FileCreateTransactionBody.prototype.contents = $util.newBuffer([]);

        /**
         * FileCreateTransactionBody shardID.
         * @member {proto.IShardID|null|undefined} shardID
         * @memberof proto.FileCreateTransactionBody
         * @instance
         */
        FileCreateTransactionBody.prototype.shardID = null;

        /**
         * FileCreateTransactionBody realmID.
         * @member {proto.IRealmID|null|undefined} realmID
         * @memberof proto.FileCreateTransactionBody
         * @instance
         */
        FileCreateTransactionBody.prototype.realmID = null;

        /**
         * FileCreateTransactionBody newRealmAdminKey.
         * @member {proto.IKey|null|undefined} newRealmAdminKey
         * @memberof proto.FileCreateTransactionBody
         * @instance
         */
        FileCreateTransactionBody.prototype.newRealmAdminKey = null;

        /**
         * FileCreateTransactionBody memo.
         * @member {string} memo
         * @memberof proto.FileCreateTransactionBody
         * @instance
         */
        FileCreateTransactionBody.prototype.memo = "";

        /**
         * Creates a new FileCreateTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.FileCreateTransactionBody
         * @static
         * @param {proto.IFileCreateTransactionBody=} [properties] Properties to set
         * @returns {proto.FileCreateTransactionBody} FileCreateTransactionBody instance
         */
        FileCreateTransactionBody.create = function create(properties) {
            return new FileCreateTransactionBody(properties);
        };

        /**
         * Encodes the specified FileCreateTransactionBody message. Does not implicitly {@link proto.FileCreateTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.FileCreateTransactionBody
         * @static
         * @param {proto.IFileCreateTransactionBody} m FileCreateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileCreateTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                $root.proto.Timestamp.encode(m.expirationTime, w.uint32(18).fork()).ldelim();
            if (m.keys != null && Object.hasOwnProperty.call(m, "keys"))
                $root.proto.KeyList.encode(m.keys, w.uint32(26).fork()).ldelim();
            if (m.contents != null && Object.hasOwnProperty.call(m, "contents"))
                w.uint32(34).bytes(m.contents);
            if (m.shardID != null && Object.hasOwnProperty.call(m, "shardID"))
                $root.proto.ShardID.encode(m.shardID, w.uint32(42).fork()).ldelim();
            if (m.realmID != null && Object.hasOwnProperty.call(m, "realmID"))
                $root.proto.RealmID.encode(m.realmID, w.uint32(50).fork()).ldelim();
            if (m.newRealmAdminKey != null && Object.hasOwnProperty.call(m, "newRealmAdminKey"))
                $root.proto.Key.encode(m.newRealmAdminKey, w.uint32(58).fork()).ldelim();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                w.uint32(66).string(m.memo);
            return w;
        };

        /**
         * Decodes a FileCreateTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileCreateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FileCreateTransactionBody} FileCreateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileCreateTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.FileCreateTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 2:
                    m.expirationTime = $root.proto.Timestamp.decode(r, r.uint32());
                    break;
                case 3:
                    m.keys = $root.proto.KeyList.decode(r, r.uint32());
                    break;
                case 4:
                    m.contents = r.bytes();
                    break;
                case 5:
                    m.shardID = $root.proto.ShardID.decode(r, r.uint32());
                    break;
                case 6:
                    m.realmID = $root.proto.RealmID.decode(r, r.uint32());
                    break;
                case 7:
                    m.newRealmAdminKey = $root.proto.Key.decode(r, r.uint32());
                    break;
                case 8:
                    m.memo = r.string();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return FileCreateTransactionBody;
    })();

    proto.FileDeleteTransactionBody = (function() {

        /**
         * Properties of a FileDeleteTransactionBody.
         * @memberof proto
         * @interface IFileDeleteTransactionBody
         * @property {proto.IFileID|null} [fileID] FileDeleteTransactionBody fileID
         */

        /**
         * Constructs a new FileDeleteTransactionBody.
         * @memberof proto
         * @classdesc Represents a FileDeleteTransactionBody.
         * @implements IFileDeleteTransactionBody
         * @constructor
         * @param {proto.IFileDeleteTransactionBody=} [p] Properties to set
         */
        function FileDeleteTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * FileDeleteTransactionBody fileID.
         * @member {proto.IFileID|null|undefined} fileID
         * @memberof proto.FileDeleteTransactionBody
         * @instance
         */
        FileDeleteTransactionBody.prototype.fileID = null;

        /**
         * Creates a new FileDeleteTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.FileDeleteTransactionBody
         * @static
         * @param {proto.IFileDeleteTransactionBody=} [properties] Properties to set
         * @returns {proto.FileDeleteTransactionBody} FileDeleteTransactionBody instance
         */
        FileDeleteTransactionBody.create = function create(properties) {
            return new FileDeleteTransactionBody(properties);
        };

        /**
         * Encodes the specified FileDeleteTransactionBody message. Does not implicitly {@link proto.FileDeleteTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.FileDeleteTransactionBody
         * @static
         * @param {proto.IFileDeleteTransactionBody} m FileDeleteTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileDeleteTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                $root.proto.FileID.encode(m.fileID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a FileDeleteTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileDeleteTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FileDeleteTransactionBody} FileDeleteTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileDeleteTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.FileDeleteTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 2:
                    m.fileID = $root.proto.FileID.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return FileDeleteTransactionBody;
    })();

    proto.FileUpdateTransactionBody = (function() {

        /**
         * Properties of a FileUpdateTransactionBody.
         * @memberof proto
         * @interface IFileUpdateTransactionBody
         * @property {proto.IFileID|null} [fileID] FileUpdateTransactionBody fileID
         * @property {proto.ITimestamp|null} [expirationTime] FileUpdateTransactionBody expirationTime
         * @property {proto.IKeyList|null} [keys] FileUpdateTransactionBody keys
         * @property {Uint8Array|null} [contents] FileUpdateTransactionBody contents
         * @property {google.protobuf.IStringValue|null} [memo] FileUpdateTransactionBody memo
         */

        /**
         * Constructs a new FileUpdateTransactionBody.
         * @memberof proto
         * @classdesc Represents a FileUpdateTransactionBody.
         * @implements IFileUpdateTransactionBody
         * @constructor
         * @param {proto.IFileUpdateTransactionBody=} [p] Properties to set
         */
        function FileUpdateTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * FileUpdateTransactionBody fileID.
         * @member {proto.IFileID|null|undefined} fileID
         * @memberof proto.FileUpdateTransactionBody
         * @instance
         */
        FileUpdateTransactionBody.prototype.fileID = null;

        /**
         * FileUpdateTransactionBody expirationTime.
         * @member {proto.ITimestamp|null|undefined} expirationTime
         * @memberof proto.FileUpdateTransactionBody
         * @instance
         */
        FileUpdateTransactionBody.prototype.expirationTime = null;

        /**
         * FileUpdateTransactionBody keys.
         * @member {proto.IKeyList|null|undefined} keys
         * @memberof proto.FileUpdateTransactionBody
         * @instance
         */
        FileUpdateTransactionBody.prototype.keys = null;

        /**
         * FileUpdateTransactionBody contents.
         * @member {Uint8Array} contents
         * @memberof proto.FileUpdateTransactionBody
         * @instance
         */
        FileUpdateTransactionBody.prototype.contents = $util.newBuffer([]);

        /**
         * FileUpdateTransactionBody memo.
         * @member {google.protobuf.IStringValue|null|undefined} memo
         * @memberof proto.FileUpdateTransactionBody
         * @instance
         */
        FileUpdateTransactionBody.prototype.memo = null;

        /**
         * Creates a new FileUpdateTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.FileUpdateTransactionBody
         * @static
         * @param {proto.IFileUpdateTransactionBody=} [properties] Properties to set
         * @returns {proto.FileUpdateTransactionBody} FileUpdateTransactionBody instance
         */
        FileUpdateTransactionBody.create = function create(properties) {
            return new FileUpdateTransactionBody(properties);
        };

        /**
         * Encodes the specified FileUpdateTransactionBody message. Does not implicitly {@link proto.FileUpdateTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.FileUpdateTransactionBody
         * @static
         * @param {proto.IFileUpdateTransactionBody} m FileUpdateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileUpdateTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                $root.proto.FileID.encode(m.fileID, w.uint32(10).fork()).ldelim();
            if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                $root.proto.Timestamp.encode(m.expirationTime, w.uint32(18).fork()).ldelim();
            if (m.keys != null && Object.hasOwnProperty.call(m, "keys"))
                $root.proto.KeyList.encode(m.keys, w.uint32(26).fork()).ldelim();
            if (m.contents != null && Object.hasOwnProperty.call(m, "contents"))
                w.uint32(34).bytes(m.contents);
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                $root.google.protobuf.StringValue.encode(m.memo, w.uint32(42).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a FileUpdateTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileUpdateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FileUpdateTransactionBody} FileUpdateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileUpdateTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.FileUpdateTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.fileID = $root.proto.FileID.decode(r, r.uint32());
                    break;
                case 2:
                    m.expirationTime = $root.proto.Timestamp.decode(r, r.uint32());
                    break;
                case 3:
                    m.keys = $root.proto.KeyList.decode(r, r.uint32());
                    break;
                case 4:
                    m.contents = r.bytes();
                    break;
                case 5:
                    m.memo = $root.google.protobuf.StringValue.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return FileUpdateTransactionBody;
    })();

    proto.ContractDeleteTransactionBody = (function() {

        /**
         * Properties of a ContractDeleteTransactionBody.
         * @memberof proto
         * @interface IContractDeleteTransactionBody
         * @property {proto.IContractID|null} [contractID] ContractDeleteTransactionBody contractID
         * @property {proto.IAccountID|null} [transferAccountID] ContractDeleteTransactionBody transferAccountID
         * @property {proto.IContractID|null} [transferContractID] ContractDeleteTransactionBody transferContractID
         */

        /**
         * Constructs a new ContractDeleteTransactionBody.
         * @memberof proto
         * @classdesc Represents a ContractDeleteTransactionBody.
         * @implements IContractDeleteTransactionBody
         * @constructor
         * @param {proto.IContractDeleteTransactionBody=} [p] Properties to set
         */
        function ContractDeleteTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ContractDeleteTransactionBody contractID.
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.ContractDeleteTransactionBody
         * @instance
         */
        ContractDeleteTransactionBody.prototype.contractID = null;

        /**
         * ContractDeleteTransactionBody transferAccountID.
         * @member {proto.IAccountID|null|undefined} transferAccountID
         * @memberof proto.ContractDeleteTransactionBody
         * @instance
         */
        ContractDeleteTransactionBody.prototype.transferAccountID = null;

        /**
         * ContractDeleteTransactionBody transferContractID.
         * @member {proto.IContractID|null|undefined} transferContractID
         * @memberof proto.ContractDeleteTransactionBody
         * @instance
         */
        ContractDeleteTransactionBody.prototype.transferContractID = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * ContractDeleteTransactionBody obtainers.
         * @member {"transferAccountID"|"transferContractID"|undefined} obtainers
         * @memberof proto.ContractDeleteTransactionBody
         * @instance
         */
        Object.defineProperty(ContractDeleteTransactionBody.prototype, "obtainers", {
            get: $util.oneOfGetter($oneOfFields = ["transferAccountID", "transferContractID"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ContractDeleteTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.ContractDeleteTransactionBody
         * @static
         * @param {proto.IContractDeleteTransactionBody=} [properties] Properties to set
         * @returns {proto.ContractDeleteTransactionBody} ContractDeleteTransactionBody instance
         */
        ContractDeleteTransactionBody.create = function create(properties) {
            return new ContractDeleteTransactionBody(properties);
        };

        /**
         * Encodes the specified ContractDeleteTransactionBody message. Does not implicitly {@link proto.ContractDeleteTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractDeleteTransactionBody
         * @static
         * @param {proto.IContractDeleteTransactionBody} m ContractDeleteTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractDeleteTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(10).fork()).ldelim();
            if (m.transferAccountID != null && Object.hasOwnProperty.call(m, "transferAccountID"))
                $root.proto.AccountID.encode(m.transferAccountID, w.uint32(18).fork()).ldelim();
            if (m.transferContractID != null && Object.hasOwnProperty.call(m, "transferContractID"))
                $root.proto.ContractID.encode(m.transferContractID, w.uint32(26).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ContractDeleteTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractDeleteTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractDeleteTransactionBody} ContractDeleteTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractDeleteTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ContractDeleteTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                    break;
                case 2:
                    m.transferAccountID = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 3:
                    m.transferContractID = $root.proto.ContractID.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ContractDeleteTransactionBody;
    })();

    proto.ConsensusUpdateTopicTransactionBody = (function() {

        /**
         * Properties of a ConsensusUpdateTopicTransactionBody.
         * @memberof proto
         * @interface IConsensusUpdateTopicTransactionBody
         * @property {proto.ITopicID|null} [topicID] ConsensusUpdateTopicTransactionBody topicID
         * @property {google.protobuf.IStringValue|null} [memo] ConsensusUpdateTopicTransactionBody memo
         * @property {proto.ITimestamp|null} [expirationTime] ConsensusUpdateTopicTransactionBody expirationTime
         * @property {proto.IKey|null} [adminKey] ConsensusUpdateTopicTransactionBody adminKey
         * @property {proto.IKey|null} [submitKey] ConsensusUpdateTopicTransactionBody submitKey
         * @property {proto.IDuration|null} [autoRenewPeriod] ConsensusUpdateTopicTransactionBody autoRenewPeriod
         * @property {proto.IAccountID|null} [autoRenewAccount] ConsensusUpdateTopicTransactionBody autoRenewAccount
         */

        /**
         * Constructs a new ConsensusUpdateTopicTransactionBody.
         * @memberof proto
         * @classdesc Represents a ConsensusUpdateTopicTransactionBody.
         * @implements IConsensusUpdateTopicTransactionBody
         * @constructor
         * @param {proto.IConsensusUpdateTopicTransactionBody=} [p] Properties to set
         */
        function ConsensusUpdateTopicTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ConsensusUpdateTopicTransactionBody topicID.
         * @member {proto.ITopicID|null|undefined} topicID
         * @memberof proto.ConsensusUpdateTopicTransactionBody
         * @instance
         */
        ConsensusUpdateTopicTransactionBody.prototype.topicID = null;

        /**
         * ConsensusUpdateTopicTransactionBody memo.
         * @member {google.protobuf.IStringValue|null|undefined} memo
         * @memberof proto.ConsensusUpdateTopicTransactionBody
         * @instance
         */
        ConsensusUpdateTopicTransactionBody.prototype.memo = null;

        /**
         * ConsensusUpdateTopicTransactionBody expirationTime.
         * @member {proto.ITimestamp|null|undefined} expirationTime
         * @memberof proto.ConsensusUpdateTopicTransactionBody
         * @instance
         */
        ConsensusUpdateTopicTransactionBody.prototype.expirationTime = null;

        /**
         * ConsensusUpdateTopicTransactionBody adminKey.
         * @member {proto.IKey|null|undefined} adminKey
         * @memberof proto.ConsensusUpdateTopicTransactionBody
         * @instance
         */
        ConsensusUpdateTopicTransactionBody.prototype.adminKey = null;

        /**
         * ConsensusUpdateTopicTransactionBody submitKey.
         * @member {proto.IKey|null|undefined} submitKey
         * @memberof proto.ConsensusUpdateTopicTransactionBody
         * @instance
         */
        ConsensusUpdateTopicTransactionBody.prototype.submitKey = null;

        /**
         * ConsensusUpdateTopicTransactionBody autoRenewPeriod.
         * @member {proto.IDuration|null|undefined} autoRenewPeriod
         * @memberof proto.ConsensusUpdateTopicTransactionBody
         * @instance
         */
        ConsensusUpdateTopicTransactionBody.prototype.autoRenewPeriod = null;

        /**
         * ConsensusUpdateTopicTransactionBody autoRenewAccount.
         * @member {proto.IAccountID|null|undefined} autoRenewAccount
         * @memberof proto.ConsensusUpdateTopicTransactionBody
         * @instance
         */
        ConsensusUpdateTopicTransactionBody.prototype.autoRenewAccount = null;

        /**
         * Creates a new ConsensusUpdateTopicTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.ConsensusUpdateTopicTransactionBody
         * @static
         * @param {proto.IConsensusUpdateTopicTransactionBody=} [properties] Properties to set
         * @returns {proto.ConsensusUpdateTopicTransactionBody} ConsensusUpdateTopicTransactionBody instance
         */
        ConsensusUpdateTopicTransactionBody.create = function create(properties) {
            return new ConsensusUpdateTopicTransactionBody(properties);
        };

        /**
         * Encodes the specified ConsensusUpdateTopicTransactionBody message. Does not implicitly {@link proto.ConsensusUpdateTopicTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.ConsensusUpdateTopicTransactionBody
         * @static
         * @param {proto.IConsensusUpdateTopicTransactionBody} m ConsensusUpdateTopicTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConsensusUpdateTopicTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
                $root.proto.TopicID.encode(m.topicID, w.uint32(10).fork()).ldelim();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                $root.google.protobuf.StringValue.encode(m.memo, w.uint32(18).fork()).ldelim();
            if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                $root.proto.Timestamp.encode(m.expirationTime, w.uint32(34).fork()).ldelim();
            if (m.adminKey != null && Object.hasOwnProperty.call(m, "adminKey"))
                $root.proto.Key.encode(m.adminKey, w.uint32(50).fork()).ldelim();
            if (m.submitKey != null && Object.hasOwnProperty.call(m, "submitKey"))
                $root.proto.Key.encode(m.submitKey, w.uint32(58).fork()).ldelim();
            if (m.autoRenewPeriod != null && Object.hasOwnProperty.call(m, "autoRenewPeriod"))
                $root.proto.Duration.encode(m.autoRenewPeriod, w.uint32(66).fork()).ldelim();
            if (m.autoRenewAccount != null && Object.hasOwnProperty.call(m, "autoRenewAccount"))
                $root.proto.AccountID.encode(m.autoRenewAccount, w.uint32(74).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ConsensusUpdateTopicTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ConsensusUpdateTopicTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ConsensusUpdateTopicTransactionBody} ConsensusUpdateTopicTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConsensusUpdateTopicTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ConsensusUpdateTopicTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.topicID = $root.proto.TopicID.decode(r, r.uint32());
                    break;
                case 2:
                    m.memo = $root.google.protobuf.StringValue.decode(r, r.uint32());
                    break;
                case 4:
                    m.expirationTime = $root.proto.Timestamp.decode(r, r.uint32());
                    break;
                case 6:
                    m.adminKey = $root.proto.Key.decode(r, r.uint32());
                    break;
                case 7:
                    m.submitKey = $root.proto.Key.decode(r, r.uint32());
                    break;
                case 8:
                    m.autoRenewPeriod = $root.proto.Duration.decode(r, r.uint32());
                    break;
                case 9:
                    m.autoRenewAccount = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ConsensusUpdateTopicTransactionBody;
    })();

    proto.ConsensusMessageChunkInfo = (function() {

        /**
         * Properties of a ConsensusMessageChunkInfo.
         * @memberof proto
         * @interface IConsensusMessageChunkInfo
         * @property {proto.ITransactionID|null} [initialTransactionID] ConsensusMessageChunkInfo initialTransactionID
         * @property {number|null} [total] ConsensusMessageChunkInfo total
         * @property {number|null} [number] ConsensusMessageChunkInfo number
         */

        /**
         * Constructs a new ConsensusMessageChunkInfo.
         * @memberof proto
         * @classdesc Represents a ConsensusMessageChunkInfo.
         * @implements IConsensusMessageChunkInfo
         * @constructor
         * @param {proto.IConsensusMessageChunkInfo=} [p] Properties to set
         */
        function ConsensusMessageChunkInfo(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ConsensusMessageChunkInfo initialTransactionID.
         * @member {proto.ITransactionID|null|undefined} initialTransactionID
         * @memberof proto.ConsensusMessageChunkInfo
         * @instance
         */
        ConsensusMessageChunkInfo.prototype.initialTransactionID = null;

        /**
         * ConsensusMessageChunkInfo total.
         * @member {number} total
         * @memberof proto.ConsensusMessageChunkInfo
         * @instance
         */
        ConsensusMessageChunkInfo.prototype.total = 0;

        /**
         * ConsensusMessageChunkInfo number.
         * @member {number} number
         * @memberof proto.ConsensusMessageChunkInfo
         * @instance
         */
        ConsensusMessageChunkInfo.prototype.number = 0;

        /**
         * Creates a new ConsensusMessageChunkInfo instance using the specified properties.
         * @function create
         * @memberof proto.ConsensusMessageChunkInfo
         * @static
         * @param {proto.IConsensusMessageChunkInfo=} [properties] Properties to set
         * @returns {proto.ConsensusMessageChunkInfo} ConsensusMessageChunkInfo instance
         */
        ConsensusMessageChunkInfo.create = function create(properties) {
            return new ConsensusMessageChunkInfo(properties);
        };

        /**
         * Encodes the specified ConsensusMessageChunkInfo message. Does not implicitly {@link proto.ConsensusMessageChunkInfo.verify|verify} messages.
         * @function encode
         * @memberof proto.ConsensusMessageChunkInfo
         * @static
         * @param {proto.IConsensusMessageChunkInfo} m ConsensusMessageChunkInfo message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConsensusMessageChunkInfo.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.initialTransactionID != null && Object.hasOwnProperty.call(m, "initialTransactionID"))
                $root.proto.TransactionID.encode(m.initialTransactionID, w.uint32(10).fork()).ldelim();
            if (m.total != null && Object.hasOwnProperty.call(m, "total"))
                w.uint32(16).int32(m.total);
            if (m.number != null && Object.hasOwnProperty.call(m, "number"))
                w.uint32(24).int32(m.number);
            return w;
        };

        /**
         * Decodes a ConsensusMessageChunkInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ConsensusMessageChunkInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ConsensusMessageChunkInfo} ConsensusMessageChunkInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConsensusMessageChunkInfo.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ConsensusMessageChunkInfo();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.initialTransactionID = $root.proto.TransactionID.decode(r, r.uint32());
                    break;
                case 2:
                    m.total = r.int32();
                    break;
                case 3:
                    m.number = r.int32();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ConsensusMessageChunkInfo;
    })();

    proto.ConsensusSubmitMessageTransactionBody = (function() {

        /**
         * Properties of a ConsensusSubmitMessageTransactionBody.
         * @memberof proto
         * @interface IConsensusSubmitMessageTransactionBody
         * @property {proto.ITopicID|null} [topicID] ConsensusSubmitMessageTransactionBody topicID
         * @property {Uint8Array|null} [message] ConsensusSubmitMessageTransactionBody message
         * @property {proto.IConsensusMessageChunkInfo|null} [chunkInfo] ConsensusSubmitMessageTransactionBody chunkInfo
         */

        /**
         * Constructs a new ConsensusSubmitMessageTransactionBody.
         * @memberof proto
         * @classdesc Represents a ConsensusSubmitMessageTransactionBody.
         * @implements IConsensusSubmitMessageTransactionBody
         * @constructor
         * @param {proto.IConsensusSubmitMessageTransactionBody=} [p] Properties to set
         */
        function ConsensusSubmitMessageTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ConsensusSubmitMessageTransactionBody topicID.
         * @member {proto.ITopicID|null|undefined} topicID
         * @memberof proto.ConsensusSubmitMessageTransactionBody
         * @instance
         */
        ConsensusSubmitMessageTransactionBody.prototype.topicID = null;

        /**
         * ConsensusSubmitMessageTransactionBody message.
         * @member {Uint8Array} message
         * @memberof proto.ConsensusSubmitMessageTransactionBody
         * @instance
         */
        ConsensusSubmitMessageTransactionBody.prototype.message = $util.newBuffer([]);

        /**
         * ConsensusSubmitMessageTransactionBody chunkInfo.
         * @member {proto.IConsensusMessageChunkInfo|null|undefined} chunkInfo
         * @memberof proto.ConsensusSubmitMessageTransactionBody
         * @instance
         */
        ConsensusSubmitMessageTransactionBody.prototype.chunkInfo = null;

        /**
         * Creates a new ConsensusSubmitMessageTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.ConsensusSubmitMessageTransactionBody
         * @static
         * @param {proto.IConsensusSubmitMessageTransactionBody=} [properties] Properties to set
         * @returns {proto.ConsensusSubmitMessageTransactionBody} ConsensusSubmitMessageTransactionBody instance
         */
        ConsensusSubmitMessageTransactionBody.create = function create(properties) {
            return new ConsensusSubmitMessageTransactionBody(properties);
        };

        /**
         * Encodes the specified ConsensusSubmitMessageTransactionBody message. Does not implicitly {@link proto.ConsensusSubmitMessageTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.ConsensusSubmitMessageTransactionBody
         * @static
         * @param {proto.IConsensusSubmitMessageTransactionBody} m ConsensusSubmitMessageTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConsensusSubmitMessageTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
                $root.proto.TopicID.encode(m.topicID, w.uint32(10).fork()).ldelim();
            if (m.message != null && Object.hasOwnProperty.call(m, "message"))
                w.uint32(18).bytes(m.message);
            if (m.chunkInfo != null && Object.hasOwnProperty.call(m, "chunkInfo"))
                $root.proto.ConsensusMessageChunkInfo.encode(m.chunkInfo, w.uint32(26).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ConsensusSubmitMessageTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ConsensusSubmitMessageTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ConsensusSubmitMessageTransactionBody} ConsensusSubmitMessageTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConsensusSubmitMessageTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ConsensusSubmitMessageTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.topicID = $root.proto.TopicID.decode(r, r.uint32());
                    break;
                case 2:
                    m.message = r.bytes();
                    break;
                case 3:
                    m.chunkInfo = $root.proto.ConsensusMessageChunkInfo.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ConsensusSubmitMessageTransactionBody;
    })();

    proto.UncheckedSubmitBody = (function() {

        /**
         * Properties of an UncheckedSubmitBody.
         * @memberof proto
         * @interface IUncheckedSubmitBody
         * @property {Uint8Array|null} [transactionBytes] UncheckedSubmitBody transactionBytes
         */

        /**
         * Constructs a new UncheckedSubmitBody.
         * @memberof proto
         * @classdesc Represents an UncheckedSubmitBody.
         * @implements IUncheckedSubmitBody
         * @constructor
         * @param {proto.IUncheckedSubmitBody=} [p] Properties to set
         */
        function UncheckedSubmitBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * UncheckedSubmitBody transactionBytes.
         * @member {Uint8Array} transactionBytes
         * @memberof proto.UncheckedSubmitBody
         * @instance
         */
        UncheckedSubmitBody.prototype.transactionBytes = $util.newBuffer([]);

        /**
         * Creates a new UncheckedSubmitBody instance using the specified properties.
         * @function create
         * @memberof proto.UncheckedSubmitBody
         * @static
         * @param {proto.IUncheckedSubmitBody=} [properties] Properties to set
         * @returns {proto.UncheckedSubmitBody} UncheckedSubmitBody instance
         */
        UncheckedSubmitBody.create = function create(properties) {
            return new UncheckedSubmitBody(properties);
        };

        /**
         * Encodes the specified UncheckedSubmitBody message. Does not implicitly {@link proto.UncheckedSubmitBody.verify|verify} messages.
         * @function encode
         * @memberof proto.UncheckedSubmitBody
         * @static
         * @param {proto.IUncheckedSubmitBody} m UncheckedSubmitBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UncheckedSubmitBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.transactionBytes != null && Object.hasOwnProperty.call(m, "transactionBytes"))
                w.uint32(10).bytes(m.transactionBytes);
            return w;
        };

        /**
         * Decodes an UncheckedSubmitBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UncheckedSubmitBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.UncheckedSubmitBody} UncheckedSubmitBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UncheckedSubmitBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.UncheckedSubmitBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.transactionBytes = r.bytes();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return UncheckedSubmitBody;
    })();

    proto.TokenCreateTransactionBody = (function() {

        /**
         * Properties of a TokenCreateTransactionBody.
         * @memberof proto
         * @interface ITokenCreateTransactionBody
         * @property {string|null} [name] TokenCreateTransactionBody name
         * @property {string|null} [symbol] TokenCreateTransactionBody symbol
         * @property {number|null} [decimals] TokenCreateTransactionBody decimals
         * @property {Long|null} [initialSupply] TokenCreateTransactionBody initialSupply
         * @property {proto.IAccountID|null} [treasury] TokenCreateTransactionBody treasury
         * @property {proto.IKey|null} [adminKey] TokenCreateTransactionBody adminKey
         * @property {proto.IKey|null} [kycKey] TokenCreateTransactionBody kycKey
         * @property {proto.IKey|null} [freezeKey] TokenCreateTransactionBody freezeKey
         * @property {proto.IKey|null} [wipeKey] TokenCreateTransactionBody wipeKey
         * @property {proto.IKey|null} [supplyKey] TokenCreateTransactionBody supplyKey
         * @property {boolean|null} [freezeDefault] TokenCreateTransactionBody freezeDefault
         * @property {proto.ITimestamp|null} [expiry] TokenCreateTransactionBody expiry
         * @property {proto.IAccountID|null} [autoRenewAccount] TokenCreateTransactionBody autoRenewAccount
         * @property {proto.IDuration|null} [autoRenewPeriod] TokenCreateTransactionBody autoRenewPeriod
         * @property {string|null} [memo] TokenCreateTransactionBody memo
         * @property {proto.TokenType|null} [tokenType] TokenCreateTransactionBody tokenType
         * @property {proto.TokenSupplyType|null} [supplyType] TokenCreateTransactionBody supplyType
         * @property {Long|null} [maxSupply] TokenCreateTransactionBody maxSupply
         * @property {proto.IKey|null} [feeScheduleKey] TokenCreateTransactionBody feeScheduleKey
         * @property {Array.<proto.ICustomFee>|null} [customFees] TokenCreateTransactionBody customFees
         */

        /**
         * Constructs a new TokenCreateTransactionBody.
         * @memberof proto
         * @classdesc Represents a TokenCreateTransactionBody.
         * @implements ITokenCreateTransactionBody
         * @constructor
         * @param {proto.ITokenCreateTransactionBody=} [p] Properties to set
         */
        function TokenCreateTransactionBody(p) {
            this.customFees = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TokenCreateTransactionBody name.
         * @member {string} name
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.name = "";

        /**
         * TokenCreateTransactionBody symbol.
         * @member {string} symbol
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.symbol = "";

        /**
         * TokenCreateTransactionBody decimals.
         * @member {number} decimals
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.decimals = 0;

        /**
         * TokenCreateTransactionBody initialSupply.
         * @member {Long} initialSupply
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.initialSupply = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TokenCreateTransactionBody treasury.
         * @member {proto.IAccountID|null|undefined} treasury
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.treasury = null;

        /**
         * TokenCreateTransactionBody adminKey.
         * @member {proto.IKey|null|undefined} adminKey
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.adminKey = null;

        /**
         * TokenCreateTransactionBody kycKey.
         * @member {proto.IKey|null|undefined} kycKey
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.kycKey = null;

        /**
         * TokenCreateTransactionBody freezeKey.
         * @member {proto.IKey|null|undefined} freezeKey
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.freezeKey = null;

        /**
         * TokenCreateTransactionBody wipeKey.
         * @member {proto.IKey|null|undefined} wipeKey
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.wipeKey = null;

        /**
         * TokenCreateTransactionBody supplyKey.
         * @member {proto.IKey|null|undefined} supplyKey
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.supplyKey = null;

        /**
         * TokenCreateTransactionBody freezeDefault.
         * @member {boolean} freezeDefault
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.freezeDefault = false;

        /**
         * TokenCreateTransactionBody expiry.
         * @member {proto.ITimestamp|null|undefined} expiry
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.expiry = null;

        /**
         * TokenCreateTransactionBody autoRenewAccount.
         * @member {proto.IAccountID|null|undefined} autoRenewAccount
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.autoRenewAccount = null;

        /**
         * TokenCreateTransactionBody autoRenewPeriod.
         * @member {proto.IDuration|null|undefined} autoRenewPeriod
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.autoRenewPeriod = null;

        /**
         * TokenCreateTransactionBody memo.
         * @member {string} memo
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.memo = "";

        /**
         * TokenCreateTransactionBody tokenType.
         * @member {proto.TokenType} tokenType
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.tokenType = 0;

        /**
         * TokenCreateTransactionBody supplyType.
         * @member {proto.TokenSupplyType} supplyType
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.supplyType = 0;

        /**
         * TokenCreateTransactionBody maxSupply.
         * @member {Long} maxSupply
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.maxSupply = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TokenCreateTransactionBody feeScheduleKey.
         * @member {proto.IKey|null|undefined} feeScheduleKey
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.feeScheduleKey = null;

        /**
         * TokenCreateTransactionBody customFees.
         * @member {Array.<proto.ICustomFee>} customFees
         * @memberof proto.TokenCreateTransactionBody
         * @instance
         */
        TokenCreateTransactionBody.prototype.customFees = $util.emptyArray;

        /**
         * Creates a new TokenCreateTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenCreateTransactionBody
         * @static
         * @param {proto.ITokenCreateTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenCreateTransactionBody} TokenCreateTransactionBody instance
         */
        TokenCreateTransactionBody.create = function create(properties) {
            return new TokenCreateTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenCreateTransactionBody message. Does not implicitly {@link proto.TokenCreateTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenCreateTransactionBody
         * @static
         * @param {proto.ITokenCreateTransactionBody} m TokenCreateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenCreateTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.name != null && Object.hasOwnProperty.call(m, "name"))
                w.uint32(10).string(m.name);
            if (m.symbol != null && Object.hasOwnProperty.call(m, "symbol"))
                w.uint32(18).string(m.symbol);
            if (m.decimals != null && Object.hasOwnProperty.call(m, "decimals"))
                w.uint32(24).uint32(m.decimals);
            if (m.initialSupply != null && Object.hasOwnProperty.call(m, "initialSupply"))
                w.uint32(32).uint64(m.initialSupply);
            if (m.treasury != null && Object.hasOwnProperty.call(m, "treasury"))
                $root.proto.AccountID.encode(m.treasury, w.uint32(42).fork()).ldelim();
            if (m.adminKey != null && Object.hasOwnProperty.call(m, "adminKey"))
                $root.proto.Key.encode(m.adminKey, w.uint32(50).fork()).ldelim();
            if (m.kycKey != null && Object.hasOwnProperty.call(m, "kycKey"))
                $root.proto.Key.encode(m.kycKey, w.uint32(58).fork()).ldelim();
            if (m.freezeKey != null && Object.hasOwnProperty.call(m, "freezeKey"))
                $root.proto.Key.encode(m.freezeKey, w.uint32(66).fork()).ldelim();
            if (m.wipeKey != null && Object.hasOwnProperty.call(m, "wipeKey"))
                $root.proto.Key.encode(m.wipeKey, w.uint32(74).fork()).ldelim();
            if (m.supplyKey != null && Object.hasOwnProperty.call(m, "supplyKey"))
                $root.proto.Key.encode(m.supplyKey, w.uint32(82).fork()).ldelim();
            if (m.freezeDefault != null && Object.hasOwnProperty.call(m, "freezeDefault"))
                w.uint32(88).bool(m.freezeDefault);
            if (m.expiry != null && Object.hasOwnProperty.call(m, "expiry"))
                $root.proto.Timestamp.encode(m.expiry, w.uint32(106).fork()).ldelim();
            if (m.autoRenewAccount != null && Object.hasOwnProperty.call(m, "autoRenewAccount"))
                $root.proto.AccountID.encode(m.autoRenewAccount, w.uint32(114).fork()).ldelim();
            if (m.autoRenewPeriod != null && Object.hasOwnProperty.call(m, "autoRenewPeriod"))
                $root.proto.Duration.encode(m.autoRenewPeriod, w.uint32(122).fork()).ldelim();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                w.uint32(130).string(m.memo);
            if (m.tokenType != null && Object.hasOwnProperty.call(m, "tokenType"))
                w.uint32(136).int32(m.tokenType);
            if (m.supplyType != null && Object.hasOwnProperty.call(m, "supplyType"))
                w.uint32(144).int32(m.supplyType);
            if (m.maxSupply != null && Object.hasOwnProperty.call(m, "maxSupply"))
                w.uint32(152).int64(m.maxSupply);
            if (m.feeScheduleKey != null && Object.hasOwnProperty.call(m, "feeScheduleKey"))
                $root.proto.Key.encode(m.feeScheduleKey, w.uint32(162).fork()).ldelim();
            if (m.customFees != null && m.customFees.length) {
                for (var i = 0; i < m.customFees.length; ++i)
                    $root.proto.CustomFee.encode(m.customFees[i], w.uint32(170).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TokenCreateTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenCreateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenCreateTransactionBody} TokenCreateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenCreateTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenCreateTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.name = r.string();
                    break;
                case 2:
                    m.symbol = r.string();
                    break;
                case 3:
                    m.decimals = r.uint32();
                    break;
                case 4:
                    m.initialSupply = r.uint64();
                    break;
                case 5:
                    m.treasury = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 6:
                    m.adminKey = $root.proto.Key.decode(r, r.uint32());
                    break;
                case 7:
                    m.kycKey = $root.proto.Key.decode(r, r.uint32());
                    break;
                case 8:
                    m.freezeKey = $root.proto.Key.decode(r, r.uint32());
                    break;
                case 9:
                    m.wipeKey = $root.proto.Key.decode(r, r.uint32());
                    break;
                case 10:
                    m.supplyKey = $root.proto.Key.decode(r, r.uint32());
                    break;
                case 11:
                    m.freezeDefault = r.bool();
                    break;
                case 13:
                    m.expiry = $root.proto.Timestamp.decode(r, r.uint32());
                    break;
                case 14:
                    m.autoRenewAccount = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 15:
                    m.autoRenewPeriod = $root.proto.Duration.decode(r, r.uint32());
                    break;
                case 16:
                    m.memo = r.string();
                    break;
                case 17:
                    m.tokenType = r.int32();
                    break;
                case 18:
                    m.supplyType = r.int32();
                    break;
                case 19:
                    m.maxSupply = r.int64();
                    break;
                case 20:
                    m.feeScheduleKey = $root.proto.Key.decode(r, r.uint32());
                    break;
                case 21:
                    if (!(m.customFees && m.customFees.length))
                        m.customFees = [];
                    m.customFees.push($root.proto.CustomFee.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TokenCreateTransactionBody;
    })();

    proto.FractionalFee = (function() {

        /**
         * Properties of a FractionalFee.
         * @memberof proto
         * @interface IFractionalFee
         * @property {proto.IFraction|null} [fractionalAmount] FractionalFee fractionalAmount
         * @property {Long|null} [minimumAmount] FractionalFee minimumAmount
         * @property {Long|null} [maximumAmount] FractionalFee maximumAmount
         */

        /**
         * Constructs a new FractionalFee.
         * @memberof proto
         * @classdesc Represents a FractionalFee.
         * @implements IFractionalFee
         * @constructor
         * @param {proto.IFractionalFee=} [p] Properties to set
         */
        function FractionalFee(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * FractionalFee fractionalAmount.
         * @member {proto.IFraction|null|undefined} fractionalAmount
         * @memberof proto.FractionalFee
         * @instance
         */
        FractionalFee.prototype.fractionalAmount = null;

        /**
         * FractionalFee minimumAmount.
         * @member {Long} minimumAmount
         * @memberof proto.FractionalFee
         * @instance
         */
        FractionalFee.prototype.minimumAmount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FractionalFee maximumAmount.
         * @member {Long} maximumAmount
         * @memberof proto.FractionalFee
         * @instance
         */
        FractionalFee.prototype.maximumAmount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new FractionalFee instance using the specified properties.
         * @function create
         * @memberof proto.FractionalFee
         * @static
         * @param {proto.IFractionalFee=} [properties] Properties to set
         * @returns {proto.FractionalFee} FractionalFee instance
         */
        FractionalFee.create = function create(properties) {
            return new FractionalFee(properties);
        };

        /**
         * Encodes the specified FractionalFee message. Does not implicitly {@link proto.FractionalFee.verify|verify} messages.
         * @function encode
         * @memberof proto.FractionalFee
         * @static
         * @param {proto.IFractionalFee} m FractionalFee message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FractionalFee.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.fractionalAmount != null && Object.hasOwnProperty.call(m, "fractionalAmount"))
                $root.proto.Fraction.encode(m.fractionalAmount, w.uint32(10).fork()).ldelim();
            if (m.minimumAmount != null && Object.hasOwnProperty.call(m, "minimumAmount"))
                w.uint32(16).int64(m.minimumAmount);
            if (m.maximumAmount != null && Object.hasOwnProperty.call(m, "maximumAmount"))
                w.uint32(24).int64(m.maximumAmount);
            return w;
        };

        /**
         * Decodes a FractionalFee message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FractionalFee
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FractionalFee} FractionalFee
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FractionalFee.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.FractionalFee();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.fractionalAmount = $root.proto.Fraction.decode(r, r.uint32());
                    break;
                case 2:
                    m.minimumAmount = r.int64();
                    break;
                case 3:
                    m.maximumAmount = r.int64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return FractionalFee;
    })();

    proto.FixedFee = (function() {

        /**
         * Properties of a FixedFee.
         * @memberof proto
         * @interface IFixedFee
         * @property {Long|null} [amount] FixedFee amount
         * @property {proto.ITokenID|null} [denominatingTokenId] FixedFee denominatingTokenId
         */

        /**
         * Constructs a new FixedFee.
         * @memberof proto
         * @classdesc Represents a FixedFee.
         * @implements IFixedFee
         * @constructor
         * @param {proto.IFixedFee=} [p] Properties to set
         */
        function FixedFee(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * FixedFee amount.
         * @member {Long} amount
         * @memberof proto.FixedFee
         * @instance
         */
        FixedFee.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FixedFee denominatingTokenId.
         * @member {proto.ITokenID|null|undefined} denominatingTokenId
         * @memberof proto.FixedFee
         * @instance
         */
        FixedFee.prototype.denominatingTokenId = null;

        /**
         * Creates a new FixedFee instance using the specified properties.
         * @function create
         * @memberof proto.FixedFee
         * @static
         * @param {proto.IFixedFee=} [properties] Properties to set
         * @returns {proto.FixedFee} FixedFee instance
         */
        FixedFee.create = function create(properties) {
            return new FixedFee(properties);
        };

        /**
         * Encodes the specified FixedFee message. Does not implicitly {@link proto.FixedFee.verify|verify} messages.
         * @function encode
         * @memberof proto.FixedFee
         * @static
         * @param {proto.IFixedFee} m FixedFee message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FixedFee.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                w.uint32(8).int64(m.amount);
            if (m.denominatingTokenId != null && Object.hasOwnProperty.call(m, "denominatingTokenId"))
                $root.proto.TokenID.encode(m.denominatingTokenId, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a FixedFee message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FixedFee
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FixedFee} FixedFee
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FixedFee.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.FixedFee();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.amount = r.int64();
                    break;
                case 2:
                    m.denominatingTokenId = $root.proto.TokenID.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return FixedFee;
    })();

    proto.CustomFee = (function() {

        /**
         * Properties of a CustomFee.
         * @memberof proto
         * @interface ICustomFee
         * @property {proto.IFixedFee|null} [fixedFee] CustomFee fixedFee
         * @property {proto.IFractionalFee|null} [fractionalFee] CustomFee fractionalFee
         * @property {proto.IAccountID|null} [feeCollectorAccountId] CustomFee feeCollectorAccountId
         */

        /**
         * Constructs a new CustomFee.
         * @memberof proto
         * @classdesc Represents a CustomFee.
         * @implements ICustomFee
         * @constructor
         * @param {proto.ICustomFee=} [p] Properties to set
         */
        function CustomFee(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * CustomFee fixedFee.
         * @member {proto.IFixedFee|null|undefined} fixedFee
         * @memberof proto.CustomFee
         * @instance
         */
        CustomFee.prototype.fixedFee = null;

        /**
         * CustomFee fractionalFee.
         * @member {proto.IFractionalFee|null|undefined} fractionalFee
         * @memberof proto.CustomFee
         * @instance
         */
        CustomFee.prototype.fractionalFee = null;

        /**
         * CustomFee feeCollectorAccountId.
         * @member {proto.IAccountID|null|undefined} feeCollectorAccountId
         * @memberof proto.CustomFee
         * @instance
         */
        CustomFee.prototype.feeCollectorAccountId = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * CustomFee fee.
         * @member {"fixedFee"|"fractionalFee"|undefined} fee
         * @memberof proto.CustomFee
         * @instance
         */
        Object.defineProperty(CustomFee.prototype, "fee", {
            get: $util.oneOfGetter($oneOfFields = ["fixedFee", "fractionalFee"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new CustomFee instance using the specified properties.
         * @function create
         * @memberof proto.CustomFee
         * @static
         * @param {proto.ICustomFee=} [properties] Properties to set
         * @returns {proto.CustomFee} CustomFee instance
         */
        CustomFee.create = function create(properties) {
            return new CustomFee(properties);
        };

        /**
         * Encodes the specified CustomFee message. Does not implicitly {@link proto.CustomFee.verify|verify} messages.
         * @function encode
         * @memberof proto.CustomFee
         * @static
         * @param {proto.ICustomFee} m CustomFee message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CustomFee.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.fixedFee != null && Object.hasOwnProperty.call(m, "fixedFee"))
                $root.proto.FixedFee.encode(m.fixedFee, w.uint32(10).fork()).ldelim();
            if (m.fractionalFee != null && Object.hasOwnProperty.call(m, "fractionalFee"))
                $root.proto.FractionalFee.encode(m.fractionalFee, w.uint32(18).fork()).ldelim();
            if (m.feeCollectorAccountId != null && Object.hasOwnProperty.call(m, "feeCollectorAccountId"))
                $root.proto.AccountID.encode(m.feeCollectorAccountId, w.uint32(26).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a CustomFee message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CustomFee
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CustomFee} CustomFee
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CustomFee.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CustomFee();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.fixedFee = $root.proto.FixedFee.decode(r, r.uint32());
                    break;
                case 2:
                    m.fractionalFee = $root.proto.FractionalFee.decode(r, r.uint32());
                    break;
                case 3:
                    m.feeCollectorAccountId = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return CustomFee;
    })();

    proto.AssessedCustomFee = (function() {

        /**
         * Properties of an AssessedCustomFee.
         * @memberof proto
         * @interface IAssessedCustomFee
         * @property {Long|null} [amount] AssessedCustomFee amount
         * @property {proto.ITokenID|null} [tokenId] AssessedCustomFee tokenId
         * @property {proto.IAccountID|null} [feeCollectorAccountId] AssessedCustomFee feeCollectorAccountId
         */

        /**
         * Constructs a new AssessedCustomFee.
         * @memberof proto
         * @classdesc Represents an AssessedCustomFee.
         * @implements IAssessedCustomFee
         * @constructor
         * @param {proto.IAssessedCustomFee=} [p] Properties to set
         */
        function AssessedCustomFee(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * AssessedCustomFee amount.
         * @member {Long} amount
         * @memberof proto.AssessedCustomFee
         * @instance
         */
        AssessedCustomFee.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AssessedCustomFee tokenId.
         * @member {proto.ITokenID|null|undefined} tokenId
         * @memberof proto.AssessedCustomFee
         * @instance
         */
        AssessedCustomFee.prototype.tokenId = null;

        /**
         * AssessedCustomFee feeCollectorAccountId.
         * @member {proto.IAccountID|null|undefined} feeCollectorAccountId
         * @memberof proto.AssessedCustomFee
         * @instance
         */
        AssessedCustomFee.prototype.feeCollectorAccountId = null;

        /**
         * Creates a new AssessedCustomFee instance using the specified properties.
         * @function create
         * @memberof proto.AssessedCustomFee
         * @static
         * @param {proto.IAssessedCustomFee=} [properties] Properties to set
         * @returns {proto.AssessedCustomFee} AssessedCustomFee instance
         */
        AssessedCustomFee.create = function create(properties) {
            return new AssessedCustomFee(properties);
        };

        /**
         * Encodes the specified AssessedCustomFee message. Does not implicitly {@link proto.AssessedCustomFee.verify|verify} messages.
         * @function encode
         * @memberof proto.AssessedCustomFee
         * @static
         * @param {proto.IAssessedCustomFee} m AssessedCustomFee message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AssessedCustomFee.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                w.uint32(8).int64(m.amount);
            if (m.tokenId != null && Object.hasOwnProperty.call(m, "tokenId"))
                $root.proto.TokenID.encode(m.tokenId, w.uint32(18).fork()).ldelim();
            if (m.feeCollectorAccountId != null && Object.hasOwnProperty.call(m, "feeCollectorAccountId"))
                $root.proto.AccountID.encode(m.feeCollectorAccountId, w.uint32(26).fork()).ldelim();
            return w;
        };

        /**
         * Decodes an AssessedCustomFee message from the specified reader or buffer.
         * @function decode
         * @memberof proto.AssessedCustomFee
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.AssessedCustomFee} AssessedCustomFee
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AssessedCustomFee.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.AssessedCustomFee();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.amount = r.int64();
                    break;
                case 2:
                    m.tokenId = $root.proto.TokenID.decode(r, r.uint32());
                    break;
                case 3:
                    m.feeCollectorAccountId = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return AssessedCustomFee;
    })();

    proto.TokenFreezeAccountTransactionBody = (function() {

        /**
         * Properties of a TokenFreezeAccountTransactionBody.
         * @memberof proto
         * @interface ITokenFreezeAccountTransactionBody
         * @property {proto.ITokenID|null} [token] TokenFreezeAccountTransactionBody token
         * @property {proto.IAccountID|null} [account] TokenFreezeAccountTransactionBody account
         */

        /**
         * Constructs a new TokenFreezeAccountTransactionBody.
         * @memberof proto
         * @classdesc Represents a TokenFreezeAccountTransactionBody.
         * @implements ITokenFreezeAccountTransactionBody
         * @constructor
         * @param {proto.ITokenFreezeAccountTransactionBody=} [p] Properties to set
         */
        function TokenFreezeAccountTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TokenFreezeAccountTransactionBody token.
         * @member {proto.ITokenID|null|undefined} token
         * @memberof proto.TokenFreezeAccountTransactionBody
         * @instance
         */
        TokenFreezeAccountTransactionBody.prototype.token = null;

        /**
         * TokenFreezeAccountTransactionBody account.
         * @member {proto.IAccountID|null|undefined} account
         * @memberof proto.TokenFreezeAccountTransactionBody
         * @instance
         */
        TokenFreezeAccountTransactionBody.prototype.account = null;

        /**
         * Creates a new TokenFreezeAccountTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenFreezeAccountTransactionBody
         * @static
         * @param {proto.ITokenFreezeAccountTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenFreezeAccountTransactionBody} TokenFreezeAccountTransactionBody instance
         */
        TokenFreezeAccountTransactionBody.create = function create(properties) {
            return new TokenFreezeAccountTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenFreezeAccountTransactionBody message. Does not implicitly {@link proto.TokenFreezeAccountTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenFreezeAccountTransactionBody
         * @static
         * @param {proto.ITokenFreezeAccountTransactionBody} m TokenFreezeAccountTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenFreezeAccountTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.token != null && Object.hasOwnProperty.call(m, "token"))
                $root.proto.TokenID.encode(m.token, w.uint32(10).fork()).ldelim();
            if (m.account != null && Object.hasOwnProperty.call(m, "account"))
                $root.proto.AccountID.encode(m.account, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenFreezeAccountTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenFreezeAccountTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenFreezeAccountTransactionBody} TokenFreezeAccountTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenFreezeAccountTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenFreezeAccountTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.token = $root.proto.TokenID.decode(r, r.uint32());
                    break;
                case 2:
                    m.account = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TokenFreezeAccountTransactionBody;
    })();

    proto.TokenUnfreezeAccountTransactionBody = (function() {

        /**
         * Properties of a TokenUnfreezeAccountTransactionBody.
         * @memberof proto
         * @interface ITokenUnfreezeAccountTransactionBody
         * @property {proto.ITokenID|null} [token] TokenUnfreezeAccountTransactionBody token
         * @property {proto.IAccountID|null} [account] TokenUnfreezeAccountTransactionBody account
         */

        /**
         * Constructs a new TokenUnfreezeAccountTransactionBody.
         * @memberof proto
         * @classdesc Represents a TokenUnfreezeAccountTransactionBody.
         * @implements ITokenUnfreezeAccountTransactionBody
         * @constructor
         * @param {proto.ITokenUnfreezeAccountTransactionBody=} [p] Properties to set
         */
        function TokenUnfreezeAccountTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TokenUnfreezeAccountTransactionBody token.
         * @member {proto.ITokenID|null|undefined} token
         * @memberof proto.TokenUnfreezeAccountTransactionBody
         * @instance
         */
        TokenUnfreezeAccountTransactionBody.prototype.token = null;

        /**
         * TokenUnfreezeAccountTransactionBody account.
         * @member {proto.IAccountID|null|undefined} account
         * @memberof proto.TokenUnfreezeAccountTransactionBody
         * @instance
         */
        TokenUnfreezeAccountTransactionBody.prototype.account = null;

        /**
         * Creates a new TokenUnfreezeAccountTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenUnfreezeAccountTransactionBody
         * @static
         * @param {proto.ITokenUnfreezeAccountTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenUnfreezeAccountTransactionBody} TokenUnfreezeAccountTransactionBody instance
         */
        TokenUnfreezeAccountTransactionBody.create = function create(properties) {
            return new TokenUnfreezeAccountTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenUnfreezeAccountTransactionBody message. Does not implicitly {@link proto.TokenUnfreezeAccountTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenUnfreezeAccountTransactionBody
         * @static
         * @param {proto.ITokenUnfreezeAccountTransactionBody} m TokenUnfreezeAccountTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenUnfreezeAccountTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.token != null && Object.hasOwnProperty.call(m, "token"))
                $root.proto.TokenID.encode(m.token, w.uint32(10).fork()).ldelim();
            if (m.account != null && Object.hasOwnProperty.call(m, "account"))
                $root.proto.AccountID.encode(m.account, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenUnfreezeAccountTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenUnfreezeAccountTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenUnfreezeAccountTransactionBody} TokenUnfreezeAccountTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenUnfreezeAccountTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenUnfreezeAccountTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.token = $root.proto.TokenID.decode(r, r.uint32());
                    break;
                case 2:
                    m.account = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TokenUnfreezeAccountTransactionBody;
    })();

    proto.TokenGrantKycTransactionBody = (function() {

        /**
         * Properties of a TokenGrantKycTransactionBody.
         * @memberof proto
         * @interface ITokenGrantKycTransactionBody
         * @property {proto.ITokenID|null} [token] TokenGrantKycTransactionBody token
         * @property {proto.IAccountID|null} [account] TokenGrantKycTransactionBody account
         */

        /**
         * Constructs a new TokenGrantKycTransactionBody.
         * @memberof proto
         * @classdesc Represents a TokenGrantKycTransactionBody.
         * @implements ITokenGrantKycTransactionBody
         * @constructor
         * @param {proto.ITokenGrantKycTransactionBody=} [p] Properties to set
         */
        function TokenGrantKycTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TokenGrantKycTransactionBody token.
         * @member {proto.ITokenID|null|undefined} token
         * @memberof proto.TokenGrantKycTransactionBody
         * @instance
         */
        TokenGrantKycTransactionBody.prototype.token = null;

        /**
         * TokenGrantKycTransactionBody account.
         * @member {proto.IAccountID|null|undefined} account
         * @memberof proto.TokenGrantKycTransactionBody
         * @instance
         */
        TokenGrantKycTransactionBody.prototype.account = null;

        /**
         * Creates a new TokenGrantKycTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenGrantKycTransactionBody
         * @static
         * @param {proto.ITokenGrantKycTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenGrantKycTransactionBody} TokenGrantKycTransactionBody instance
         */
        TokenGrantKycTransactionBody.create = function create(properties) {
            return new TokenGrantKycTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenGrantKycTransactionBody message. Does not implicitly {@link proto.TokenGrantKycTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenGrantKycTransactionBody
         * @static
         * @param {proto.ITokenGrantKycTransactionBody} m TokenGrantKycTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenGrantKycTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.token != null && Object.hasOwnProperty.call(m, "token"))
                $root.proto.TokenID.encode(m.token, w.uint32(10).fork()).ldelim();
            if (m.account != null && Object.hasOwnProperty.call(m, "account"))
                $root.proto.AccountID.encode(m.account, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenGrantKycTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenGrantKycTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenGrantKycTransactionBody} TokenGrantKycTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenGrantKycTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenGrantKycTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.token = $root.proto.TokenID.decode(r, r.uint32());
                    break;
                case 2:
                    m.account = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TokenGrantKycTransactionBody;
    })();

    proto.TokenRevokeKycTransactionBody = (function() {

        /**
         * Properties of a TokenRevokeKycTransactionBody.
         * @memberof proto
         * @interface ITokenRevokeKycTransactionBody
         * @property {proto.ITokenID|null} [token] TokenRevokeKycTransactionBody token
         * @property {proto.IAccountID|null} [account] TokenRevokeKycTransactionBody account
         */

        /**
         * Constructs a new TokenRevokeKycTransactionBody.
         * @memberof proto
         * @classdesc Represents a TokenRevokeKycTransactionBody.
         * @implements ITokenRevokeKycTransactionBody
         * @constructor
         * @param {proto.ITokenRevokeKycTransactionBody=} [p] Properties to set
         */
        function TokenRevokeKycTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TokenRevokeKycTransactionBody token.
         * @member {proto.ITokenID|null|undefined} token
         * @memberof proto.TokenRevokeKycTransactionBody
         * @instance
         */
        TokenRevokeKycTransactionBody.prototype.token = null;

        /**
         * TokenRevokeKycTransactionBody account.
         * @member {proto.IAccountID|null|undefined} account
         * @memberof proto.TokenRevokeKycTransactionBody
         * @instance
         */
        TokenRevokeKycTransactionBody.prototype.account = null;

        /**
         * Creates a new TokenRevokeKycTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenRevokeKycTransactionBody
         * @static
         * @param {proto.ITokenRevokeKycTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenRevokeKycTransactionBody} TokenRevokeKycTransactionBody instance
         */
        TokenRevokeKycTransactionBody.create = function create(properties) {
            return new TokenRevokeKycTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenRevokeKycTransactionBody message. Does not implicitly {@link proto.TokenRevokeKycTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenRevokeKycTransactionBody
         * @static
         * @param {proto.ITokenRevokeKycTransactionBody} m TokenRevokeKycTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenRevokeKycTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.token != null && Object.hasOwnProperty.call(m, "token"))
                $root.proto.TokenID.encode(m.token, w.uint32(10).fork()).ldelim();
            if (m.account != null && Object.hasOwnProperty.call(m, "account"))
                $root.proto.AccountID.encode(m.account, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenRevokeKycTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenRevokeKycTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenRevokeKycTransactionBody} TokenRevokeKycTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenRevokeKycTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenRevokeKycTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.token = $root.proto.TokenID.decode(r, r.uint32());
                    break;
                case 2:
                    m.account = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TokenRevokeKycTransactionBody;
    })();

    proto.TokenDeleteTransactionBody = (function() {

        /**
         * Properties of a TokenDeleteTransactionBody.
         * @memberof proto
         * @interface ITokenDeleteTransactionBody
         * @property {proto.ITokenID|null} [token] TokenDeleteTransactionBody token
         */

        /**
         * Constructs a new TokenDeleteTransactionBody.
         * @memberof proto
         * @classdesc Represents a TokenDeleteTransactionBody.
         * @implements ITokenDeleteTransactionBody
         * @constructor
         * @param {proto.ITokenDeleteTransactionBody=} [p] Properties to set
         */
        function TokenDeleteTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TokenDeleteTransactionBody token.
         * @member {proto.ITokenID|null|undefined} token
         * @memberof proto.TokenDeleteTransactionBody
         * @instance
         */
        TokenDeleteTransactionBody.prototype.token = null;

        /**
         * Creates a new TokenDeleteTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenDeleteTransactionBody
         * @static
         * @param {proto.ITokenDeleteTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenDeleteTransactionBody} TokenDeleteTransactionBody instance
         */
        TokenDeleteTransactionBody.create = function create(properties) {
            return new TokenDeleteTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenDeleteTransactionBody message. Does not implicitly {@link proto.TokenDeleteTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenDeleteTransactionBody
         * @static
         * @param {proto.ITokenDeleteTransactionBody} m TokenDeleteTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenDeleteTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.token != null && Object.hasOwnProperty.call(m, "token"))
                $root.proto.TokenID.encode(m.token, w.uint32(10).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenDeleteTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenDeleteTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenDeleteTransactionBody} TokenDeleteTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenDeleteTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenDeleteTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.token = $root.proto.TokenID.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TokenDeleteTransactionBody;
    })();

    proto.TokenUpdateTransactionBody = (function() {

        /**
         * Properties of a TokenUpdateTransactionBody.
         * @memberof proto
         * @interface ITokenUpdateTransactionBody
         * @property {proto.ITokenID|null} [token] TokenUpdateTransactionBody token
         * @property {string|null} [symbol] TokenUpdateTransactionBody symbol
         * @property {string|null} [name] TokenUpdateTransactionBody name
         * @property {proto.IAccountID|null} [treasury] TokenUpdateTransactionBody treasury
         * @property {proto.IKey|null} [adminKey] TokenUpdateTransactionBody adminKey
         * @property {proto.IKey|null} [kycKey] TokenUpdateTransactionBody kycKey
         * @property {proto.IKey|null} [freezeKey] TokenUpdateTransactionBody freezeKey
         * @property {proto.IKey|null} [wipeKey] TokenUpdateTransactionBody wipeKey
         * @property {proto.IKey|null} [supplyKey] TokenUpdateTransactionBody supplyKey
         * @property {proto.IAccountID|null} [autoRenewAccount] TokenUpdateTransactionBody autoRenewAccount
         * @property {proto.IDuration|null} [autoRenewPeriod] TokenUpdateTransactionBody autoRenewPeriod
         * @property {proto.ITimestamp|null} [expiry] TokenUpdateTransactionBody expiry
         * @property {google.protobuf.IStringValue|null} [memo] TokenUpdateTransactionBody memo
         * @property {proto.IKey|null} [feeScheduleKey] TokenUpdateTransactionBody feeScheduleKey
         */

        /**
         * Constructs a new TokenUpdateTransactionBody.
         * @memberof proto
         * @classdesc Represents a TokenUpdateTransactionBody.
         * @implements ITokenUpdateTransactionBody
         * @constructor
         * @param {proto.ITokenUpdateTransactionBody=} [p] Properties to set
         */
        function TokenUpdateTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TokenUpdateTransactionBody token.
         * @member {proto.ITokenID|null|undefined} token
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.token = null;

        /**
         * TokenUpdateTransactionBody symbol.
         * @member {string} symbol
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.symbol = "";

        /**
         * TokenUpdateTransactionBody name.
         * @member {string} name
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.name = "";

        /**
         * TokenUpdateTransactionBody treasury.
         * @member {proto.IAccountID|null|undefined} treasury
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.treasury = null;

        /**
         * TokenUpdateTransactionBody adminKey.
         * @member {proto.IKey|null|undefined} adminKey
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.adminKey = null;

        /**
         * TokenUpdateTransactionBody kycKey.
         * @member {proto.IKey|null|undefined} kycKey
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.kycKey = null;

        /**
         * TokenUpdateTransactionBody freezeKey.
         * @member {proto.IKey|null|undefined} freezeKey
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.freezeKey = null;

        /**
         * TokenUpdateTransactionBody wipeKey.
         * @member {proto.IKey|null|undefined} wipeKey
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.wipeKey = null;

        /**
         * TokenUpdateTransactionBody supplyKey.
         * @member {proto.IKey|null|undefined} supplyKey
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.supplyKey = null;

        /**
         * TokenUpdateTransactionBody autoRenewAccount.
         * @member {proto.IAccountID|null|undefined} autoRenewAccount
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.autoRenewAccount = null;

        /**
         * TokenUpdateTransactionBody autoRenewPeriod.
         * @member {proto.IDuration|null|undefined} autoRenewPeriod
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.autoRenewPeriod = null;

        /**
         * TokenUpdateTransactionBody expiry.
         * @member {proto.ITimestamp|null|undefined} expiry
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.expiry = null;

        /**
         * TokenUpdateTransactionBody memo.
         * @member {google.protobuf.IStringValue|null|undefined} memo
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.memo = null;

        /**
         * TokenUpdateTransactionBody feeScheduleKey.
         * @member {proto.IKey|null|undefined} feeScheduleKey
         * @memberof proto.TokenUpdateTransactionBody
         * @instance
         */
        TokenUpdateTransactionBody.prototype.feeScheduleKey = null;

        /**
         * Creates a new TokenUpdateTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenUpdateTransactionBody
         * @static
         * @param {proto.ITokenUpdateTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenUpdateTransactionBody} TokenUpdateTransactionBody instance
         */
        TokenUpdateTransactionBody.create = function create(properties) {
            return new TokenUpdateTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenUpdateTransactionBody message. Does not implicitly {@link proto.TokenUpdateTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenUpdateTransactionBody
         * @static
         * @param {proto.ITokenUpdateTransactionBody} m TokenUpdateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenUpdateTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.token != null && Object.hasOwnProperty.call(m, "token"))
                $root.proto.TokenID.encode(m.token, w.uint32(10).fork()).ldelim();
            if (m.symbol != null && Object.hasOwnProperty.call(m, "symbol"))
                w.uint32(18).string(m.symbol);
            if (m.name != null && Object.hasOwnProperty.call(m, "name"))
                w.uint32(26).string(m.name);
            if (m.treasury != null && Object.hasOwnProperty.call(m, "treasury"))
                $root.proto.AccountID.encode(m.treasury, w.uint32(34).fork()).ldelim();
            if (m.adminKey != null && Object.hasOwnProperty.call(m, "adminKey"))
                $root.proto.Key.encode(m.adminKey, w.uint32(42).fork()).ldelim();
            if (m.kycKey != null && Object.hasOwnProperty.call(m, "kycKey"))
                $root.proto.Key.encode(m.kycKey, w.uint32(50).fork()).ldelim();
            if (m.freezeKey != null && Object.hasOwnProperty.call(m, "freezeKey"))
                $root.proto.Key.encode(m.freezeKey, w.uint32(58).fork()).ldelim();
            if (m.wipeKey != null && Object.hasOwnProperty.call(m, "wipeKey"))
                $root.proto.Key.encode(m.wipeKey, w.uint32(66).fork()).ldelim();
            if (m.supplyKey != null && Object.hasOwnProperty.call(m, "supplyKey"))
                $root.proto.Key.encode(m.supplyKey, w.uint32(74).fork()).ldelim();
            if (m.autoRenewAccount != null && Object.hasOwnProperty.call(m, "autoRenewAccount"))
                $root.proto.AccountID.encode(m.autoRenewAccount, w.uint32(82).fork()).ldelim();
            if (m.autoRenewPeriod != null && Object.hasOwnProperty.call(m, "autoRenewPeriod"))
                $root.proto.Duration.encode(m.autoRenewPeriod, w.uint32(90).fork()).ldelim();
            if (m.expiry != null && Object.hasOwnProperty.call(m, "expiry"))
                $root.proto.Timestamp.encode(m.expiry, w.uint32(98).fork()).ldelim();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                $root.google.protobuf.StringValue.encode(m.memo, w.uint32(106).fork()).ldelim();
            if (m.feeScheduleKey != null && Object.hasOwnProperty.call(m, "feeScheduleKey"))
                $root.proto.Key.encode(m.feeScheduleKey, w.uint32(114).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenUpdateTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenUpdateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenUpdateTransactionBody} TokenUpdateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenUpdateTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenUpdateTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.token = $root.proto.TokenID.decode(r, r.uint32());
                    break;
                case 2:
                    m.symbol = r.string();
                    break;
                case 3:
                    m.name = r.string();
                    break;
                case 4:
                    m.treasury = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 5:
                    m.adminKey = $root.proto.Key.decode(r, r.uint32());
                    break;
                case 6:
                    m.kycKey = $root.proto.Key.decode(r, r.uint32());
                    break;
                case 7:
                    m.freezeKey = $root.proto.Key.decode(r, r.uint32());
                    break;
                case 8:
                    m.wipeKey = $root.proto.Key.decode(r, r.uint32());
                    break;
                case 9:
                    m.supplyKey = $root.proto.Key.decode(r, r.uint32());
                    break;
                case 10:
                    m.autoRenewAccount = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 11:
                    m.autoRenewPeriod = $root.proto.Duration.decode(r, r.uint32());
                    break;
                case 12:
                    m.expiry = $root.proto.Timestamp.decode(r, r.uint32());
                    break;
                case 13:
                    m.memo = $root.google.protobuf.StringValue.decode(r, r.uint32());
                    break;
                case 14:
                    m.feeScheduleKey = $root.proto.Key.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TokenUpdateTransactionBody;
    })();

    proto.TokenMintTransactionBody = (function() {

        /**
         * Properties of a TokenMintTransactionBody.
         * @memberof proto
         * @interface ITokenMintTransactionBody
         * @property {proto.ITokenID|null} [token] TokenMintTransactionBody token
         * @property {Long|null} [amount] TokenMintTransactionBody amount
         * @property {Array.<Uint8Array>|null} [metadata] TokenMintTransactionBody metadata
         */

        /**
         * Constructs a new TokenMintTransactionBody.
         * @memberof proto
         * @classdesc Represents a TokenMintTransactionBody.
         * @implements ITokenMintTransactionBody
         * @constructor
         * @param {proto.ITokenMintTransactionBody=} [p] Properties to set
         */
        function TokenMintTransactionBody(p) {
            this.metadata = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TokenMintTransactionBody token.
         * @member {proto.ITokenID|null|undefined} token
         * @memberof proto.TokenMintTransactionBody
         * @instance
         */
        TokenMintTransactionBody.prototype.token = null;

        /**
         * TokenMintTransactionBody amount.
         * @member {Long} amount
         * @memberof proto.TokenMintTransactionBody
         * @instance
         */
        TokenMintTransactionBody.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TokenMintTransactionBody metadata.
         * @member {Array.<Uint8Array>} metadata
         * @memberof proto.TokenMintTransactionBody
         * @instance
         */
        TokenMintTransactionBody.prototype.metadata = $util.emptyArray;

        /**
         * Creates a new TokenMintTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenMintTransactionBody
         * @static
         * @param {proto.ITokenMintTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenMintTransactionBody} TokenMintTransactionBody instance
         */
        TokenMintTransactionBody.create = function create(properties) {
            return new TokenMintTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenMintTransactionBody message. Does not implicitly {@link proto.TokenMintTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenMintTransactionBody
         * @static
         * @param {proto.ITokenMintTransactionBody} m TokenMintTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenMintTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.token != null && Object.hasOwnProperty.call(m, "token"))
                $root.proto.TokenID.encode(m.token, w.uint32(10).fork()).ldelim();
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                w.uint32(16).uint64(m.amount);
            if (m.metadata != null && m.metadata.length) {
                for (var i = 0; i < m.metadata.length; ++i)
                    w.uint32(26).bytes(m.metadata[i]);
            }
            return w;
        };

        /**
         * Decodes a TokenMintTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenMintTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenMintTransactionBody} TokenMintTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenMintTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenMintTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.token = $root.proto.TokenID.decode(r, r.uint32());
                    break;
                case 2:
                    m.amount = r.uint64();
                    break;
                case 3:
                    if (!(m.metadata && m.metadata.length))
                        m.metadata = [];
                    m.metadata.push(r.bytes());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TokenMintTransactionBody;
    })();

    proto.TokenBurnTransactionBody = (function() {

        /**
         * Properties of a TokenBurnTransactionBody.
         * @memberof proto
         * @interface ITokenBurnTransactionBody
         * @property {proto.ITokenID|null} [token] TokenBurnTransactionBody token
         * @property {Long|null} [amount] TokenBurnTransactionBody amount
         * @property {Array.<Long>|null} [serialNumbers] TokenBurnTransactionBody serialNumbers
         */

        /**
         * Constructs a new TokenBurnTransactionBody.
         * @memberof proto
         * @classdesc Represents a TokenBurnTransactionBody.
         * @implements ITokenBurnTransactionBody
         * @constructor
         * @param {proto.ITokenBurnTransactionBody=} [p] Properties to set
         */
        function TokenBurnTransactionBody(p) {
            this.serialNumbers = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TokenBurnTransactionBody token.
         * @member {proto.ITokenID|null|undefined} token
         * @memberof proto.TokenBurnTransactionBody
         * @instance
         */
        TokenBurnTransactionBody.prototype.token = null;

        /**
         * TokenBurnTransactionBody amount.
         * @member {Long} amount
         * @memberof proto.TokenBurnTransactionBody
         * @instance
         */
        TokenBurnTransactionBody.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TokenBurnTransactionBody serialNumbers.
         * @member {Array.<Long>} serialNumbers
         * @memberof proto.TokenBurnTransactionBody
         * @instance
         */
        TokenBurnTransactionBody.prototype.serialNumbers = $util.emptyArray;

        /**
         * Creates a new TokenBurnTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenBurnTransactionBody
         * @static
         * @param {proto.ITokenBurnTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenBurnTransactionBody} TokenBurnTransactionBody instance
         */
        TokenBurnTransactionBody.create = function create(properties) {
            return new TokenBurnTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenBurnTransactionBody message. Does not implicitly {@link proto.TokenBurnTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenBurnTransactionBody
         * @static
         * @param {proto.ITokenBurnTransactionBody} m TokenBurnTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenBurnTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.token != null && Object.hasOwnProperty.call(m, "token"))
                $root.proto.TokenID.encode(m.token, w.uint32(10).fork()).ldelim();
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                w.uint32(16).uint64(m.amount);
            if (m.serialNumbers != null && m.serialNumbers.length) {
                w.uint32(26).fork();
                for (var i = 0; i < m.serialNumbers.length; ++i)
                    w.int64(m.serialNumbers[i]);
                w.ldelim();
            }
            return w;
        };

        /**
         * Decodes a TokenBurnTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenBurnTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenBurnTransactionBody} TokenBurnTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenBurnTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenBurnTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.token = $root.proto.TokenID.decode(r, r.uint32());
                    break;
                case 2:
                    m.amount = r.uint64();
                    break;
                case 3:
                    if (!(m.serialNumbers && m.serialNumbers.length))
                        m.serialNumbers = [];
                    if ((t & 7) === 2) {
                        var c2 = r.uint32() + r.pos;
                        while (r.pos < c2)
                            m.serialNumbers.push(r.int64());
                    } else
                        m.serialNumbers.push(r.int64());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TokenBurnTransactionBody;
    })();

    proto.TokenWipeAccountTransactionBody = (function() {

        /**
         * Properties of a TokenWipeAccountTransactionBody.
         * @memberof proto
         * @interface ITokenWipeAccountTransactionBody
         * @property {proto.ITokenID|null} [token] TokenWipeAccountTransactionBody token
         * @property {proto.IAccountID|null} [account] TokenWipeAccountTransactionBody account
         * @property {Long|null} [amount] TokenWipeAccountTransactionBody amount
         * @property {Array.<Long>|null} [serialNumbers] TokenWipeAccountTransactionBody serialNumbers
         */

        /**
         * Constructs a new TokenWipeAccountTransactionBody.
         * @memberof proto
         * @classdesc Represents a TokenWipeAccountTransactionBody.
         * @implements ITokenWipeAccountTransactionBody
         * @constructor
         * @param {proto.ITokenWipeAccountTransactionBody=} [p] Properties to set
         */
        function TokenWipeAccountTransactionBody(p) {
            this.serialNumbers = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TokenWipeAccountTransactionBody token.
         * @member {proto.ITokenID|null|undefined} token
         * @memberof proto.TokenWipeAccountTransactionBody
         * @instance
         */
        TokenWipeAccountTransactionBody.prototype.token = null;

        /**
         * TokenWipeAccountTransactionBody account.
         * @member {proto.IAccountID|null|undefined} account
         * @memberof proto.TokenWipeAccountTransactionBody
         * @instance
         */
        TokenWipeAccountTransactionBody.prototype.account = null;

        /**
         * TokenWipeAccountTransactionBody amount.
         * @member {Long} amount
         * @memberof proto.TokenWipeAccountTransactionBody
         * @instance
         */
        TokenWipeAccountTransactionBody.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TokenWipeAccountTransactionBody serialNumbers.
         * @member {Array.<Long>} serialNumbers
         * @memberof proto.TokenWipeAccountTransactionBody
         * @instance
         */
        TokenWipeAccountTransactionBody.prototype.serialNumbers = $util.emptyArray;

        /**
         * Creates a new TokenWipeAccountTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenWipeAccountTransactionBody
         * @static
         * @param {proto.ITokenWipeAccountTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenWipeAccountTransactionBody} TokenWipeAccountTransactionBody instance
         */
        TokenWipeAccountTransactionBody.create = function create(properties) {
            return new TokenWipeAccountTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenWipeAccountTransactionBody message. Does not implicitly {@link proto.TokenWipeAccountTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenWipeAccountTransactionBody
         * @static
         * @param {proto.ITokenWipeAccountTransactionBody} m TokenWipeAccountTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenWipeAccountTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.token != null && Object.hasOwnProperty.call(m, "token"))
                $root.proto.TokenID.encode(m.token, w.uint32(10).fork()).ldelim();
            if (m.account != null && Object.hasOwnProperty.call(m, "account"))
                $root.proto.AccountID.encode(m.account, w.uint32(18).fork()).ldelim();
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                w.uint32(24).uint64(m.amount);
            if (m.serialNumbers != null && m.serialNumbers.length) {
                w.uint32(34).fork();
                for (var i = 0; i < m.serialNumbers.length; ++i)
                    w.int64(m.serialNumbers[i]);
                w.ldelim();
            }
            return w;
        };

        /**
         * Decodes a TokenWipeAccountTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenWipeAccountTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenWipeAccountTransactionBody} TokenWipeAccountTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenWipeAccountTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenWipeAccountTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.token = $root.proto.TokenID.decode(r, r.uint32());
                    break;
                case 2:
                    m.account = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 3:
                    m.amount = r.uint64();
                    break;
                case 4:
                    if (!(m.serialNumbers && m.serialNumbers.length))
                        m.serialNumbers = [];
                    if ((t & 7) === 2) {
                        var c2 = r.uint32() + r.pos;
                        while (r.pos < c2)
                            m.serialNumbers.push(r.int64());
                    } else
                        m.serialNumbers.push(r.int64());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TokenWipeAccountTransactionBody;
    })();

    proto.TokenAssociateTransactionBody = (function() {

        /**
         * Properties of a TokenAssociateTransactionBody.
         * @memberof proto
         * @interface ITokenAssociateTransactionBody
         * @property {proto.IAccountID|null} [account] TokenAssociateTransactionBody account
         * @property {Array.<proto.ITokenID>|null} [tokens] TokenAssociateTransactionBody tokens
         */

        /**
         * Constructs a new TokenAssociateTransactionBody.
         * @memberof proto
         * @classdesc Represents a TokenAssociateTransactionBody.
         * @implements ITokenAssociateTransactionBody
         * @constructor
         * @param {proto.ITokenAssociateTransactionBody=} [p] Properties to set
         */
        function TokenAssociateTransactionBody(p) {
            this.tokens = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TokenAssociateTransactionBody account.
         * @member {proto.IAccountID|null|undefined} account
         * @memberof proto.TokenAssociateTransactionBody
         * @instance
         */
        TokenAssociateTransactionBody.prototype.account = null;

        /**
         * TokenAssociateTransactionBody tokens.
         * @member {Array.<proto.ITokenID>} tokens
         * @memberof proto.TokenAssociateTransactionBody
         * @instance
         */
        TokenAssociateTransactionBody.prototype.tokens = $util.emptyArray;

        /**
         * Creates a new TokenAssociateTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenAssociateTransactionBody
         * @static
         * @param {proto.ITokenAssociateTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenAssociateTransactionBody} TokenAssociateTransactionBody instance
         */
        TokenAssociateTransactionBody.create = function create(properties) {
            return new TokenAssociateTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenAssociateTransactionBody message. Does not implicitly {@link proto.TokenAssociateTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenAssociateTransactionBody
         * @static
         * @param {proto.ITokenAssociateTransactionBody} m TokenAssociateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenAssociateTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.account != null && Object.hasOwnProperty.call(m, "account"))
                $root.proto.AccountID.encode(m.account, w.uint32(10).fork()).ldelim();
            if (m.tokens != null && m.tokens.length) {
                for (var i = 0; i < m.tokens.length; ++i)
                    $root.proto.TokenID.encode(m.tokens[i], w.uint32(18).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TokenAssociateTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenAssociateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenAssociateTransactionBody} TokenAssociateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenAssociateTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenAssociateTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.account = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 2:
                    if (!(m.tokens && m.tokens.length))
                        m.tokens = [];
                    m.tokens.push($root.proto.TokenID.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TokenAssociateTransactionBody;
    })();

    proto.TokenDissociateTransactionBody = (function() {

        /**
         * Properties of a TokenDissociateTransactionBody.
         * @memberof proto
         * @interface ITokenDissociateTransactionBody
         * @property {proto.IAccountID|null} [account] TokenDissociateTransactionBody account
         * @property {Array.<proto.ITokenID>|null} [tokens] TokenDissociateTransactionBody tokens
         */

        /**
         * Constructs a new TokenDissociateTransactionBody.
         * @memberof proto
         * @classdesc Represents a TokenDissociateTransactionBody.
         * @implements ITokenDissociateTransactionBody
         * @constructor
         * @param {proto.ITokenDissociateTransactionBody=} [p] Properties to set
         */
        function TokenDissociateTransactionBody(p) {
            this.tokens = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TokenDissociateTransactionBody account.
         * @member {proto.IAccountID|null|undefined} account
         * @memberof proto.TokenDissociateTransactionBody
         * @instance
         */
        TokenDissociateTransactionBody.prototype.account = null;

        /**
         * TokenDissociateTransactionBody tokens.
         * @member {Array.<proto.ITokenID>} tokens
         * @memberof proto.TokenDissociateTransactionBody
         * @instance
         */
        TokenDissociateTransactionBody.prototype.tokens = $util.emptyArray;

        /**
         * Creates a new TokenDissociateTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenDissociateTransactionBody
         * @static
         * @param {proto.ITokenDissociateTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenDissociateTransactionBody} TokenDissociateTransactionBody instance
         */
        TokenDissociateTransactionBody.create = function create(properties) {
            return new TokenDissociateTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenDissociateTransactionBody message. Does not implicitly {@link proto.TokenDissociateTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenDissociateTransactionBody
         * @static
         * @param {proto.ITokenDissociateTransactionBody} m TokenDissociateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenDissociateTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.account != null && Object.hasOwnProperty.call(m, "account"))
                $root.proto.AccountID.encode(m.account, w.uint32(10).fork()).ldelim();
            if (m.tokens != null && m.tokens.length) {
                for (var i = 0; i < m.tokens.length; ++i)
                    $root.proto.TokenID.encode(m.tokens[i], w.uint32(18).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TokenDissociateTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenDissociateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenDissociateTransactionBody} TokenDissociateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenDissociateTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenDissociateTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.account = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 2:
                    if (!(m.tokens && m.tokens.length))
                        m.tokens = [];
                    m.tokens.push($root.proto.TokenID.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TokenDissociateTransactionBody;
    })();

    proto.TokenFeeScheduleUpdateTransactionBody = (function() {

        /**
         * Properties of a TokenFeeScheduleUpdateTransactionBody.
         * @memberof proto
         * @interface ITokenFeeScheduleUpdateTransactionBody
         * @property {proto.ITokenID|null} [tokenId] TokenFeeScheduleUpdateTransactionBody tokenId
         * @property {Array.<proto.ICustomFee>|null} [customFees] TokenFeeScheduleUpdateTransactionBody customFees
         */

        /**
         * Constructs a new TokenFeeScheduleUpdateTransactionBody.
         * @memberof proto
         * @classdesc Represents a TokenFeeScheduleUpdateTransactionBody.
         * @implements ITokenFeeScheduleUpdateTransactionBody
         * @constructor
         * @param {proto.ITokenFeeScheduleUpdateTransactionBody=} [p] Properties to set
         */
        function TokenFeeScheduleUpdateTransactionBody(p) {
            this.customFees = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TokenFeeScheduleUpdateTransactionBody tokenId.
         * @member {proto.ITokenID|null|undefined} tokenId
         * @memberof proto.TokenFeeScheduleUpdateTransactionBody
         * @instance
         */
        TokenFeeScheduleUpdateTransactionBody.prototype.tokenId = null;

        /**
         * TokenFeeScheduleUpdateTransactionBody customFees.
         * @member {Array.<proto.ICustomFee>} customFees
         * @memberof proto.TokenFeeScheduleUpdateTransactionBody
         * @instance
         */
        TokenFeeScheduleUpdateTransactionBody.prototype.customFees = $util.emptyArray;

        /**
         * Creates a new TokenFeeScheduleUpdateTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenFeeScheduleUpdateTransactionBody
         * @static
         * @param {proto.ITokenFeeScheduleUpdateTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenFeeScheduleUpdateTransactionBody} TokenFeeScheduleUpdateTransactionBody instance
         */
        TokenFeeScheduleUpdateTransactionBody.create = function create(properties) {
            return new TokenFeeScheduleUpdateTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenFeeScheduleUpdateTransactionBody message. Does not implicitly {@link proto.TokenFeeScheduleUpdateTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenFeeScheduleUpdateTransactionBody
         * @static
         * @param {proto.ITokenFeeScheduleUpdateTransactionBody} m TokenFeeScheduleUpdateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenFeeScheduleUpdateTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.tokenId != null && Object.hasOwnProperty.call(m, "tokenId"))
                $root.proto.TokenID.encode(m.tokenId, w.uint32(10).fork()).ldelim();
            if (m.customFees != null && m.customFees.length) {
                for (var i = 0; i < m.customFees.length; ++i)
                    $root.proto.CustomFee.encode(m.customFees[i], w.uint32(18).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TokenFeeScheduleUpdateTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenFeeScheduleUpdateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenFeeScheduleUpdateTransactionBody} TokenFeeScheduleUpdateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenFeeScheduleUpdateTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenFeeScheduleUpdateTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.tokenId = $root.proto.TokenID.decode(r, r.uint32());
                    break;
                case 2:
                    if (!(m.customFees && m.customFees.length))
                        m.customFees = [];
                    m.customFees.push($root.proto.CustomFee.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TokenFeeScheduleUpdateTransactionBody;
    })();

    proto.ScheduleCreateTransactionBody = (function() {

        /**
         * Properties of a ScheduleCreateTransactionBody.
         * @memberof proto
         * @interface IScheduleCreateTransactionBody
         * @property {proto.ISchedulableTransactionBody|null} [scheduledTransactionBody] ScheduleCreateTransactionBody scheduledTransactionBody
         * @property {string|null} [memo] ScheduleCreateTransactionBody memo
         * @property {proto.IKey|null} [adminKey] ScheduleCreateTransactionBody adminKey
         * @property {proto.IAccountID|null} [payerAccountID] ScheduleCreateTransactionBody payerAccountID
         */

        /**
         * Constructs a new ScheduleCreateTransactionBody.
         * @memberof proto
         * @classdesc Represents a ScheduleCreateTransactionBody.
         * @implements IScheduleCreateTransactionBody
         * @constructor
         * @param {proto.IScheduleCreateTransactionBody=} [p] Properties to set
         */
        function ScheduleCreateTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ScheduleCreateTransactionBody scheduledTransactionBody.
         * @member {proto.ISchedulableTransactionBody|null|undefined} scheduledTransactionBody
         * @memberof proto.ScheduleCreateTransactionBody
         * @instance
         */
        ScheduleCreateTransactionBody.prototype.scheduledTransactionBody = null;

        /**
         * ScheduleCreateTransactionBody memo.
         * @member {string} memo
         * @memberof proto.ScheduleCreateTransactionBody
         * @instance
         */
        ScheduleCreateTransactionBody.prototype.memo = "";

        /**
         * ScheduleCreateTransactionBody adminKey.
         * @member {proto.IKey|null|undefined} adminKey
         * @memberof proto.ScheduleCreateTransactionBody
         * @instance
         */
        ScheduleCreateTransactionBody.prototype.adminKey = null;

        /**
         * ScheduleCreateTransactionBody payerAccountID.
         * @member {proto.IAccountID|null|undefined} payerAccountID
         * @memberof proto.ScheduleCreateTransactionBody
         * @instance
         */
        ScheduleCreateTransactionBody.prototype.payerAccountID = null;

        /**
         * Creates a new ScheduleCreateTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.ScheduleCreateTransactionBody
         * @static
         * @param {proto.IScheduleCreateTransactionBody=} [properties] Properties to set
         * @returns {proto.ScheduleCreateTransactionBody} ScheduleCreateTransactionBody instance
         */
        ScheduleCreateTransactionBody.create = function create(properties) {
            return new ScheduleCreateTransactionBody(properties);
        };

        /**
         * Encodes the specified ScheduleCreateTransactionBody message. Does not implicitly {@link proto.ScheduleCreateTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.ScheduleCreateTransactionBody
         * @static
         * @param {proto.IScheduleCreateTransactionBody} m ScheduleCreateTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScheduleCreateTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.scheduledTransactionBody != null && Object.hasOwnProperty.call(m, "scheduledTransactionBody"))
                $root.proto.SchedulableTransactionBody.encode(m.scheduledTransactionBody, w.uint32(10).fork()).ldelim();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                w.uint32(18).string(m.memo);
            if (m.adminKey != null && Object.hasOwnProperty.call(m, "adminKey"))
                $root.proto.Key.encode(m.adminKey, w.uint32(26).fork()).ldelim();
            if (m.payerAccountID != null && Object.hasOwnProperty.call(m, "payerAccountID"))
                $root.proto.AccountID.encode(m.payerAccountID, w.uint32(34).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ScheduleCreateTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ScheduleCreateTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ScheduleCreateTransactionBody} ScheduleCreateTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScheduleCreateTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ScheduleCreateTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.scheduledTransactionBody = $root.proto.SchedulableTransactionBody.decode(r, r.uint32());
                    break;
                case 2:
                    m.memo = r.string();
                    break;
                case 3:
                    m.adminKey = $root.proto.Key.decode(r, r.uint32());
                    break;
                case 4:
                    m.payerAccountID = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ScheduleCreateTransactionBody;
    })();

    proto.SchedulableTransactionBody = (function() {

        /**
         * Properties of a SchedulableTransactionBody.
         * @memberof proto
         * @interface ISchedulableTransactionBody
         * @property {Long|null} [transactionFee] SchedulableTransactionBody transactionFee
         * @property {string|null} [memo] SchedulableTransactionBody memo
         * @property {proto.IContractCallTransactionBody|null} [contractCall] SchedulableTransactionBody contractCall
         * @property {proto.IContractCreateTransactionBody|null} [contractCreateInstance] SchedulableTransactionBody contractCreateInstance
         * @property {proto.IContractUpdateTransactionBody|null} [contractUpdateInstance] SchedulableTransactionBody contractUpdateInstance
         * @property {proto.IContractDeleteTransactionBody|null} [contractDeleteInstance] SchedulableTransactionBody contractDeleteInstance
         * @property {proto.ICryptoCreateTransactionBody|null} [cryptoCreateAccount] SchedulableTransactionBody cryptoCreateAccount
         * @property {proto.ICryptoDeleteTransactionBody|null} [cryptoDelete] SchedulableTransactionBody cryptoDelete
         * @property {proto.ICryptoTransferTransactionBody|null} [cryptoTransfer] SchedulableTransactionBody cryptoTransfer
         * @property {proto.ICryptoUpdateTransactionBody|null} [cryptoUpdateAccount] SchedulableTransactionBody cryptoUpdateAccount
         * @property {proto.IFileAppendTransactionBody|null} [fileAppend] SchedulableTransactionBody fileAppend
         * @property {proto.IFileCreateTransactionBody|null} [fileCreate] SchedulableTransactionBody fileCreate
         * @property {proto.IFileDeleteTransactionBody|null} [fileDelete] SchedulableTransactionBody fileDelete
         * @property {proto.IFileUpdateTransactionBody|null} [fileUpdate] SchedulableTransactionBody fileUpdate
         * @property {proto.ISystemDeleteTransactionBody|null} [systemDelete] SchedulableTransactionBody systemDelete
         * @property {proto.ISystemUndeleteTransactionBody|null} [systemUndelete] SchedulableTransactionBody systemUndelete
         * @property {proto.IFreezeTransactionBody|null} [freeze] SchedulableTransactionBody freeze
         * @property {proto.IConsensusCreateTopicTransactionBody|null} [consensusCreateTopic] SchedulableTransactionBody consensusCreateTopic
         * @property {proto.IConsensusUpdateTopicTransactionBody|null} [consensusUpdateTopic] SchedulableTransactionBody consensusUpdateTopic
         * @property {proto.IConsensusDeleteTopicTransactionBody|null} [consensusDeleteTopic] SchedulableTransactionBody consensusDeleteTopic
         * @property {proto.IConsensusSubmitMessageTransactionBody|null} [consensusSubmitMessage] SchedulableTransactionBody consensusSubmitMessage
         * @property {proto.ITokenCreateTransactionBody|null} [tokenCreation] SchedulableTransactionBody tokenCreation
         * @property {proto.ITokenFreezeAccountTransactionBody|null} [tokenFreeze] SchedulableTransactionBody tokenFreeze
         * @property {proto.ITokenUnfreezeAccountTransactionBody|null} [tokenUnfreeze] SchedulableTransactionBody tokenUnfreeze
         * @property {proto.ITokenGrantKycTransactionBody|null} [tokenGrantKyc] SchedulableTransactionBody tokenGrantKyc
         * @property {proto.ITokenRevokeKycTransactionBody|null} [tokenRevokeKyc] SchedulableTransactionBody tokenRevokeKyc
         * @property {proto.ITokenDeleteTransactionBody|null} [tokenDeletion] SchedulableTransactionBody tokenDeletion
         * @property {proto.ITokenUpdateTransactionBody|null} [tokenUpdate] SchedulableTransactionBody tokenUpdate
         * @property {proto.ITokenMintTransactionBody|null} [tokenMint] SchedulableTransactionBody tokenMint
         * @property {proto.ITokenBurnTransactionBody|null} [tokenBurn] SchedulableTransactionBody tokenBurn
         * @property {proto.ITokenWipeAccountTransactionBody|null} [tokenWipe] SchedulableTransactionBody tokenWipe
         * @property {proto.ITokenAssociateTransactionBody|null} [tokenAssociate] SchedulableTransactionBody tokenAssociate
         * @property {proto.ITokenDissociateTransactionBody|null} [tokenDissociate] SchedulableTransactionBody tokenDissociate
         * @property {proto.IScheduleDeleteTransactionBody|null} [scheduleDelete] SchedulableTransactionBody scheduleDelete
         */

        /**
         * Constructs a new SchedulableTransactionBody.
         * @memberof proto
         * @classdesc Represents a SchedulableTransactionBody.
         * @implements ISchedulableTransactionBody
         * @constructor
         * @param {proto.ISchedulableTransactionBody=} [p] Properties to set
         */
        function SchedulableTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * SchedulableTransactionBody transactionFee.
         * @member {Long} transactionFee
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.transactionFee = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SchedulableTransactionBody memo.
         * @member {string} memo
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.memo = "";

        /**
         * SchedulableTransactionBody contractCall.
         * @member {proto.IContractCallTransactionBody|null|undefined} contractCall
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.contractCall = null;

        /**
         * SchedulableTransactionBody contractCreateInstance.
         * @member {proto.IContractCreateTransactionBody|null|undefined} contractCreateInstance
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.contractCreateInstance = null;

        /**
         * SchedulableTransactionBody contractUpdateInstance.
         * @member {proto.IContractUpdateTransactionBody|null|undefined} contractUpdateInstance
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.contractUpdateInstance = null;

        /**
         * SchedulableTransactionBody contractDeleteInstance.
         * @member {proto.IContractDeleteTransactionBody|null|undefined} contractDeleteInstance
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.contractDeleteInstance = null;

        /**
         * SchedulableTransactionBody cryptoCreateAccount.
         * @member {proto.ICryptoCreateTransactionBody|null|undefined} cryptoCreateAccount
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.cryptoCreateAccount = null;

        /**
         * SchedulableTransactionBody cryptoDelete.
         * @member {proto.ICryptoDeleteTransactionBody|null|undefined} cryptoDelete
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.cryptoDelete = null;

        /**
         * SchedulableTransactionBody cryptoTransfer.
         * @member {proto.ICryptoTransferTransactionBody|null|undefined} cryptoTransfer
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.cryptoTransfer = null;

        /**
         * SchedulableTransactionBody cryptoUpdateAccount.
         * @member {proto.ICryptoUpdateTransactionBody|null|undefined} cryptoUpdateAccount
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.cryptoUpdateAccount = null;

        /**
         * SchedulableTransactionBody fileAppend.
         * @member {proto.IFileAppendTransactionBody|null|undefined} fileAppend
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.fileAppend = null;

        /**
         * SchedulableTransactionBody fileCreate.
         * @member {proto.IFileCreateTransactionBody|null|undefined} fileCreate
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.fileCreate = null;

        /**
         * SchedulableTransactionBody fileDelete.
         * @member {proto.IFileDeleteTransactionBody|null|undefined} fileDelete
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.fileDelete = null;

        /**
         * SchedulableTransactionBody fileUpdate.
         * @member {proto.IFileUpdateTransactionBody|null|undefined} fileUpdate
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.fileUpdate = null;

        /**
         * SchedulableTransactionBody systemDelete.
         * @member {proto.ISystemDeleteTransactionBody|null|undefined} systemDelete
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.systemDelete = null;

        /**
         * SchedulableTransactionBody systemUndelete.
         * @member {proto.ISystemUndeleteTransactionBody|null|undefined} systemUndelete
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.systemUndelete = null;

        /**
         * SchedulableTransactionBody freeze.
         * @member {proto.IFreezeTransactionBody|null|undefined} freeze
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.freeze = null;

        /**
         * SchedulableTransactionBody consensusCreateTopic.
         * @member {proto.IConsensusCreateTopicTransactionBody|null|undefined} consensusCreateTopic
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.consensusCreateTopic = null;

        /**
         * SchedulableTransactionBody consensusUpdateTopic.
         * @member {proto.IConsensusUpdateTopicTransactionBody|null|undefined} consensusUpdateTopic
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.consensusUpdateTopic = null;

        /**
         * SchedulableTransactionBody consensusDeleteTopic.
         * @member {proto.IConsensusDeleteTopicTransactionBody|null|undefined} consensusDeleteTopic
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.consensusDeleteTopic = null;

        /**
         * SchedulableTransactionBody consensusSubmitMessage.
         * @member {proto.IConsensusSubmitMessageTransactionBody|null|undefined} consensusSubmitMessage
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.consensusSubmitMessage = null;

        /**
         * SchedulableTransactionBody tokenCreation.
         * @member {proto.ITokenCreateTransactionBody|null|undefined} tokenCreation
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenCreation = null;

        /**
         * SchedulableTransactionBody tokenFreeze.
         * @member {proto.ITokenFreezeAccountTransactionBody|null|undefined} tokenFreeze
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenFreeze = null;

        /**
         * SchedulableTransactionBody tokenUnfreeze.
         * @member {proto.ITokenUnfreezeAccountTransactionBody|null|undefined} tokenUnfreeze
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenUnfreeze = null;

        /**
         * SchedulableTransactionBody tokenGrantKyc.
         * @member {proto.ITokenGrantKycTransactionBody|null|undefined} tokenGrantKyc
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenGrantKyc = null;

        /**
         * SchedulableTransactionBody tokenRevokeKyc.
         * @member {proto.ITokenRevokeKycTransactionBody|null|undefined} tokenRevokeKyc
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenRevokeKyc = null;

        /**
         * SchedulableTransactionBody tokenDeletion.
         * @member {proto.ITokenDeleteTransactionBody|null|undefined} tokenDeletion
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenDeletion = null;

        /**
         * SchedulableTransactionBody tokenUpdate.
         * @member {proto.ITokenUpdateTransactionBody|null|undefined} tokenUpdate
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenUpdate = null;

        /**
         * SchedulableTransactionBody tokenMint.
         * @member {proto.ITokenMintTransactionBody|null|undefined} tokenMint
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenMint = null;

        /**
         * SchedulableTransactionBody tokenBurn.
         * @member {proto.ITokenBurnTransactionBody|null|undefined} tokenBurn
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenBurn = null;

        /**
         * SchedulableTransactionBody tokenWipe.
         * @member {proto.ITokenWipeAccountTransactionBody|null|undefined} tokenWipe
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenWipe = null;

        /**
         * SchedulableTransactionBody tokenAssociate.
         * @member {proto.ITokenAssociateTransactionBody|null|undefined} tokenAssociate
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenAssociate = null;

        /**
         * SchedulableTransactionBody tokenDissociate.
         * @member {proto.ITokenDissociateTransactionBody|null|undefined} tokenDissociate
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.tokenDissociate = null;

        /**
         * SchedulableTransactionBody scheduleDelete.
         * @member {proto.IScheduleDeleteTransactionBody|null|undefined} scheduleDelete
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        SchedulableTransactionBody.prototype.scheduleDelete = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * SchedulableTransactionBody data.
         * @member {"contractCall"|"contractCreateInstance"|"contractUpdateInstance"|"contractDeleteInstance"|"cryptoCreateAccount"|"cryptoDelete"|"cryptoTransfer"|"cryptoUpdateAccount"|"fileAppend"|"fileCreate"|"fileDelete"|"fileUpdate"|"systemDelete"|"systemUndelete"|"freeze"|"consensusCreateTopic"|"consensusUpdateTopic"|"consensusDeleteTopic"|"consensusSubmitMessage"|"tokenCreation"|"tokenFreeze"|"tokenUnfreeze"|"tokenGrantKyc"|"tokenRevokeKyc"|"tokenDeletion"|"tokenUpdate"|"tokenMint"|"tokenBurn"|"tokenWipe"|"tokenAssociate"|"tokenDissociate"|"scheduleDelete"|undefined} data
         * @memberof proto.SchedulableTransactionBody
         * @instance
         */
        Object.defineProperty(SchedulableTransactionBody.prototype, "data", {
            get: $util.oneOfGetter($oneOfFields = ["contractCall", "contractCreateInstance", "contractUpdateInstance", "contractDeleteInstance", "cryptoCreateAccount", "cryptoDelete", "cryptoTransfer", "cryptoUpdateAccount", "fileAppend", "fileCreate", "fileDelete", "fileUpdate", "systemDelete", "systemUndelete", "freeze", "consensusCreateTopic", "consensusUpdateTopic", "consensusDeleteTopic", "consensusSubmitMessage", "tokenCreation", "tokenFreeze", "tokenUnfreeze", "tokenGrantKyc", "tokenRevokeKyc", "tokenDeletion", "tokenUpdate", "tokenMint", "tokenBurn", "tokenWipe", "tokenAssociate", "tokenDissociate", "scheduleDelete"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new SchedulableTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.SchedulableTransactionBody
         * @static
         * @param {proto.ISchedulableTransactionBody=} [properties] Properties to set
         * @returns {proto.SchedulableTransactionBody} SchedulableTransactionBody instance
         */
        SchedulableTransactionBody.create = function create(properties) {
            return new SchedulableTransactionBody(properties);
        };

        /**
         * Encodes the specified SchedulableTransactionBody message. Does not implicitly {@link proto.SchedulableTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.SchedulableTransactionBody
         * @static
         * @param {proto.ISchedulableTransactionBody} m SchedulableTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SchedulableTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.transactionFee != null && Object.hasOwnProperty.call(m, "transactionFee"))
                w.uint32(8).uint64(m.transactionFee);
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                w.uint32(18).string(m.memo);
            if (m.contractCall != null && Object.hasOwnProperty.call(m, "contractCall"))
                $root.proto.ContractCallTransactionBody.encode(m.contractCall, w.uint32(26).fork()).ldelim();
            if (m.contractCreateInstance != null && Object.hasOwnProperty.call(m, "contractCreateInstance"))
                $root.proto.ContractCreateTransactionBody.encode(m.contractCreateInstance, w.uint32(34).fork()).ldelim();
            if (m.contractUpdateInstance != null && Object.hasOwnProperty.call(m, "contractUpdateInstance"))
                $root.proto.ContractUpdateTransactionBody.encode(m.contractUpdateInstance, w.uint32(42).fork()).ldelim();
            if (m.contractDeleteInstance != null && Object.hasOwnProperty.call(m, "contractDeleteInstance"))
                $root.proto.ContractDeleteTransactionBody.encode(m.contractDeleteInstance, w.uint32(50).fork()).ldelim();
            if (m.cryptoCreateAccount != null && Object.hasOwnProperty.call(m, "cryptoCreateAccount"))
                $root.proto.CryptoCreateTransactionBody.encode(m.cryptoCreateAccount, w.uint32(58).fork()).ldelim();
            if (m.cryptoDelete != null && Object.hasOwnProperty.call(m, "cryptoDelete"))
                $root.proto.CryptoDeleteTransactionBody.encode(m.cryptoDelete, w.uint32(66).fork()).ldelim();
            if (m.cryptoTransfer != null && Object.hasOwnProperty.call(m, "cryptoTransfer"))
                $root.proto.CryptoTransferTransactionBody.encode(m.cryptoTransfer, w.uint32(74).fork()).ldelim();
            if (m.cryptoUpdateAccount != null && Object.hasOwnProperty.call(m, "cryptoUpdateAccount"))
                $root.proto.CryptoUpdateTransactionBody.encode(m.cryptoUpdateAccount, w.uint32(82).fork()).ldelim();
            if (m.fileAppend != null && Object.hasOwnProperty.call(m, "fileAppend"))
                $root.proto.FileAppendTransactionBody.encode(m.fileAppend, w.uint32(90).fork()).ldelim();
            if (m.fileCreate != null && Object.hasOwnProperty.call(m, "fileCreate"))
                $root.proto.FileCreateTransactionBody.encode(m.fileCreate, w.uint32(98).fork()).ldelim();
            if (m.fileDelete != null && Object.hasOwnProperty.call(m, "fileDelete"))
                $root.proto.FileDeleteTransactionBody.encode(m.fileDelete, w.uint32(106).fork()).ldelim();
            if (m.fileUpdate != null && Object.hasOwnProperty.call(m, "fileUpdate"))
                $root.proto.FileUpdateTransactionBody.encode(m.fileUpdate, w.uint32(114).fork()).ldelim();
            if (m.systemDelete != null && Object.hasOwnProperty.call(m, "systemDelete"))
                $root.proto.SystemDeleteTransactionBody.encode(m.systemDelete, w.uint32(122).fork()).ldelim();
            if (m.systemUndelete != null && Object.hasOwnProperty.call(m, "systemUndelete"))
                $root.proto.SystemUndeleteTransactionBody.encode(m.systemUndelete, w.uint32(130).fork()).ldelim();
            if (m.freeze != null && Object.hasOwnProperty.call(m, "freeze"))
                $root.proto.FreezeTransactionBody.encode(m.freeze, w.uint32(138).fork()).ldelim();
            if (m.consensusCreateTopic != null && Object.hasOwnProperty.call(m, "consensusCreateTopic"))
                $root.proto.ConsensusCreateTopicTransactionBody.encode(m.consensusCreateTopic, w.uint32(146).fork()).ldelim();
            if (m.consensusUpdateTopic != null && Object.hasOwnProperty.call(m, "consensusUpdateTopic"))
                $root.proto.ConsensusUpdateTopicTransactionBody.encode(m.consensusUpdateTopic, w.uint32(154).fork()).ldelim();
            if (m.consensusDeleteTopic != null && Object.hasOwnProperty.call(m, "consensusDeleteTopic"))
                $root.proto.ConsensusDeleteTopicTransactionBody.encode(m.consensusDeleteTopic, w.uint32(162).fork()).ldelim();
            if (m.consensusSubmitMessage != null && Object.hasOwnProperty.call(m, "consensusSubmitMessage"))
                $root.proto.ConsensusSubmitMessageTransactionBody.encode(m.consensusSubmitMessage, w.uint32(170).fork()).ldelim();
            if (m.tokenCreation != null && Object.hasOwnProperty.call(m, "tokenCreation"))
                $root.proto.TokenCreateTransactionBody.encode(m.tokenCreation, w.uint32(178).fork()).ldelim();
            if (m.tokenFreeze != null && Object.hasOwnProperty.call(m, "tokenFreeze"))
                $root.proto.TokenFreezeAccountTransactionBody.encode(m.tokenFreeze, w.uint32(186).fork()).ldelim();
            if (m.tokenUnfreeze != null && Object.hasOwnProperty.call(m, "tokenUnfreeze"))
                $root.proto.TokenUnfreezeAccountTransactionBody.encode(m.tokenUnfreeze, w.uint32(194).fork()).ldelim();
            if (m.tokenGrantKyc != null && Object.hasOwnProperty.call(m, "tokenGrantKyc"))
                $root.proto.TokenGrantKycTransactionBody.encode(m.tokenGrantKyc, w.uint32(202).fork()).ldelim();
            if (m.tokenRevokeKyc != null && Object.hasOwnProperty.call(m, "tokenRevokeKyc"))
                $root.proto.TokenRevokeKycTransactionBody.encode(m.tokenRevokeKyc, w.uint32(210).fork()).ldelim();
            if (m.tokenDeletion != null && Object.hasOwnProperty.call(m, "tokenDeletion"))
                $root.proto.TokenDeleteTransactionBody.encode(m.tokenDeletion, w.uint32(218).fork()).ldelim();
            if (m.tokenUpdate != null && Object.hasOwnProperty.call(m, "tokenUpdate"))
                $root.proto.TokenUpdateTransactionBody.encode(m.tokenUpdate, w.uint32(226).fork()).ldelim();
            if (m.tokenMint != null && Object.hasOwnProperty.call(m, "tokenMint"))
                $root.proto.TokenMintTransactionBody.encode(m.tokenMint, w.uint32(234).fork()).ldelim();
            if (m.tokenBurn != null && Object.hasOwnProperty.call(m, "tokenBurn"))
                $root.proto.TokenBurnTransactionBody.encode(m.tokenBurn, w.uint32(242).fork()).ldelim();
            if (m.tokenWipe != null && Object.hasOwnProperty.call(m, "tokenWipe"))
                $root.proto.TokenWipeAccountTransactionBody.encode(m.tokenWipe, w.uint32(250).fork()).ldelim();
            if (m.tokenAssociate != null && Object.hasOwnProperty.call(m, "tokenAssociate"))
                $root.proto.TokenAssociateTransactionBody.encode(m.tokenAssociate, w.uint32(258).fork()).ldelim();
            if (m.tokenDissociate != null && Object.hasOwnProperty.call(m, "tokenDissociate"))
                $root.proto.TokenDissociateTransactionBody.encode(m.tokenDissociate, w.uint32(266).fork()).ldelim();
            if (m.scheduleDelete != null && Object.hasOwnProperty.call(m, "scheduleDelete"))
                $root.proto.ScheduleDeleteTransactionBody.encode(m.scheduleDelete, w.uint32(274).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a SchedulableTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SchedulableTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.SchedulableTransactionBody} SchedulableTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SchedulableTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.SchedulableTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.transactionFee = r.uint64();
                    break;
                case 2:
                    m.memo = r.string();
                    break;
                case 3:
                    m.contractCall = $root.proto.ContractCallTransactionBody.decode(r, r.uint32());
                    break;
                case 4:
                    m.contractCreateInstance = $root.proto.ContractCreateTransactionBody.decode(r, r.uint32());
                    break;
                case 5:
                    m.contractUpdateInstance = $root.proto.ContractUpdateTransactionBody.decode(r, r.uint32());
                    break;
                case 6:
                    m.contractDeleteInstance = $root.proto.ContractDeleteTransactionBody.decode(r, r.uint32());
                    break;
                case 7:
                    m.cryptoCreateAccount = $root.proto.CryptoCreateTransactionBody.decode(r, r.uint32());
                    break;
                case 8:
                    m.cryptoDelete = $root.proto.CryptoDeleteTransactionBody.decode(r, r.uint32());
                    break;
                case 9:
                    m.cryptoTransfer = $root.proto.CryptoTransferTransactionBody.decode(r, r.uint32());
                    break;
                case 10:
                    m.cryptoUpdateAccount = $root.proto.CryptoUpdateTransactionBody.decode(r, r.uint32());
                    break;
                case 11:
                    m.fileAppend = $root.proto.FileAppendTransactionBody.decode(r, r.uint32());
                    break;
                case 12:
                    m.fileCreate = $root.proto.FileCreateTransactionBody.decode(r, r.uint32());
                    break;
                case 13:
                    m.fileDelete = $root.proto.FileDeleteTransactionBody.decode(r, r.uint32());
                    break;
                case 14:
                    m.fileUpdate = $root.proto.FileUpdateTransactionBody.decode(r, r.uint32());
                    break;
                case 15:
                    m.systemDelete = $root.proto.SystemDeleteTransactionBody.decode(r, r.uint32());
                    break;
                case 16:
                    m.systemUndelete = $root.proto.SystemUndeleteTransactionBody.decode(r, r.uint32());
                    break;
                case 17:
                    m.freeze = $root.proto.FreezeTransactionBody.decode(r, r.uint32());
                    break;
                case 18:
                    m.consensusCreateTopic = $root.proto.ConsensusCreateTopicTransactionBody.decode(r, r.uint32());
                    break;
                case 19:
                    m.consensusUpdateTopic = $root.proto.ConsensusUpdateTopicTransactionBody.decode(r, r.uint32());
                    break;
                case 20:
                    m.consensusDeleteTopic = $root.proto.ConsensusDeleteTopicTransactionBody.decode(r, r.uint32());
                    break;
                case 21:
                    m.consensusSubmitMessage = $root.proto.ConsensusSubmitMessageTransactionBody.decode(r, r.uint32());
                    break;
                case 22:
                    m.tokenCreation = $root.proto.TokenCreateTransactionBody.decode(r, r.uint32());
                    break;
                case 23:
                    m.tokenFreeze = $root.proto.TokenFreezeAccountTransactionBody.decode(r, r.uint32());
                    break;
                case 24:
                    m.tokenUnfreeze = $root.proto.TokenUnfreezeAccountTransactionBody.decode(r, r.uint32());
                    break;
                case 25:
                    m.tokenGrantKyc = $root.proto.TokenGrantKycTransactionBody.decode(r, r.uint32());
                    break;
                case 26:
                    m.tokenRevokeKyc = $root.proto.TokenRevokeKycTransactionBody.decode(r, r.uint32());
                    break;
                case 27:
                    m.tokenDeletion = $root.proto.TokenDeleteTransactionBody.decode(r, r.uint32());
                    break;
                case 28:
                    m.tokenUpdate = $root.proto.TokenUpdateTransactionBody.decode(r, r.uint32());
                    break;
                case 29:
                    m.tokenMint = $root.proto.TokenMintTransactionBody.decode(r, r.uint32());
                    break;
                case 30:
                    m.tokenBurn = $root.proto.TokenBurnTransactionBody.decode(r, r.uint32());
                    break;
                case 31:
                    m.tokenWipe = $root.proto.TokenWipeAccountTransactionBody.decode(r, r.uint32());
                    break;
                case 32:
                    m.tokenAssociate = $root.proto.TokenAssociateTransactionBody.decode(r, r.uint32());
                    break;
                case 33:
                    m.tokenDissociate = $root.proto.TokenDissociateTransactionBody.decode(r, r.uint32());
                    break;
                case 34:
                    m.scheduleDelete = $root.proto.ScheduleDeleteTransactionBody.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return SchedulableTransactionBody;
    })();

    proto.ScheduleDeleteTransactionBody = (function() {

        /**
         * Properties of a ScheduleDeleteTransactionBody.
         * @memberof proto
         * @interface IScheduleDeleteTransactionBody
         * @property {proto.IScheduleID|null} [scheduleID] ScheduleDeleteTransactionBody scheduleID
         */

        /**
         * Constructs a new ScheduleDeleteTransactionBody.
         * @memberof proto
         * @classdesc Represents a ScheduleDeleteTransactionBody.
         * @implements IScheduleDeleteTransactionBody
         * @constructor
         * @param {proto.IScheduleDeleteTransactionBody=} [p] Properties to set
         */
        function ScheduleDeleteTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ScheduleDeleteTransactionBody scheduleID.
         * @member {proto.IScheduleID|null|undefined} scheduleID
         * @memberof proto.ScheduleDeleteTransactionBody
         * @instance
         */
        ScheduleDeleteTransactionBody.prototype.scheduleID = null;

        /**
         * Creates a new ScheduleDeleteTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.ScheduleDeleteTransactionBody
         * @static
         * @param {proto.IScheduleDeleteTransactionBody=} [properties] Properties to set
         * @returns {proto.ScheduleDeleteTransactionBody} ScheduleDeleteTransactionBody instance
         */
        ScheduleDeleteTransactionBody.create = function create(properties) {
            return new ScheduleDeleteTransactionBody(properties);
        };

        /**
         * Encodes the specified ScheduleDeleteTransactionBody message. Does not implicitly {@link proto.ScheduleDeleteTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.ScheduleDeleteTransactionBody
         * @static
         * @param {proto.IScheduleDeleteTransactionBody} m ScheduleDeleteTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScheduleDeleteTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.scheduleID != null && Object.hasOwnProperty.call(m, "scheduleID"))
                $root.proto.ScheduleID.encode(m.scheduleID, w.uint32(10).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ScheduleDeleteTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ScheduleDeleteTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ScheduleDeleteTransactionBody} ScheduleDeleteTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScheduleDeleteTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ScheduleDeleteTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.scheduleID = $root.proto.ScheduleID.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ScheduleDeleteTransactionBody;
    })();

    proto.ScheduleSignTransactionBody = (function() {

        /**
         * Properties of a ScheduleSignTransactionBody.
         * @memberof proto
         * @interface IScheduleSignTransactionBody
         * @property {proto.IScheduleID|null} [scheduleID] ScheduleSignTransactionBody scheduleID
         */

        /**
         * Constructs a new ScheduleSignTransactionBody.
         * @memberof proto
         * @classdesc Represents a ScheduleSignTransactionBody.
         * @implements IScheduleSignTransactionBody
         * @constructor
         * @param {proto.IScheduleSignTransactionBody=} [p] Properties to set
         */
        function ScheduleSignTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ScheduleSignTransactionBody scheduleID.
         * @member {proto.IScheduleID|null|undefined} scheduleID
         * @memberof proto.ScheduleSignTransactionBody
         * @instance
         */
        ScheduleSignTransactionBody.prototype.scheduleID = null;

        /**
         * Creates a new ScheduleSignTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.ScheduleSignTransactionBody
         * @static
         * @param {proto.IScheduleSignTransactionBody=} [properties] Properties to set
         * @returns {proto.ScheduleSignTransactionBody} ScheduleSignTransactionBody instance
         */
        ScheduleSignTransactionBody.create = function create(properties) {
            return new ScheduleSignTransactionBody(properties);
        };

        /**
         * Encodes the specified ScheduleSignTransactionBody message. Does not implicitly {@link proto.ScheduleSignTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.ScheduleSignTransactionBody
         * @static
         * @param {proto.IScheduleSignTransactionBody} m ScheduleSignTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScheduleSignTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.scheduleID != null && Object.hasOwnProperty.call(m, "scheduleID"))
                $root.proto.ScheduleID.encode(m.scheduleID, w.uint32(10).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ScheduleSignTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ScheduleSignTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ScheduleSignTransactionBody} ScheduleSignTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScheduleSignTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ScheduleSignTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.scheduleID = $root.proto.ScheduleID.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ScheduleSignTransactionBody;
    })();

    proto.ResponseHeader = (function() {

        /**
         * Properties of a ResponseHeader.
         * @memberof proto
         * @interface IResponseHeader
         * @property {proto.ResponseCodeEnum|null} [nodeTransactionPrecheckCode] ResponseHeader nodeTransactionPrecheckCode
         * @property {proto.ResponseType|null} [responseType] ResponseHeader responseType
         * @property {Long|null} [cost] ResponseHeader cost
         * @property {Uint8Array|null} [stateProof] ResponseHeader stateProof
         */

        /**
         * Constructs a new ResponseHeader.
         * @memberof proto
         * @classdesc Represents a ResponseHeader.
         * @implements IResponseHeader
         * @constructor
         * @param {proto.IResponseHeader=} [p] Properties to set
         */
        function ResponseHeader(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ResponseHeader nodeTransactionPrecheckCode.
         * @member {proto.ResponseCodeEnum} nodeTransactionPrecheckCode
         * @memberof proto.ResponseHeader
         * @instance
         */
        ResponseHeader.prototype.nodeTransactionPrecheckCode = 0;

        /**
         * ResponseHeader responseType.
         * @member {proto.ResponseType} responseType
         * @memberof proto.ResponseHeader
         * @instance
         */
        ResponseHeader.prototype.responseType = 0;

        /**
         * ResponseHeader cost.
         * @member {Long} cost
         * @memberof proto.ResponseHeader
         * @instance
         */
        ResponseHeader.prototype.cost = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ResponseHeader stateProof.
         * @member {Uint8Array} stateProof
         * @memberof proto.ResponseHeader
         * @instance
         */
        ResponseHeader.prototype.stateProof = $util.newBuffer([]);

        /**
         * Creates a new ResponseHeader instance using the specified properties.
         * @function create
         * @memberof proto.ResponseHeader
         * @static
         * @param {proto.IResponseHeader=} [properties] Properties to set
         * @returns {proto.ResponseHeader} ResponseHeader instance
         */
        ResponseHeader.create = function create(properties) {
            return new ResponseHeader(properties);
        };

        /**
         * Encodes the specified ResponseHeader message. Does not implicitly {@link proto.ResponseHeader.verify|verify} messages.
         * @function encode
         * @memberof proto.ResponseHeader
         * @static
         * @param {proto.IResponseHeader} m ResponseHeader message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResponseHeader.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.nodeTransactionPrecheckCode != null && Object.hasOwnProperty.call(m, "nodeTransactionPrecheckCode"))
                w.uint32(8).int32(m.nodeTransactionPrecheckCode);
            if (m.responseType != null && Object.hasOwnProperty.call(m, "responseType"))
                w.uint32(16).int32(m.responseType);
            if (m.cost != null && Object.hasOwnProperty.call(m, "cost"))
                w.uint32(24).uint64(m.cost);
            if (m.stateProof != null && Object.hasOwnProperty.call(m, "stateProof"))
                w.uint32(34).bytes(m.stateProof);
            return w;
        };

        /**
         * Decodes a ResponseHeader message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ResponseHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ResponseHeader} ResponseHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseHeader.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ResponseHeader();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.nodeTransactionPrecheckCode = r.int32();
                    break;
                case 2:
                    m.responseType = r.int32();
                    break;
                case 3:
                    m.cost = r.uint64();
                    break;
                case 4:
                    m.stateProof = r.bytes();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ResponseHeader;
    })();

    proto.TransactionResponse = (function() {

        /**
         * Properties of a TransactionResponse.
         * @memberof proto
         * @interface ITransactionResponse
         * @property {proto.ResponseCodeEnum|null} [nodeTransactionPrecheckCode] TransactionResponse nodeTransactionPrecheckCode
         * @property {Long|null} [cost] TransactionResponse cost
         */

        /**
         * Constructs a new TransactionResponse.
         * @memberof proto
         * @classdesc Represents a TransactionResponse.
         * @implements ITransactionResponse
         * @constructor
         * @param {proto.ITransactionResponse=} [p] Properties to set
         */
        function TransactionResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TransactionResponse nodeTransactionPrecheckCode.
         * @member {proto.ResponseCodeEnum} nodeTransactionPrecheckCode
         * @memberof proto.TransactionResponse
         * @instance
         */
        TransactionResponse.prototype.nodeTransactionPrecheckCode = 0;

        /**
         * TransactionResponse cost.
         * @member {Long} cost
         * @memberof proto.TransactionResponse
         * @instance
         */
        TransactionResponse.prototype.cost = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new TransactionResponse instance using the specified properties.
         * @function create
         * @memberof proto.TransactionResponse
         * @static
         * @param {proto.ITransactionResponse=} [properties] Properties to set
         * @returns {proto.TransactionResponse} TransactionResponse instance
         */
        TransactionResponse.create = function create(properties) {
            return new TransactionResponse(properties);
        };

        /**
         * Encodes the specified TransactionResponse message. Does not implicitly {@link proto.TransactionResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionResponse
         * @static
         * @param {proto.ITransactionResponse} m TransactionResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.nodeTransactionPrecheckCode != null && Object.hasOwnProperty.call(m, "nodeTransactionPrecheckCode"))
                w.uint32(8).int32(m.nodeTransactionPrecheckCode);
            if (m.cost != null && Object.hasOwnProperty.call(m, "cost"))
                w.uint32(16).uint64(m.cost);
            return w;
        };

        /**
         * Decodes a TransactionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionResponse} TransactionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TransactionResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.nodeTransactionPrecheckCode = r.int32();
                    break;
                case 2:
                    m.cost = r.uint64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TransactionResponse;
    })();

    /**
     * ResponseCodeEnum enum.
     * @name proto.ResponseCodeEnum
     * @enum {number}
     * @property {number} OK=0 OK value
     * @property {number} INVALID_TRANSACTION=1 INVALID_TRANSACTION value
     * @property {number} PAYER_ACCOUNT_NOT_FOUND=2 PAYER_ACCOUNT_NOT_FOUND value
     * @property {number} INVALID_NODE_ACCOUNT=3 INVALID_NODE_ACCOUNT value
     * @property {number} TRANSACTION_EXPIRED=4 TRANSACTION_EXPIRED value
     * @property {number} INVALID_TRANSACTION_START=5 INVALID_TRANSACTION_START value
     * @property {number} INVALID_TRANSACTION_DURATION=6 INVALID_TRANSACTION_DURATION value
     * @property {number} INVALID_SIGNATURE=7 INVALID_SIGNATURE value
     * @property {number} MEMO_TOO_LONG=8 MEMO_TOO_LONG value
     * @property {number} INSUFFICIENT_TX_FEE=9 INSUFFICIENT_TX_FEE value
     * @property {number} INSUFFICIENT_PAYER_BALANCE=10 INSUFFICIENT_PAYER_BALANCE value
     * @property {number} DUPLICATE_TRANSACTION=11 DUPLICATE_TRANSACTION value
     * @property {number} BUSY=12 BUSY value
     * @property {number} NOT_SUPPORTED=13 NOT_SUPPORTED value
     * @property {number} INVALID_FILE_ID=14 INVALID_FILE_ID value
     * @property {number} INVALID_ACCOUNT_ID=15 INVALID_ACCOUNT_ID value
     * @property {number} INVALID_CONTRACT_ID=16 INVALID_CONTRACT_ID value
     * @property {number} INVALID_TRANSACTION_ID=17 INVALID_TRANSACTION_ID value
     * @property {number} RECEIPT_NOT_FOUND=18 RECEIPT_NOT_FOUND value
     * @property {number} RECORD_NOT_FOUND=19 RECORD_NOT_FOUND value
     * @property {number} INVALID_SOLIDITY_ID=20 INVALID_SOLIDITY_ID value
     * @property {number} UNKNOWN=21 UNKNOWN value
     * @property {number} SUCCESS=22 SUCCESS value
     * @property {number} FAIL_INVALID=23 FAIL_INVALID value
     * @property {number} FAIL_FEE=24 FAIL_FEE value
     * @property {number} FAIL_BALANCE=25 FAIL_BALANCE value
     * @property {number} KEY_REQUIRED=26 KEY_REQUIRED value
     * @property {number} BAD_ENCODING=27 BAD_ENCODING value
     * @property {number} INSUFFICIENT_ACCOUNT_BALANCE=28 INSUFFICIENT_ACCOUNT_BALANCE value
     * @property {number} INVALID_SOLIDITY_ADDRESS=29 INVALID_SOLIDITY_ADDRESS value
     * @property {number} INSUFFICIENT_GAS=30 INSUFFICIENT_GAS value
     * @property {number} CONTRACT_SIZE_LIMIT_EXCEEDED=31 CONTRACT_SIZE_LIMIT_EXCEEDED value
     * @property {number} LOCAL_CALL_MODIFICATION_EXCEPTION=32 LOCAL_CALL_MODIFICATION_EXCEPTION value
     * @property {number} CONTRACT_REVERT_EXECUTED=33 CONTRACT_REVERT_EXECUTED value
     * @property {number} CONTRACT_EXECUTION_EXCEPTION=34 CONTRACT_EXECUTION_EXCEPTION value
     * @property {number} INVALID_RECEIVING_NODE_ACCOUNT=35 INVALID_RECEIVING_NODE_ACCOUNT value
     * @property {number} MISSING_QUERY_HEADER=36 MISSING_QUERY_HEADER value
     * @property {number} ACCOUNT_UPDATE_FAILED=37 ACCOUNT_UPDATE_FAILED value
     * @property {number} INVALID_KEY_ENCODING=38 INVALID_KEY_ENCODING value
     * @property {number} NULL_SOLIDITY_ADDRESS=39 NULL_SOLIDITY_ADDRESS value
     * @property {number} CONTRACT_UPDATE_FAILED=40 CONTRACT_UPDATE_FAILED value
     * @property {number} INVALID_QUERY_HEADER=41 INVALID_QUERY_HEADER value
     * @property {number} INVALID_FEE_SUBMITTED=42 INVALID_FEE_SUBMITTED value
     * @property {number} INVALID_PAYER_SIGNATURE=43 INVALID_PAYER_SIGNATURE value
     * @property {number} KEY_NOT_PROVIDED=44 KEY_NOT_PROVIDED value
     * @property {number} INVALID_EXPIRATION_TIME=45 INVALID_EXPIRATION_TIME value
     * @property {number} NO_WACL_KEY=46 NO_WACL_KEY value
     * @property {number} FILE_CONTENT_EMPTY=47 FILE_CONTENT_EMPTY value
     * @property {number} INVALID_ACCOUNT_AMOUNTS=48 INVALID_ACCOUNT_AMOUNTS value
     * @property {number} EMPTY_TRANSACTION_BODY=49 EMPTY_TRANSACTION_BODY value
     * @property {number} INVALID_TRANSACTION_BODY=50 INVALID_TRANSACTION_BODY value
     * @property {number} INVALID_SIGNATURE_TYPE_MISMATCHING_KEY=51 INVALID_SIGNATURE_TYPE_MISMATCHING_KEY value
     * @property {number} INVALID_SIGNATURE_COUNT_MISMATCHING_KEY=52 INVALID_SIGNATURE_COUNT_MISMATCHING_KEY value
     * @property {number} EMPTY_LIVE_HASH_BODY=53 EMPTY_LIVE_HASH_BODY value
     * @property {number} EMPTY_LIVE_HASH=54 EMPTY_LIVE_HASH value
     * @property {number} EMPTY_LIVE_HASH_KEYS=55 EMPTY_LIVE_HASH_KEYS value
     * @property {number} INVALID_LIVE_HASH_SIZE=56 INVALID_LIVE_HASH_SIZE value
     * @property {number} EMPTY_QUERY_BODY=57 EMPTY_QUERY_BODY value
     * @property {number} EMPTY_LIVE_HASH_QUERY=58 EMPTY_LIVE_HASH_QUERY value
     * @property {number} LIVE_HASH_NOT_FOUND=59 LIVE_HASH_NOT_FOUND value
     * @property {number} ACCOUNT_ID_DOES_NOT_EXIST=60 ACCOUNT_ID_DOES_NOT_EXIST value
     * @property {number} LIVE_HASH_ALREADY_EXISTS=61 LIVE_HASH_ALREADY_EXISTS value
     * @property {number} INVALID_FILE_WACL=62 INVALID_FILE_WACL value
     * @property {number} SERIALIZATION_FAILED=63 SERIALIZATION_FAILED value
     * @property {number} TRANSACTION_OVERSIZE=64 TRANSACTION_OVERSIZE value
     * @property {number} TRANSACTION_TOO_MANY_LAYERS=65 TRANSACTION_TOO_MANY_LAYERS value
     * @property {number} CONTRACT_DELETED=66 CONTRACT_DELETED value
     * @property {number} PLATFORM_NOT_ACTIVE=67 PLATFORM_NOT_ACTIVE value
     * @property {number} KEY_PREFIX_MISMATCH=68 KEY_PREFIX_MISMATCH value
     * @property {number} PLATFORM_TRANSACTION_NOT_CREATED=69 PLATFORM_TRANSACTION_NOT_CREATED value
     * @property {number} INVALID_RENEWAL_PERIOD=70 INVALID_RENEWAL_PERIOD value
     * @property {number} INVALID_PAYER_ACCOUNT_ID=71 INVALID_PAYER_ACCOUNT_ID value
     * @property {number} ACCOUNT_DELETED=72 ACCOUNT_DELETED value
     * @property {number} FILE_DELETED=73 FILE_DELETED value
     * @property {number} ACCOUNT_REPEATED_IN_ACCOUNT_AMOUNTS=74 ACCOUNT_REPEATED_IN_ACCOUNT_AMOUNTS value
     * @property {number} SETTING_NEGATIVE_ACCOUNT_BALANCE=75 SETTING_NEGATIVE_ACCOUNT_BALANCE value
     * @property {number} OBTAINER_REQUIRED=76 OBTAINER_REQUIRED value
     * @property {number} OBTAINER_SAME_CONTRACT_ID=77 OBTAINER_SAME_CONTRACT_ID value
     * @property {number} OBTAINER_DOES_NOT_EXIST=78 OBTAINER_DOES_NOT_EXIST value
     * @property {number} MODIFYING_IMMUTABLE_CONTRACT=79 MODIFYING_IMMUTABLE_CONTRACT value
     * @property {number} FILE_SYSTEM_EXCEPTION=80 FILE_SYSTEM_EXCEPTION value
     * @property {number} AUTORENEW_DURATION_NOT_IN_RANGE=81 AUTORENEW_DURATION_NOT_IN_RANGE value
     * @property {number} ERROR_DECODING_BYTESTRING=82 ERROR_DECODING_BYTESTRING value
     * @property {number} CONTRACT_FILE_EMPTY=83 CONTRACT_FILE_EMPTY value
     * @property {number} CONTRACT_BYTECODE_EMPTY=84 CONTRACT_BYTECODE_EMPTY value
     * @property {number} INVALID_INITIAL_BALANCE=85 INVALID_INITIAL_BALANCE value
     * @property {number} INVALID_RECEIVE_RECORD_THRESHOLD=86 INVALID_RECEIVE_RECORD_THRESHOLD value
     * @property {number} INVALID_SEND_RECORD_THRESHOLD=87 INVALID_SEND_RECORD_THRESHOLD value
     * @property {number} ACCOUNT_IS_NOT_GENESIS_ACCOUNT=88 ACCOUNT_IS_NOT_GENESIS_ACCOUNT value
     * @property {number} PAYER_ACCOUNT_UNAUTHORIZED=89 PAYER_ACCOUNT_UNAUTHORIZED value
     * @property {number} INVALID_FREEZE_TRANSACTION_BODY=90 INVALID_FREEZE_TRANSACTION_BODY value
     * @property {number} FREEZE_TRANSACTION_BODY_NOT_FOUND=91 FREEZE_TRANSACTION_BODY_NOT_FOUND value
     * @property {number} TRANSFER_LIST_SIZE_LIMIT_EXCEEDED=92 TRANSFER_LIST_SIZE_LIMIT_EXCEEDED value
     * @property {number} RESULT_SIZE_LIMIT_EXCEEDED=93 RESULT_SIZE_LIMIT_EXCEEDED value
     * @property {number} NOT_SPECIAL_ACCOUNT=94 NOT_SPECIAL_ACCOUNT value
     * @property {number} CONTRACT_NEGATIVE_GAS=95 CONTRACT_NEGATIVE_GAS value
     * @property {number} CONTRACT_NEGATIVE_VALUE=96 CONTRACT_NEGATIVE_VALUE value
     * @property {number} INVALID_FEE_FILE=97 INVALID_FEE_FILE value
     * @property {number} INVALID_EXCHANGE_RATE_FILE=98 INVALID_EXCHANGE_RATE_FILE value
     * @property {number} INSUFFICIENT_LOCAL_CALL_GAS=99 INSUFFICIENT_LOCAL_CALL_GAS value
     * @property {number} ENTITY_NOT_ALLOWED_TO_DELETE=100 ENTITY_NOT_ALLOWED_TO_DELETE value
     * @property {number} AUTHORIZATION_FAILED=101 AUTHORIZATION_FAILED value
     * @property {number} FILE_UPLOADED_PROTO_INVALID=102 FILE_UPLOADED_PROTO_INVALID value
     * @property {number} FILE_UPLOADED_PROTO_NOT_SAVED_TO_DISK=103 FILE_UPLOADED_PROTO_NOT_SAVED_TO_DISK value
     * @property {number} FEE_SCHEDULE_FILE_PART_UPLOADED=104 FEE_SCHEDULE_FILE_PART_UPLOADED value
     * @property {number} EXCHANGE_RATE_CHANGE_LIMIT_EXCEEDED=105 EXCHANGE_RATE_CHANGE_LIMIT_EXCEEDED value
     * @property {number} MAX_CONTRACT_STORAGE_EXCEEDED=106 MAX_CONTRACT_STORAGE_EXCEEDED value
     * @property {number} TRANSFER_ACCOUNT_SAME_AS_DELETE_ACCOUNT=107 TRANSFER_ACCOUNT_SAME_AS_DELETE_ACCOUNT value
     * @property {number} TOTAL_LEDGER_BALANCE_INVALID=108 TOTAL_LEDGER_BALANCE_INVALID value
     * @property {number} EXPIRATION_REDUCTION_NOT_ALLOWED=110 EXPIRATION_REDUCTION_NOT_ALLOWED value
     * @property {number} MAX_GAS_LIMIT_EXCEEDED=111 MAX_GAS_LIMIT_EXCEEDED value
     * @property {number} MAX_FILE_SIZE_EXCEEDED=112 MAX_FILE_SIZE_EXCEEDED value
     * @property {number} RECEIVER_SIG_REQUIRED=113 RECEIVER_SIG_REQUIRED value
     * @property {number} INVALID_TOPIC_ID=150 INVALID_TOPIC_ID value
     * @property {number} INVALID_ADMIN_KEY=155 INVALID_ADMIN_KEY value
     * @property {number} INVALID_SUBMIT_KEY=156 INVALID_SUBMIT_KEY value
     * @property {number} UNAUTHORIZED=157 UNAUTHORIZED value
     * @property {number} INVALID_TOPIC_MESSAGE=158 INVALID_TOPIC_MESSAGE value
     * @property {number} INVALID_AUTORENEW_ACCOUNT=159 INVALID_AUTORENEW_ACCOUNT value
     * @property {number} AUTORENEW_ACCOUNT_NOT_ALLOWED=160 AUTORENEW_ACCOUNT_NOT_ALLOWED value
     * @property {number} TOPIC_EXPIRED=162 TOPIC_EXPIRED value
     * @property {number} INVALID_CHUNK_NUMBER=163 INVALID_CHUNK_NUMBER value
     * @property {number} INVALID_CHUNK_TRANSACTION_ID=164 INVALID_CHUNK_TRANSACTION_ID value
     * @property {number} ACCOUNT_FROZEN_FOR_TOKEN=165 ACCOUNT_FROZEN_FOR_TOKEN value
     * @property {number} TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED=166 TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED value
     * @property {number} INVALID_TOKEN_ID=167 INVALID_TOKEN_ID value
     * @property {number} INVALID_TOKEN_DECIMALS=168 INVALID_TOKEN_DECIMALS value
     * @property {number} INVALID_TOKEN_INITIAL_SUPPLY=169 INVALID_TOKEN_INITIAL_SUPPLY value
     * @property {number} INVALID_TREASURY_ACCOUNT_FOR_TOKEN=170 INVALID_TREASURY_ACCOUNT_FOR_TOKEN value
     * @property {number} INVALID_TOKEN_SYMBOL=171 INVALID_TOKEN_SYMBOL value
     * @property {number} TOKEN_HAS_NO_FREEZE_KEY=172 TOKEN_HAS_NO_FREEZE_KEY value
     * @property {number} TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN=173 TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN value
     * @property {number} MISSING_TOKEN_SYMBOL=174 MISSING_TOKEN_SYMBOL value
     * @property {number} TOKEN_SYMBOL_TOO_LONG=175 TOKEN_SYMBOL_TOO_LONG value
     * @property {number} ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN=176 ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN value
     * @property {number} TOKEN_HAS_NO_KYC_KEY=177 TOKEN_HAS_NO_KYC_KEY value
     * @property {number} INSUFFICIENT_TOKEN_BALANCE=178 INSUFFICIENT_TOKEN_BALANCE value
     * @property {number} TOKEN_WAS_DELETED=179 TOKEN_WAS_DELETED value
     * @property {number} TOKEN_HAS_NO_SUPPLY_KEY=180 TOKEN_HAS_NO_SUPPLY_KEY value
     * @property {number} TOKEN_HAS_NO_WIPE_KEY=181 TOKEN_HAS_NO_WIPE_KEY value
     * @property {number} INVALID_TOKEN_MINT_AMOUNT=182 INVALID_TOKEN_MINT_AMOUNT value
     * @property {number} INVALID_TOKEN_BURN_AMOUNT=183 INVALID_TOKEN_BURN_AMOUNT value
     * @property {number} TOKEN_NOT_ASSOCIATED_TO_ACCOUNT=184 TOKEN_NOT_ASSOCIATED_TO_ACCOUNT value
     * @property {number} CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT=185 CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT value
     * @property {number} INVALID_KYC_KEY=186 INVALID_KYC_KEY value
     * @property {number} INVALID_WIPE_KEY=187 INVALID_WIPE_KEY value
     * @property {number} INVALID_FREEZE_KEY=188 INVALID_FREEZE_KEY value
     * @property {number} INVALID_SUPPLY_KEY=189 INVALID_SUPPLY_KEY value
     * @property {number} MISSING_TOKEN_NAME=190 MISSING_TOKEN_NAME value
     * @property {number} TOKEN_NAME_TOO_LONG=191 TOKEN_NAME_TOO_LONG value
     * @property {number} INVALID_WIPING_AMOUNT=192 INVALID_WIPING_AMOUNT value
     * @property {number} TOKEN_IS_IMMUTABLE=193 TOKEN_IS_IMMUTABLE value
     * @property {number} TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT=194 TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT value
     * @property {number} TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES=195 TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES value
     * @property {number} ACCOUNT_IS_TREASURY=196 ACCOUNT_IS_TREASURY value
     * @property {number} TOKEN_ID_REPEATED_IN_TOKEN_LIST=197 TOKEN_ID_REPEATED_IN_TOKEN_LIST value
     * @property {number} TOKEN_TRANSFER_LIST_SIZE_LIMIT_EXCEEDED=198 TOKEN_TRANSFER_LIST_SIZE_LIMIT_EXCEEDED value
     * @property {number} EMPTY_TOKEN_TRANSFER_BODY=199 EMPTY_TOKEN_TRANSFER_BODY value
     * @property {number} EMPTY_TOKEN_TRANSFER_ACCOUNT_AMOUNTS=200 EMPTY_TOKEN_TRANSFER_ACCOUNT_AMOUNTS value
     * @property {number} INVALID_SCHEDULE_ID=201 INVALID_SCHEDULE_ID value
     * @property {number} SCHEDULE_IS_IMMUTABLE=202 SCHEDULE_IS_IMMUTABLE value
     * @property {number} INVALID_SCHEDULE_PAYER_ID=203 INVALID_SCHEDULE_PAYER_ID value
     * @property {number} INVALID_SCHEDULE_ACCOUNT_ID=204 INVALID_SCHEDULE_ACCOUNT_ID value
     * @property {number} NO_NEW_VALID_SIGNATURES=205 NO_NEW_VALID_SIGNATURES value
     * @property {number} UNRESOLVABLE_REQUIRED_SIGNERS=206 UNRESOLVABLE_REQUIRED_SIGNERS value
     * @property {number} SCHEDULED_TRANSACTION_NOT_IN_WHITELIST=207 SCHEDULED_TRANSACTION_NOT_IN_WHITELIST value
     * @property {number} SOME_SIGNATURES_WERE_INVALID=208 SOME_SIGNATURES_WERE_INVALID value
     * @property {number} TRANSACTION_ID_FIELD_NOT_ALLOWED=209 TRANSACTION_ID_FIELD_NOT_ALLOWED value
     * @property {number} IDENTICAL_SCHEDULE_ALREADY_CREATED=210 IDENTICAL_SCHEDULE_ALREADY_CREATED value
     * @property {number} INVALID_ZERO_BYTE_IN_STRING=211 INVALID_ZERO_BYTE_IN_STRING value
     * @property {number} SCHEDULE_ALREADY_DELETED=212 SCHEDULE_ALREADY_DELETED value
     * @property {number} SCHEDULE_ALREADY_EXECUTED=213 SCHEDULE_ALREADY_EXECUTED value
     * @property {number} MESSAGE_SIZE_TOO_LARGE=214 MESSAGE_SIZE_TOO_LARGE value
     * @property {number} OPERATION_REPEATED_IN_BUCKET_GROUPS=215 OPERATION_REPEATED_IN_BUCKET_GROUPS value
     * @property {number} BUCKET_CAPACITY_OVERFLOW=216 BUCKET_CAPACITY_OVERFLOW value
     * @property {number} NODE_CAPACITY_NOT_SUFFICIENT_FOR_OPERATION=217 NODE_CAPACITY_NOT_SUFFICIENT_FOR_OPERATION value
     * @property {number} BUCKET_HAS_NO_THROTTLE_GROUPS=218 BUCKET_HAS_NO_THROTTLE_GROUPS value
     * @property {number} THROTTLE_GROUP_HAS_ZERO_OPS_PER_SEC=219 THROTTLE_GROUP_HAS_ZERO_OPS_PER_SEC value
     * @property {number} SUCCESS_BUT_MISSING_EXPECTED_OPERATION=220 SUCCESS_BUT_MISSING_EXPECTED_OPERATION value
     * @property {number} UNPARSEABLE_THROTTLE_DEFINITIONS=221 UNPARSEABLE_THROTTLE_DEFINITIONS value
     * @property {number} INVALID_THROTTLE_DEFINITIONS=222 INVALID_THROTTLE_DEFINITIONS value
     * @property {number} ACCOUNT_EXPIRED_AND_PENDING_REMOVAL=223 ACCOUNT_EXPIRED_AND_PENDING_REMOVAL value
     * @property {number} INVALID_TOKEN_MAX_SUPPLY=224 INVALID_TOKEN_MAX_SUPPLY value
     * @property {number} INVALID_TOKEN_NFT_SERIAL_NUMBER=225 INVALID_TOKEN_NFT_SERIAL_NUMBER value
     * @property {number} INVALID_NFT_ID=226 INVALID_NFT_ID value
     * @property {number} METADATA_TOO_LONG=227 METADATA_TOO_LONG value
     * @property {number} BATCH_SIZE_LIMIT_EXCEEDED=228 BATCH_SIZE_LIMIT_EXCEEDED value
     * @property {number} INVALID_QUERY_RANGE=229 INVALID_QUERY_RANGE value
     * @property {number} FRACTION_DIVIDES_BY_ZERO=230 FRACTION_DIVIDES_BY_ZERO value
     * @property {number} INSUFFICIENT_PAYER_BALANCE_FOR_CUSTOM_FEE=231 INSUFFICIENT_PAYER_BALANCE_FOR_CUSTOM_FEE value
     * @property {number} CUSTOM_FEES_LIST_TOO_LONG=232 CUSTOM_FEES_LIST_TOO_LONG value
     * @property {number} INVALID_CUSTOM_FEE_COLLECTOR=233 INVALID_CUSTOM_FEE_COLLECTOR value
     * @property {number} INVALID_TOKEN_ID_IN_CUSTOM_FEES=234 INVALID_TOKEN_ID_IN_CUSTOM_FEES value
     * @property {number} TOKEN_NOT_ASSOCIATED_TO_FEE_COLLECTOR=235 TOKEN_NOT_ASSOCIATED_TO_FEE_COLLECTOR value
     * @property {number} TOKEN_MAX_SUPPLY_REACHED=236 TOKEN_MAX_SUPPLY_REACHED value
     * @property {number} SENDER_DOES_NOT_OWN_NFT_SERIAL_NO=237 SENDER_DOES_NOT_OWN_NFT_SERIAL_NO value
     * @property {number} CUSTOM_FEE_NOT_FULLY_SPECIFIED=238 CUSTOM_FEE_NOT_FULLY_SPECIFIED value
     * @property {number} CUSTOM_FEE_MUST_BE_POSITIVE=239 CUSTOM_FEE_MUST_BE_POSITIVE value
     * @property {number} TOKEN_HAS_NO_FEE_SCHEDULE_KEY=240 TOKEN_HAS_NO_FEE_SCHEDULE_KEY value
     * @property {number} CUSTOM_FEE_OUTSIDE_NUMERIC_RANGE=241 CUSTOM_FEE_OUTSIDE_NUMERIC_RANGE value
     * @property {number} INVALID_CUSTOM_FRACTIONAL_FEES_SUM=242 INVALID_CUSTOM_FRACTIONAL_FEES_SUM value
     * @property {number} FRACTIONAL_FEE_MAX_AMOUNT_LESS_THAN_MIN_AMOUNT=243 FRACTIONAL_FEE_MAX_AMOUNT_LESS_THAN_MIN_AMOUNT value
     * @property {number} CUSTOM_SCHEDULE_ALREADY_HAS_NO_FEES=244 CUSTOM_SCHEDULE_ALREADY_HAS_NO_FEES value
     * @property {number} CUSTOM_FEE_DENOMINATION_MUST_BE_FUNGIBLE_COMMON=245 CUSTOM_FEE_DENOMINATION_MUST_BE_FUNGIBLE_COMMON value
     * @property {number} CUSTOM_FRACTIONAL_FEE_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON=246 CUSTOM_FRACTIONAL_FEE_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON value
     * @property {number} INVALID_CUSTOM_FEE_SCHEDULE_KEY=247 INVALID_CUSTOM_FEE_SCHEDULE_KEY value
     * @property {number} INVALID_TOKEN_MINT_METADATA=248 INVALID_TOKEN_MINT_METADATA value
     * @property {number} INVALID_TOKEN_BURN_METADATA=249 INVALID_TOKEN_BURN_METADATA value
     * @property {number} CURRENT_TREASURY_STILL_OWNS_NFTS=250 CURRENT_TREASURY_STILL_OWNS_NFTS value
     * @property {number} ACCOUNT_STILL_OWNS_NFTS=251 ACCOUNT_STILL_OWNS_NFTS value
     * @property {number} TREASURY_MUST_OWN_BURNED_NFT=252 TREASURY_MUST_OWN_BURNED_NFT value
     * @property {number} ACCOUNT_DOES_NOT_OWN_WIPED_NFT=253 ACCOUNT_DOES_NOT_OWN_WIPED_NFT value
     * @property {number} ACCOUNT_AMOUNT_TRANSFERS_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON=254 ACCOUNT_AMOUNT_TRANSFERS_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON value
     * @property {number} MAX_NFTS_IN_PRICE_REGIME_HAVE_BEEN_MINTED=255 MAX_NFTS_IN_PRICE_REGIME_HAVE_BEEN_MINTED value
     * @property {number} PAYER_ACCOUNT_DELETED=256 PAYER_ACCOUNT_DELETED value
     * @property {number} CUSTOM_FEE_CHARGING_EXCEEDED_MAX_RECURSION_DEPTH=257 CUSTOM_FEE_CHARGING_EXCEEDED_MAX_RECURSION_DEPTH value
     * @property {number} CUSTOM_FEE_CHARGING_EXCEEDED_MAX_ACCOUNT_AMOUNTS=258 CUSTOM_FEE_CHARGING_EXCEEDED_MAX_ACCOUNT_AMOUNTS value
     * @property {number} INSUFFICIENT_SENDER_ACCOUNT_BALANCE_FOR_CUSTOM_FEE=259 INSUFFICIENT_SENDER_ACCOUNT_BALANCE_FOR_CUSTOM_FEE value
     */
    proto.ResponseCodeEnum = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "OK"] = 0;
        values[valuesById[1] = "INVALID_TRANSACTION"] = 1;
        values[valuesById[2] = "PAYER_ACCOUNT_NOT_FOUND"] = 2;
        values[valuesById[3] = "INVALID_NODE_ACCOUNT"] = 3;
        values[valuesById[4] = "TRANSACTION_EXPIRED"] = 4;
        values[valuesById[5] = "INVALID_TRANSACTION_START"] = 5;
        values[valuesById[6] = "INVALID_TRANSACTION_DURATION"] = 6;
        values[valuesById[7] = "INVALID_SIGNATURE"] = 7;
        values[valuesById[8] = "MEMO_TOO_LONG"] = 8;
        values[valuesById[9] = "INSUFFICIENT_TX_FEE"] = 9;
        values[valuesById[10] = "INSUFFICIENT_PAYER_BALANCE"] = 10;
        values[valuesById[11] = "DUPLICATE_TRANSACTION"] = 11;
        values[valuesById[12] = "BUSY"] = 12;
        values[valuesById[13] = "NOT_SUPPORTED"] = 13;
        values[valuesById[14] = "INVALID_FILE_ID"] = 14;
        values[valuesById[15] = "INVALID_ACCOUNT_ID"] = 15;
        values[valuesById[16] = "INVALID_CONTRACT_ID"] = 16;
        values[valuesById[17] = "INVALID_TRANSACTION_ID"] = 17;
        values[valuesById[18] = "RECEIPT_NOT_FOUND"] = 18;
        values[valuesById[19] = "RECORD_NOT_FOUND"] = 19;
        values[valuesById[20] = "INVALID_SOLIDITY_ID"] = 20;
        values[valuesById[21] = "UNKNOWN"] = 21;
        values[valuesById[22] = "SUCCESS"] = 22;
        values[valuesById[23] = "FAIL_INVALID"] = 23;
        values[valuesById[24] = "FAIL_FEE"] = 24;
        values[valuesById[25] = "FAIL_BALANCE"] = 25;
        values[valuesById[26] = "KEY_REQUIRED"] = 26;
        values[valuesById[27] = "BAD_ENCODING"] = 27;
        values[valuesById[28] = "INSUFFICIENT_ACCOUNT_BALANCE"] = 28;
        values[valuesById[29] = "INVALID_SOLIDITY_ADDRESS"] = 29;
        values[valuesById[30] = "INSUFFICIENT_GAS"] = 30;
        values[valuesById[31] = "CONTRACT_SIZE_LIMIT_EXCEEDED"] = 31;
        values[valuesById[32] = "LOCAL_CALL_MODIFICATION_EXCEPTION"] = 32;
        values[valuesById[33] = "CONTRACT_REVERT_EXECUTED"] = 33;
        values[valuesById[34] = "CONTRACT_EXECUTION_EXCEPTION"] = 34;
        values[valuesById[35] = "INVALID_RECEIVING_NODE_ACCOUNT"] = 35;
        values[valuesById[36] = "MISSING_QUERY_HEADER"] = 36;
        values[valuesById[37] = "ACCOUNT_UPDATE_FAILED"] = 37;
        values[valuesById[38] = "INVALID_KEY_ENCODING"] = 38;
        values[valuesById[39] = "NULL_SOLIDITY_ADDRESS"] = 39;
        values[valuesById[40] = "CONTRACT_UPDATE_FAILED"] = 40;
        values[valuesById[41] = "INVALID_QUERY_HEADER"] = 41;
        values[valuesById[42] = "INVALID_FEE_SUBMITTED"] = 42;
        values[valuesById[43] = "INVALID_PAYER_SIGNATURE"] = 43;
        values[valuesById[44] = "KEY_NOT_PROVIDED"] = 44;
        values[valuesById[45] = "INVALID_EXPIRATION_TIME"] = 45;
        values[valuesById[46] = "NO_WACL_KEY"] = 46;
        values[valuesById[47] = "FILE_CONTENT_EMPTY"] = 47;
        values[valuesById[48] = "INVALID_ACCOUNT_AMOUNTS"] = 48;
        values[valuesById[49] = "EMPTY_TRANSACTION_BODY"] = 49;
        values[valuesById[50] = "INVALID_TRANSACTION_BODY"] = 50;
        values[valuesById[51] = "INVALID_SIGNATURE_TYPE_MISMATCHING_KEY"] = 51;
        values[valuesById[52] = "INVALID_SIGNATURE_COUNT_MISMATCHING_KEY"] = 52;
        values[valuesById[53] = "EMPTY_LIVE_HASH_BODY"] = 53;
        values[valuesById[54] = "EMPTY_LIVE_HASH"] = 54;
        values[valuesById[55] = "EMPTY_LIVE_HASH_KEYS"] = 55;
        values[valuesById[56] = "INVALID_LIVE_HASH_SIZE"] = 56;
        values[valuesById[57] = "EMPTY_QUERY_BODY"] = 57;
        values[valuesById[58] = "EMPTY_LIVE_HASH_QUERY"] = 58;
        values[valuesById[59] = "LIVE_HASH_NOT_FOUND"] = 59;
        values[valuesById[60] = "ACCOUNT_ID_DOES_NOT_EXIST"] = 60;
        values[valuesById[61] = "LIVE_HASH_ALREADY_EXISTS"] = 61;
        values[valuesById[62] = "INVALID_FILE_WACL"] = 62;
        values[valuesById[63] = "SERIALIZATION_FAILED"] = 63;
        values[valuesById[64] = "TRANSACTION_OVERSIZE"] = 64;
        values[valuesById[65] = "TRANSACTION_TOO_MANY_LAYERS"] = 65;
        values[valuesById[66] = "CONTRACT_DELETED"] = 66;
        values[valuesById[67] = "PLATFORM_NOT_ACTIVE"] = 67;
        values[valuesById[68] = "KEY_PREFIX_MISMATCH"] = 68;
        values[valuesById[69] = "PLATFORM_TRANSACTION_NOT_CREATED"] = 69;
        values[valuesById[70] = "INVALID_RENEWAL_PERIOD"] = 70;
        values[valuesById[71] = "INVALID_PAYER_ACCOUNT_ID"] = 71;
        values[valuesById[72] = "ACCOUNT_DELETED"] = 72;
        values[valuesById[73] = "FILE_DELETED"] = 73;
        values[valuesById[74] = "ACCOUNT_REPEATED_IN_ACCOUNT_AMOUNTS"] = 74;
        values[valuesById[75] = "SETTING_NEGATIVE_ACCOUNT_BALANCE"] = 75;
        values[valuesById[76] = "OBTAINER_REQUIRED"] = 76;
        values[valuesById[77] = "OBTAINER_SAME_CONTRACT_ID"] = 77;
        values[valuesById[78] = "OBTAINER_DOES_NOT_EXIST"] = 78;
        values[valuesById[79] = "MODIFYING_IMMUTABLE_CONTRACT"] = 79;
        values[valuesById[80] = "FILE_SYSTEM_EXCEPTION"] = 80;
        values[valuesById[81] = "AUTORENEW_DURATION_NOT_IN_RANGE"] = 81;
        values[valuesById[82] = "ERROR_DECODING_BYTESTRING"] = 82;
        values[valuesById[83] = "CONTRACT_FILE_EMPTY"] = 83;
        values[valuesById[84] = "CONTRACT_BYTECODE_EMPTY"] = 84;
        values[valuesById[85] = "INVALID_INITIAL_BALANCE"] = 85;
        values[valuesById[86] = "INVALID_RECEIVE_RECORD_THRESHOLD"] = 86;
        values[valuesById[87] = "INVALID_SEND_RECORD_THRESHOLD"] = 87;
        values[valuesById[88] = "ACCOUNT_IS_NOT_GENESIS_ACCOUNT"] = 88;
        values[valuesById[89] = "PAYER_ACCOUNT_UNAUTHORIZED"] = 89;
        values[valuesById[90] = "INVALID_FREEZE_TRANSACTION_BODY"] = 90;
        values[valuesById[91] = "FREEZE_TRANSACTION_BODY_NOT_FOUND"] = 91;
        values[valuesById[92] = "TRANSFER_LIST_SIZE_LIMIT_EXCEEDED"] = 92;
        values[valuesById[93] = "RESULT_SIZE_LIMIT_EXCEEDED"] = 93;
        values[valuesById[94] = "NOT_SPECIAL_ACCOUNT"] = 94;
        values[valuesById[95] = "CONTRACT_NEGATIVE_GAS"] = 95;
        values[valuesById[96] = "CONTRACT_NEGATIVE_VALUE"] = 96;
        values[valuesById[97] = "INVALID_FEE_FILE"] = 97;
        values[valuesById[98] = "INVALID_EXCHANGE_RATE_FILE"] = 98;
        values[valuesById[99] = "INSUFFICIENT_LOCAL_CALL_GAS"] = 99;
        values[valuesById[100] = "ENTITY_NOT_ALLOWED_TO_DELETE"] = 100;
        values[valuesById[101] = "AUTHORIZATION_FAILED"] = 101;
        values[valuesById[102] = "FILE_UPLOADED_PROTO_INVALID"] = 102;
        values[valuesById[103] = "FILE_UPLOADED_PROTO_NOT_SAVED_TO_DISK"] = 103;
        values[valuesById[104] = "FEE_SCHEDULE_FILE_PART_UPLOADED"] = 104;
        values[valuesById[105] = "EXCHANGE_RATE_CHANGE_LIMIT_EXCEEDED"] = 105;
        values[valuesById[106] = "MAX_CONTRACT_STORAGE_EXCEEDED"] = 106;
        values[valuesById[107] = "TRANSFER_ACCOUNT_SAME_AS_DELETE_ACCOUNT"] = 107;
        values[valuesById[108] = "TOTAL_LEDGER_BALANCE_INVALID"] = 108;
        values[valuesById[110] = "EXPIRATION_REDUCTION_NOT_ALLOWED"] = 110;
        values[valuesById[111] = "MAX_GAS_LIMIT_EXCEEDED"] = 111;
        values[valuesById[112] = "MAX_FILE_SIZE_EXCEEDED"] = 112;
        values[valuesById[113] = "RECEIVER_SIG_REQUIRED"] = 113;
        values[valuesById[150] = "INVALID_TOPIC_ID"] = 150;
        values[valuesById[155] = "INVALID_ADMIN_KEY"] = 155;
        values[valuesById[156] = "INVALID_SUBMIT_KEY"] = 156;
        values[valuesById[157] = "UNAUTHORIZED"] = 157;
        values[valuesById[158] = "INVALID_TOPIC_MESSAGE"] = 158;
        values[valuesById[159] = "INVALID_AUTORENEW_ACCOUNT"] = 159;
        values[valuesById[160] = "AUTORENEW_ACCOUNT_NOT_ALLOWED"] = 160;
        values[valuesById[162] = "TOPIC_EXPIRED"] = 162;
        values[valuesById[163] = "INVALID_CHUNK_NUMBER"] = 163;
        values[valuesById[164] = "INVALID_CHUNK_TRANSACTION_ID"] = 164;
        values[valuesById[165] = "ACCOUNT_FROZEN_FOR_TOKEN"] = 165;
        values[valuesById[166] = "TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED"] = 166;
        values[valuesById[167] = "INVALID_TOKEN_ID"] = 167;
        values[valuesById[168] = "INVALID_TOKEN_DECIMALS"] = 168;
        values[valuesById[169] = "INVALID_TOKEN_INITIAL_SUPPLY"] = 169;
        values[valuesById[170] = "INVALID_TREASURY_ACCOUNT_FOR_TOKEN"] = 170;
        values[valuesById[171] = "INVALID_TOKEN_SYMBOL"] = 171;
        values[valuesById[172] = "TOKEN_HAS_NO_FREEZE_KEY"] = 172;
        values[valuesById[173] = "TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN"] = 173;
        values[valuesById[174] = "MISSING_TOKEN_SYMBOL"] = 174;
        values[valuesById[175] = "TOKEN_SYMBOL_TOO_LONG"] = 175;
        values[valuesById[176] = "ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN"] = 176;
        values[valuesById[177] = "TOKEN_HAS_NO_KYC_KEY"] = 177;
        values[valuesById[178] = "INSUFFICIENT_TOKEN_BALANCE"] = 178;
        values[valuesById[179] = "TOKEN_WAS_DELETED"] = 179;
        values[valuesById[180] = "TOKEN_HAS_NO_SUPPLY_KEY"] = 180;
        values[valuesById[181] = "TOKEN_HAS_NO_WIPE_KEY"] = 181;
        values[valuesById[182] = "INVALID_TOKEN_MINT_AMOUNT"] = 182;
        values[valuesById[183] = "INVALID_TOKEN_BURN_AMOUNT"] = 183;
        values[valuesById[184] = "TOKEN_NOT_ASSOCIATED_TO_ACCOUNT"] = 184;
        values[valuesById[185] = "CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT"] = 185;
        values[valuesById[186] = "INVALID_KYC_KEY"] = 186;
        values[valuesById[187] = "INVALID_WIPE_KEY"] = 187;
        values[valuesById[188] = "INVALID_FREEZE_KEY"] = 188;
        values[valuesById[189] = "INVALID_SUPPLY_KEY"] = 189;
        values[valuesById[190] = "MISSING_TOKEN_NAME"] = 190;
        values[valuesById[191] = "TOKEN_NAME_TOO_LONG"] = 191;
        values[valuesById[192] = "INVALID_WIPING_AMOUNT"] = 192;
        values[valuesById[193] = "TOKEN_IS_IMMUTABLE"] = 193;
        values[valuesById[194] = "TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT"] = 194;
        values[valuesById[195] = "TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES"] = 195;
        values[valuesById[196] = "ACCOUNT_IS_TREASURY"] = 196;
        values[valuesById[197] = "TOKEN_ID_REPEATED_IN_TOKEN_LIST"] = 197;
        values[valuesById[198] = "TOKEN_TRANSFER_LIST_SIZE_LIMIT_EXCEEDED"] = 198;
        values[valuesById[199] = "EMPTY_TOKEN_TRANSFER_BODY"] = 199;
        values[valuesById[200] = "EMPTY_TOKEN_TRANSFER_ACCOUNT_AMOUNTS"] = 200;
        values[valuesById[201] = "INVALID_SCHEDULE_ID"] = 201;
        values[valuesById[202] = "SCHEDULE_IS_IMMUTABLE"] = 202;
        values[valuesById[203] = "INVALID_SCHEDULE_PAYER_ID"] = 203;
        values[valuesById[204] = "INVALID_SCHEDULE_ACCOUNT_ID"] = 204;
        values[valuesById[205] = "NO_NEW_VALID_SIGNATURES"] = 205;
        values[valuesById[206] = "UNRESOLVABLE_REQUIRED_SIGNERS"] = 206;
        values[valuesById[207] = "SCHEDULED_TRANSACTION_NOT_IN_WHITELIST"] = 207;
        values[valuesById[208] = "SOME_SIGNATURES_WERE_INVALID"] = 208;
        values[valuesById[209] = "TRANSACTION_ID_FIELD_NOT_ALLOWED"] = 209;
        values[valuesById[210] = "IDENTICAL_SCHEDULE_ALREADY_CREATED"] = 210;
        values[valuesById[211] = "INVALID_ZERO_BYTE_IN_STRING"] = 211;
        values[valuesById[212] = "SCHEDULE_ALREADY_DELETED"] = 212;
        values[valuesById[213] = "SCHEDULE_ALREADY_EXECUTED"] = 213;
        values[valuesById[214] = "MESSAGE_SIZE_TOO_LARGE"] = 214;
        values[valuesById[215] = "OPERATION_REPEATED_IN_BUCKET_GROUPS"] = 215;
        values[valuesById[216] = "BUCKET_CAPACITY_OVERFLOW"] = 216;
        values[valuesById[217] = "NODE_CAPACITY_NOT_SUFFICIENT_FOR_OPERATION"] = 217;
        values[valuesById[218] = "BUCKET_HAS_NO_THROTTLE_GROUPS"] = 218;
        values[valuesById[219] = "THROTTLE_GROUP_HAS_ZERO_OPS_PER_SEC"] = 219;
        values[valuesById[220] = "SUCCESS_BUT_MISSING_EXPECTED_OPERATION"] = 220;
        values[valuesById[221] = "UNPARSEABLE_THROTTLE_DEFINITIONS"] = 221;
        values[valuesById[222] = "INVALID_THROTTLE_DEFINITIONS"] = 222;
        values[valuesById[223] = "ACCOUNT_EXPIRED_AND_PENDING_REMOVAL"] = 223;
        values[valuesById[224] = "INVALID_TOKEN_MAX_SUPPLY"] = 224;
        values[valuesById[225] = "INVALID_TOKEN_NFT_SERIAL_NUMBER"] = 225;
        values[valuesById[226] = "INVALID_NFT_ID"] = 226;
        values[valuesById[227] = "METADATA_TOO_LONG"] = 227;
        values[valuesById[228] = "BATCH_SIZE_LIMIT_EXCEEDED"] = 228;
        values[valuesById[229] = "INVALID_QUERY_RANGE"] = 229;
        values[valuesById[230] = "FRACTION_DIVIDES_BY_ZERO"] = 230;
        values[valuesById[231] = "INSUFFICIENT_PAYER_BALANCE_FOR_CUSTOM_FEE"] = 231;
        values[valuesById[232] = "CUSTOM_FEES_LIST_TOO_LONG"] = 232;
        values[valuesById[233] = "INVALID_CUSTOM_FEE_COLLECTOR"] = 233;
        values[valuesById[234] = "INVALID_TOKEN_ID_IN_CUSTOM_FEES"] = 234;
        values[valuesById[235] = "TOKEN_NOT_ASSOCIATED_TO_FEE_COLLECTOR"] = 235;
        values[valuesById[236] = "TOKEN_MAX_SUPPLY_REACHED"] = 236;
        values[valuesById[237] = "SENDER_DOES_NOT_OWN_NFT_SERIAL_NO"] = 237;
        values[valuesById[238] = "CUSTOM_FEE_NOT_FULLY_SPECIFIED"] = 238;
        values[valuesById[239] = "CUSTOM_FEE_MUST_BE_POSITIVE"] = 239;
        values[valuesById[240] = "TOKEN_HAS_NO_FEE_SCHEDULE_KEY"] = 240;
        values[valuesById[241] = "CUSTOM_FEE_OUTSIDE_NUMERIC_RANGE"] = 241;
        values[valuesById[242] = "INVALID_CUSTOM_FRACTIONAL_FEES_SUM"] = 242;
        values[valuesById[243] = "FRACTIONAL_FEE_MAX_AMOUNT_LESS_THAN_MIN_AMOUNT"] = 243;
        values[valuesById[244] = "CUSTOM_SCHEDULE_ALREADY_HAS_NO_FEES"] = 244;
        values[valuesById[245] = "CUSTOM_FEE_DENOMINATION_MUST_BE_FUNGIBLE_COMMON"] = 245;
        values[valuesById[246] = "CUSTOM_FRACTIONAL_FEE_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON"] = 246;
        values[valuesById[247] = "INVALID_CUSTOM_FEE_SCHEDULE_KEY"] = 247;
        values[valuesById[248] = "INVALID_TOKEN_MINT_METADATA"] = 248;
        values[valuesById[249] = "INVALID_TOKEN_BURN_METADATA"] = 249;
        values[valuesById[250] = "CURRENT_TREASURY_STILL_OWNS_NFTS"] = 250;
        values[valuesById[251] = "ACCOUNT_STILL_OWNS_NFTS"] = 251;
        values[valuesById[252] = "TREASURY_MUST_OWN_BURNED_NFT"] = 252;
        values[valuesById[253] = "ACCOUNT_DOES_NOT_OWN_WIPED_NFT"] = 253;
        values[valuesById[254] = "ACCOUNT_AMOUNT_TRANSFERS_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON"] = 254;
        values[valuesById[255] = "MAX_NFTS_IN_PRICE_REGIME_HAVE_BEEN_MINTED"] = 255;
        values[valuesById[256] = "PAYER_ACCOUNT_DELETED"] = 256;
        values[valuesById[257] = "CUSTOM_FEE_CHARGING_EXCEEDED_MAX_RECURSION_DEPTH"] = 257;
        values[valuesById[258] = "CUSTOM_FEE_CHARGING_EXCEEDED_MAX_ACCOUNT_AMOUNTS"] = 258;
        values[valuesById[259] = "INSUFFICIENT_SENDER_ACCOUNT_BALANCE_FOR_CUSTOM_FEE"] = 259;
        return values;
    })();

    proto.ConsensusTopicInfo = (function() {

        /**
         * Properties of a ConsensusTopicInfo.
         * @memberof proto
         * @interface IConsensusTopicInfo
         * @property {string|null} [memo] ConsensusTopicInfo memo
         * @property {Uint8Array|null} [runningHash] ConsensusTopicInfo runningHash
         * @property {Long|null} [sequenceNumber] ConsensusTopicInfo sequenceNumber
         * @property {proto.ITimestamp|null} [expirationTime] ConsensusTopicInfo expirationTime
         * @property {proto.IKey|null} [adminKey] ConsensusTopicInfo adminKey
         * @property {proto.IKey|null} [submitKey] ConsensusTopicInfo submitKey
         * @property {proto.IDuration|null} [autoRenewPeriod] ConsensusTopicInfo autoRenewPeriod
         * @property {proto.IAccountID|null} [autoRenewAccount] ConsensusTopicInfo autoRenewAccount
         */

        /**
         * Constructs a new ConsensusTopicInfo.
         * @memberof proto
         * @classdesc Represents a ConsensusTopicInfo.
         * @implements IConsensusTopicInfo
         * @constructor
         * @param {proto.IConsensusTopicInfo=} [p] Properties to set
         */
        function ConsensusTopicInfo(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ConsensusTopicInfo memo.
         * @member {string} memo
         * @memberof proto.ConsensusTopicInfo
         * @instance
         */
        ConsensusTopicInfo.prototype.memo = "";

        /**
         * ConsensusTopicInfo runningHash.
         * @member {Uint8Array} runningHash
         * @memberof proto.ConsensusTopicInfo
         * @instance
         */
        ConsensusTopicInfo.prototype.runningHash = $util.newBuffer([]);

        /**
         * ConsensusTopicInfo sequenceNumber.
         * @member {Long} sequenceNumber
         * @memberof proto.ConsensusTopicInfo
         * @instance
         */
        ConsensusTopicInfo.prototype.sequenceNumber = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ConsensusTopicInfo expirationTime.
         * @member {proto.ITimestamp|null|undefined} expirationTime
         * @memberof proto.ConsensusTopicInfo
         * @instance
         */
        ConsensusTopicInfo.prototype.expirationTime = null;

        /**
         * ConsensusTopicInfo adminKey.
         * @member {proto.IKey|null|undefined} adminKey
         * @memberof proto.ConsensusTopicInfo
         * @instance
         */
        ConsensusTopicInfo.prototype.adminKey = null;

        /**
         * ConsensusTopicInfo submitKey.
         * @member {proto.IKey|null|undefined} submitKey
         * @memberof proto.ConsensusTopicInfo
         * @instance
         */
        ConsensusTopicInfo.prototype.submitKey = null;

        /**
         * ConsensusTopicInfo autoRenewPeriod.
         * @member {proto.IDuration|null|undefined} autoRenewPeriod
         * @memberof proto.ConsensusTopicInfo
         * @instance
         */
        ConsensusTopicInfo.prototype.autoRenewPeriod = null;

        /**
         * ConsensusTopicInfo autoRenewAccount.
         * @member {proto.IAccountID|null|undefined} autoRenewAccount
         * @memberof proto.ConsensusTopicInfo
         * @instance
         */
        ConsensusTopicInfo.prototype.autoRenewAccount = null;

        /**
         * Creates a new ConsensusTopicInfo instance using the specified properties.
         * @function create
         * @memberof proto.ConsensusTopicInfo
         * @static
         * @param {proto.IConsensusTopicInfo=} [properties] Properties to set
         * @returns {proto.ConsensusTopicInfo} ConsensusTopicInfo instance
         */
        ConsensusTopicInfo.create = function create(properties) {
            return new ConsensusTopicInfo(properties);
        };

        /**
         * Encodes the specified ConsensusTopicInfo message. Does not implicitly {@link proto.ConsensusTopicInfo.verify|verify} messages.
         * @function encode
         * @memberof proto.ConsensusTopicInfo
         * @static
         * @param {proto.IConsensusTopicInfo} m ConsensusTopicInfo message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConsensusTopicInfo.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                w.uint32(10).string(m.memo);
            if (m.runningHash != null && Object.hasOwnProperty.call(m, "runningHash"))
                w.uint32(18).bytes(m.runningHash);
            if (m.sequenceNumber != null && Object.hasOwnProperty.call(m, "sequenceNumber"))
                w.uint32(24).uint64(m.sequenceNumber);
            if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                $root.proto.Timestamp.encode(m.expirationTime, w.uint32(34).fork()).ldelim();
            if (m.adminKey != null && Object.hasOwnProperty.call(m, "adminKey"))
                $root.proto.Key.encode(m.adminKey, w.uint32(42).fork()).ldelim();
            if (m.submitKey != null && Object.hasOwnProperty.call(m, "submitKey"))
                $root.proto.Key.encode(m.submitKey, w.uint32(50).fork()).ldelim();
            if (m.autoRenewPeriod != null && Object.hasOwnProperty.call(m, "autoRenewPeriod"))
                $root.proto.Duration.encode(m.autoRenewPeriod, w.uint32(58).fork()).ldelim();
            if (m.autoRenewAccount != null && Object.hasOwnProperty.call(m, "autoRenewAccount"))
                $root.proto.AccountID.encode(m.autoRenewAccount, w.uint32(66).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ConsensusTopicInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ConsensusTopicInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ConsensusTopicInfo} ConsensusTopicInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConsensusTopicInfo.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ConsensusTopicInfo();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.memo = r.string();
                    break;
                case 2:
                    m.runningHash = r.bytes();
                    break;
                case 3:
                    m.sequenceNumber = r.uint64();
                    break;
                case 4:
                    m.expirationTime = $root.proto.Timestamp.decode(r, r.uint32());
                    break;
                case 5:
                    m.adminKey = $root.proto.Key.decode(r, r.uint32());
                    break;
                case 6:
                    m.submitKey = $root.proto.Key.decode(r, r.uint32());
                    break;
                case 7:
                    m.autoRenewPeriod = $root.proto.Duration.decode(r, r.uint32());
                    break;
                case 8:
                    m.autoRenewAccount = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ConsensusTopicInfo;
    })();

    proto.ConsensusService = (function() {

        /**
         * Constructs a new ConsensusService service.
         * @memberof proto
         * @classdesc Represents a ConsensusService
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function ConsensusService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (ConsensusService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ConsensusService;

        /**
         * Creates new ConsensusService service using the specified rpc implementation.
         * @function create
         * @memberof proto.ConsensusService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {ConsensusService} RPC service. Useful where requests and/or responses are streamed.
         */
        ConsensusService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link proto.ConsensusService#createTopic}.
         * @memberof proto.ConsensusService
         * @typedef createTopicCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls createTopic.
         * @function createTopic
         * @memberof proto.ConsensusService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.ConsensusService.createTopicCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ConsensusService.prototype.createTopic = function createTopic(request, callback) {
            return this.rpcCall(createTopic, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "createTopic" });

        /**
         * Calls createTopic.
         * @function createTopic
         * @memberof proto.ConsensusService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.ConsensusService#updateTopic}.
         * @memberof proto.ConsensusService
         * @typedef updateTopicCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls updateTopic.
         * @function updateTopic
         * @memberof proto.ConsensusService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.ConsensusService.updateTopicCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ConsensusService.prototype.updateTopic = function updateTopic(request, callback) {
            return this.rpcCall(updateTopic, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "updateTopic" });

        /**
         * Calls updateTopic.
         * @function updateTopic
         * @memberof proto.ConsensusService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.ConsensusService#deleteTopic}.
         * @memberof proto.ConsensusService
         * @typedef deleteTopicCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls deleteTopic.
         * @function deleteTopic
         * @memberof proto.ConsensusService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.ConsensusService.deleteTopicCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ConsensusService.prototype.deleteTopic = function deleteTopic(request, callback) {
            return this.rpcCall(deleteTopic, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "deleteTopic" });

        /**
         * Calls deleteTopic.
         * @function deleteTopic
         * @memberof proto.ConsensusService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.ConsensusService#getTopicInfo}.
         * @memberof proto.ConsensusService
         * @typedef getTopicInfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Calls getTopicInfo.
         * @function getTopicInfo
         * @memberof proto.ConsensusService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.ConsensusService.getTopicInfoCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ConsensusService.prototype.getTopicInfo = function getTopicInfo(request, callback) {
            return this.rpcCall(getTopicInfo, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getTopicInfo" });

        /**
         * Calls getTopicInfo.
         * @function getTopicInfo
         * @memberof proto.ConsensusService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.ConsensusService#submitMessage}.
         * @memberof proto.ConsensusService
         * @typedef submitMessageCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls submitMessage.
         * @function submitMessage
         * @memberof proto.ConsensusService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.ConsensusService.submitMessageCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ConsensusService.prototype.submitMessage = function submitMessage(request, callback) {
            return this.rpcCall(submitMessage, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "submitMessage" });

        /**
         * Calls submitMessage.
         * @function submitMessage
         * @memberof proto.ConsensusService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        return ConsensusService;
    })();

    proto.Query = (function() {

        /**
         * Properties of a Query.
         * @memberof proto
         * @interface IQuery
         * @property {proto.IGetByKeyQuery|null} [getByKey] Query getByKey
         * @property {proto.IGetBySolidityIDQuery|null} [getBySolidityID] Query getBySolidityID
         * @property {proto.IContractCallLocalQuery|null} [contractCallLocal] Query contractCallLocal
         * @property {proto.IContractGetInfoQuery|null} [contractGetInfo] Query contractGetInfo
         * @property {proto.IContractGetBytecodeQuery|null} [contractGetBytecode] Query contractGetBytecode
         * @property {proto.IContractGetRecordsQuery|null} [ContractGetRecords] Query ContractGetRecords
         * @property {proto.ICryptoGetAccountBalanceQuery|null} [cryptogetAccountBalance] Query cryptogetAccountBalance
         * @property {proto.ICryptoGetAccountRecordsQuery|null} [cryptoGetAccountRecords] Query cryptoGetAccountRecords
         * @property {proto.ICryptoGetInfoQuery|null} [cryptoGetInfo] Query cryptoGetInfo
         * @property {proto.ICryptoGetLiveHashQuery|null} [cryptoGetLiveHash] Query cryptoGetLiveHash
         * @property {proto.ICryptoGetStakersQuery|null} [cryptoGetProxyStakers] Query cryptoGetProxyStakers
         * @property {proto.IFileGetContentsQuery|null} [fileGetContents] Query fileGetContents
         * @property {proto.IFileGetInfoQuery|null} [fileGetInfo] Query fileGetInfo
         * @property {proto.ITransactionGetReceiptQuery|null} [transactionGetReceipt] Query transactionGetReceipt
         * @property {proto.ITransactionGetRecordQuery|null} [transactionGetRecord] Query transactionGetRecord
         * @property {proto.ITransactionGetFastRecordQuery|null} [transactionGetFastRecord] Query transactionGetFastRecord
         * @property {proto.IConsensusGetTopicInfoQuery|null} [consensusGetTopicInfo] Query consensusGetTopicInfo
         * @property {proto.INetworkGetVersionInfoQuery|null} [networkGetVersionInfo] Query networkGetVersionInfo
         * @property {proto.ITokenGetInfoQuery|null} [tokenGetInfo] Query tokenGetInfo
         * @property {proto.IScheduleGetInfoQuery|null} [scheduleGetInfo] Query scheduleGetInfo
         * @property {proto.ITokenGetAccountNftInfosQuery|null} [tokenGetAccountNftInfos] Query tokenGetAccountNftInfos
         * @property {proto.ITokenGetNftInfoQuery|null} [tokenGetNftInfo] Query tokenGetNftInfo
         * @property {proto.ITokenGetNftInfosQuery|null} [tokenGetNftInfos] Query tokenGetNftInfos
         */

        /**
         * Constructs a new Query.
         * @memberof proto
         * @classdesc Represents a Query.
         * @implements IQuery
         * @constructor
         * @param {proto.IQuery=} [p] Properties to set
         */
        function Query(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Query getByKey.
         * @member {proto.IGetByKeyQuery|null|undefined} getByKey
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.getByKey = null;

        /**
         * Query getBySolidityID.
         * @member {proto.IGetBySolidityIDQuery|null|undefined} getBySolidityID
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.getBySolidityID = null;

        /**
         * Query contractCallLocal.
         * @member {proto.IContractCallLocalQuery|null|undefined} contractCallLocal
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.contractCallLocal = null;

        /**
         * Query contractGetInfo.
         * @member {proto.IContractGetInfoQuery|null|undefined} contractGetInfo
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.contractGetInfo = null;

        /**
         * Query contractGetBytecode.
         * @member {proto.IContractGetBytecodeQuery|null|undefined} contractGetBytecode
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.contractGetBytecode = null;

        /**
         * Query ContractGetRecords.
         * @member {proto.IContractGetRecordsQuery|null|undefined} ContractGetRecords
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.ContractGetRecords = null;

        /**
         * Query cryptogetAccountBalance.
         * @member {proto.ICryptoGetAccountBalanceQuery|null|undefined} cryptogetAccountBalance
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.cryptogetAccountBalance = null;

        /**
         * Query cryptoGetAccountRecords.
         * @member {proto.ICryptoGetAccountRecordsQuery|null|undefined} cryptoGetAccountRecords
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.cryptoGetAccountRecords = null;

        /**
         * Query cryptoGetInfo.
         * @member {proto.ICryptoGetInfoQuery|null|undefined} cryptoGetInfo
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.cryptoGetInfo = null;

        /**
         * Query cryptoGetLiveHash.
         * @member {proto.ICryptoGetLiveHashQuery|null|undefined} cryptoGetLiveHash
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.cryptoGetLiveHash = null;

        /**
         * Query cryptoGetProxyStakers.
         * @member {proto.ICryptoGetStakersQuery|null|undefined} cryptoGetProxyStakers
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.cryptoGetProxyStakers = null;

        /**
         * Query fileGetContents.
         * @member {proto.IFileGetContentsQuery|null|undefined} fileGetContents
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.fileGetContents = null;

        /**
         * Query fileGetInfo.
         * @member {proto.IFileGetInfoQuery|null|undefined} fileGetInfo
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.fileGetInfo = null;

        /**
         * Query transactionGetReceipt.
         * @member {proto.ITransactionGetReceiptQuery|null|undefined} transactionGetReceipt
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.transactionGetReceipt = null;

        /**
         * Query transactionGetRecord.
         * @member {proto.ITransactionGetRecordQuery|null|undefined} transactionGetRecord
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.transactionGetRecord = null;

        /**
         * Query transactionGetFastRecord.
         * @member {proto.ITransactionGetFastRecordQuery|null|undefined} transactionGetFastRecord
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.transactionGetFastRecord = null;

        /**
         * Query consensusGetTopicInfo.
         * @member {proto.IConsensusGetTopicInfoQuery|null|undefined} consensusGetTopicInfo
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.consensusGetTopicInfo = null;

        /**
         * Query networkGetVersionInfo.
         * @member {proto.INetworkGetVersionInfoQuery|null|undefined} networkGetVersionInfo
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.networkGetVersionInfo = null;

        /**
         * Query tokenGetInfo.
         * @member {proto.ITokenGetInfoQuery|null|undefined} tokenGetInfo
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.tokenGetInfo = null;

        /**
         * Query scheduleGetInfo.
         * @member {proto.IScheduleGetInfoQuery|null|undefined} scheduleGetInfo
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.scheduleGetInfo = null;

        /**
         * Query tokenGetAccountNftInfos.
         * @member {proto.ITokenGetAccountNftInfosQuery|null|undefined} tokenGetAccountNftInfos
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.tokenGetAccountNftInfos = null;

        /**
         * Query tokenGetNftInfo.
         * @member {proto.ITokenGetNftInfoQuery|null|undefined} tokenGetNftInfo
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.tokenGetNftInfo = null;

        /**
         * Query tokenGetNftInfos.
         * @member {proto.ITokenGetNftInfosQuery|null|undefined} tokenGetNftInfos
         * @memberof proto.Query
         * @instance
         */
        Query.prototype.tokenGetNftInfos = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * Query query.
         * @member {"getByKey"|"getBySolidityID"|"contractCallLocal"|"contractGetInfo"|"contractGetBytecode"|"ContractGetRecords"|"cryptogetAccountBalance"|"cryptoGetAccountRecords"|"cryptoGetInfo"|"cryptoGetLiveHash"|"cryptoGetProxyStakers"|"fileGetContents"|"fileGetInfo"|"transactionGetReceipt"|"transactionGetRecord"|"transactionGetFastRecord"|"consensusGetTopicInfo"|"networkGetVersionInfo"|"tokenGetInfo"|"scheduleGetInfo"|"tokenGetAccountNftInfos"|"tokenGetNftInfo"|"tokenGetNftInfos"|undefined} query
         * @memberof proto.Query
         * @instance
         */
        Object.defineProperty(Query.prototype, "query", {
            get: $util.oneOfGetter($oneOfFields = ["getByKey", "getBySolidityID", "contractCallLocal", "contractGetInfo", "contractGetBytecode", "ContractGetRecords", "cryptogetAccountBalance", "cryptoGetAccountRecords", "cryptoGetInfo", "cryptoGetLiveHash", "cryptoGetProxyStakers", "fileGetContents", "fileGetInfo", "transactionGetReceipt", "transactionGetRecord", "transactionGetFastRecord", "consensusGetTopicInfo", "networkGetVersionInfo", "tokenGetInfo", "scheduleGetInfo", "tokenGetAccountNftInfos", "tokenGetNftInfo", "tokenGetNftInfos"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Query instance using the specified properties.
         * @function create
         * @memberof proto.Query
         * @static
         * @param {proto.IQuery=} [properties] Properties to set
         * @returns {proto.Query} Query instance
         */
        Query.create = function create(properties) {
            return new Query(properties);
        };

        /**
         * Encodes the specified Query message. Does not implicitly {@link proto.Query.verify|verify} messages.
         * @function encode
         * @memberof proto.Query
         * @static
         * @param {proto.IQuery} m Query message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Query.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.getByKey != null && Object.hasOwnProperty.call(m, "getByKey"))
                $root.proto.GetByKeyQuery.encode(m.getByKey, w.uint32(10).fork()).ldelim();
            if (m.getBySolidityID != null && Object.hasOwnProperty.call(m, "getBySolidityID"))
                $root.proto.GetBySolidityIDQuery.encode(m.getBySolidityID, w.uint32(18).fork()).ldelim();
            if (m.contractCallLocal != null && Object.hasOwnProperty.call(m, "contractCallLocal"))
                $root.proto.ContractCallLocalQuery.encode(m.contractCallLocal, w.uint32(26).fork()).ldelim();
            if (m.contractGetInfo != null && Object.hasOwnProperty.call(m, "contractGetInfo"))
                $root.proto.ContractGetInfoQuery.encode(m.contractGetInfo, w.uint32(34).fork()).ldelim();
            if (m.contractGetBytecode != null && Object.hasOwnProperty.call(m, "contractGetBytecode"))
                $root.proto.ContractGetBytecodeQuery.encode(m.contractGetBytecode, w.uint32(42).fork()).ldelim();
            if (m.ContractGetRecords != null && Object.hasOwnProperty.call(m, "ContractGetRecords"))
                $root.proto.ContractGetRecordsQuery.encode(m.ContractGetRecords, w.uint32(50).fork()).ldelim();
            if (m.cryptogetAccountBalance != null && Object.hasOwnProperty.call(m, "cryptogetAccountBalance"))
                $root.proto.CryptoGetAccountBalanceQuery.encode(m.cryptogetAccountBalance, w.uint32(58).fork()).ldelim();
            if (m.cryptoGetAccountRecords != null && Object.hasOwnProperty.call(m, "cryptoGetAccountRecords"))
                $root.proto.CryptoGetAccountRecordsQuery.encode(m.cryptoGetAccountRecords, w.uint32(66).fork()).ldelim();
            if (m.cryptoGetInfo != null && Object.hasOwnProperty.call(m, "cryptoGetInfo"))
                $root.proto.CryptoGetInfoQuery.encode(m.cryptoGetInfo, w.uint32(74).fork()).ldelim();
            if (m.cryptoGetLiveHash != null && Object.hasOwnProperty.call(m, "cryptoGetLiveHash"))
                $root.proto.CryptoGetLiveHashQuery.encode(m.cryptoGetLiveHash, w.uint32(82).fork()).ldelim();
            if (m.cryptoGetProxyStakers != null && Object.hasOwnProperty.call(m, "cryptoGetProxyStakers"))
                $root.proto.CryptoGetStakersQuery.encode(m.cryptoGetProxyStakers, w.uint32(90).fork()).ldelim();
            if (m.fileGetContents != null && Object.hasOwnProperty.call(m, "fileGetContents"))
                $root.proto.FileGetContentsQuery.encode(m.fileGetContents, w.uint32(98).fork()).ldelim();
            if (m.fileGetInfo != null && Object.hasOwnProperty.call(m, "fileGetInfo"))
                $root.proto.FileGetInfoQuery.encode(m.fileGetInfo, w.uint32(106).fork()).ldelim();
            if (m.transactionGetReceipt != null && Object.hasOwnProperty.call(m, "transactionGetReceipt"))
                $root.proto.TransactionGetReceiptQuery.encode(m.transactionGetReceipt, w.uint32(114).fork()).ldelim();
            if (m.transactionGetRecord != null && Object.hasOwnProperty.call(m, "transactionGetRecord"))
                $root.proto.TransactionGetRecordQuery.encode(m.transactionGetRecord, w.uint32(122).fork()).ldelim();
            if (m.transactionGetFastRecord != null && Object.hasOwnProperty.call(m, "transactionGetFastRecord"))
                $root.proto.TransactionGetFastRecordQuery.encode(m.transactionGetFastRecord, w.uint32(130).fork()).ldelim();
            if (m.consensusGetTopicInfo != null && Object.hasOwnProperty.call(m, "consensusGetTopicInfo"))
                $root.proto.ConsensusGetTopicInfoQuery.encode(m.consensusGetTopicInfo, w.uint32(402).fork()).ldelim();
            if (m.networkGetVersionInfo != null && Object.hasOwnProperty.call(m, "networkGetVersionInfo"))
                $root.proto.NetworkGetVersionInfoQuery.encode(m.networkGetVersionInfo, w.uint32(410).fork()).ldelim();
            if (m.tokenGetInfo != null && Object.hasOwnProperty.call(m, "tokenGetInfo"))
                $root.proto.TokenGetInfoQuery.encode(m.tokenGetInfo, w.uint32(418).fork()).ldelim();
            if (m.scheduleGetInfo != null && Object.hasOwnProperty.call(m, "scheduleGetInfo"))
                $root.proto.ScheduleGetInfoQuery.encode(m.scheduleGetInfo, w.uint32(426).fork()).ldelim();
            if (m.tokenGetAccountNftInfos != null && Object.hasOwnProperty.call(m, "tokenGetAccountNftInfos"))
                $root.proto.TokenGetAccountNftInfosQuery.encode(m.tokenGetAccountNftInfos, w.uint32(434).fork()).ldelim();
            if (m.tokenGetNftInfo != null && Object.hasOwnProperty.call(m, "tokenGetNftInfo"))
                $root.proto.TokenGetNftInfoQuery.encode(m.tokenGetNftInfo, w.uint32(442).fork()).ldelim();
            if (m.tokenGetNftInfos != null && Object.hasOwnProperty.call(m, "tokenGetNftInfos"))
                $root.proto.TokenGetNftInfosQuery.encode(m.tokenGetNftInfos, w.uint32(450).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a Query message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Query
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.Query} Query
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Query.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.Query();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.getByKey = $root.proto.GetByKeyQuery.decode(r, r.uint32());
                    break;
                case 2:
                    m.getBySolidityID = $root.proto.GetBySolidityIDQuery.decode(r, r.uint32());
                    break;
                case 3:
                    m.contractCallLocal = $root.proto.ContractCallLocalQuery.decode(r, r.uint32());
                    break;
                case 4:
                    m.contractGetInfo = $root.proto.ContractGetInfoQuery.decode(r, r.uint32());
                    break;
                case 5:
                    m.contractGetBytecode = $root.proto.ContractGetBytecodeQuery.decode(r, r.uint32());
                    break;
                case 6:
                    m.ContractGetRecords = $root.proto.ContractGetRecordsQuery.decode(r, r.uint32());
                    break;
                case 7:
                    m.cryptogetAccountBalance = $root.proto.CryptoGetAccountBalanceQuery.decode(r, r.uint32());
                    break;
                case 8:
                    m.cryptoGetAccountRecords = $root.proto.CryptoGetAccountRecordsQuery.decode(r, r.uint32());
                    break;
                case 9:
                    m.cryptoGetInfo = $root.proto.CryptoGetInfoQuery.decode(r, r.uint32());
                    break;
                case 10:
                    m.cryptoGetLiveHash = $root.proto.CryptoGetLiveHashQuery.decode(r, r.uint32());
                    break;
                case 11:
                    m.cryptoGetProxyStakers = $root.proto.CryptoGetStakersQuery.decode(r, r.uint32());
                    break;
                case 12:
                    m.fileGetContents = $root.proto.FileGetContentsQuery.decode(r, r.uint32());
                    break;
                case 13:
                    m.fileGetInfo = $root.proto.FileGetInfoQuery.decode(r, r.uint32());
                    break;
                case 14:
                    m.transactionGetReceipt = $root.proto.TransactionGetReceiptQuery.decode(r, r.uint32());
                    break;
                case 15:
                    m.transactionGetRecord = $root.proto.TransactionGetRecordQuery.decode(r, r.uint32());
                    break;
                case 16:
                    m.transactionGetFastRecord = $root.proto.TransactionGetFastRecordQuery.decode(r, r.uint32());
                    break;
                case 50:
                    m.consensusGetTopicInfo = $root.proto.ConsensusGetTopicInfoQuery.decode(r, r.uint32());
                    break;
                case 51:
                    m.networkGetVersionInfo = $root.proto.NetworkGetVersionInfoQuery.decode(r, r.uint32());
                    break;
                case 52:
                    m.tokenGetInfo = $root.proto.TokenGetInfoQuery.decode(r, r.uint32());
                    break;
                case 53:
                    m.scheduleGetInfo = $root.proto.ScheduleGetInfoQuery.decode(r, r.uint32());
                    break;
                case 54:
                    m.tokenGetAccountNftInfos = $root.proto.TokenGetAccountNftInfosQuery.decode(r, r.uint32());
                    break;
                case 55:
                    m.tokenGetNftInfo = $root.proto.TokenGetNftInfoQuery.decode(r, r.uint32());
                    break;
                case 56:
                    m.tokenGetNftInfos = $root.proto.TokenGetNftInfosQuery.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return Query;
    })();

    proto.GetByKeyQuery = (function() {

        /**
         * Properties of a GetByKeyQuery.
         * @memberof proto
         * @interface IGetByKeyQuery
         * @property {proto.IQueryHeader|null} [header] GetByKeyQuery header
         * @property {proto.IKey|null} [key] GetByKeyQuery key
         */

        /**
         * Constructs a new GetByKeyQuery.
         * @memberof proto
         * @classdesc Represents a GetByKeyQuery.
         * @implements IGetByKeyQuery
         * @constructor
         * @param {proto.IGetByKeyQuery=} [p] Properties to set
         */
        function GetByKeyQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * GetByKeyQuery header.
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.GetByKeyQuery
         * @instance
         */
        GetByKeyQuery.prototype.header = null;

        /**
         * GetByKeyQuery key.
         * @member {proto.IKey|null|undefined} key
         * @memberof proto.GetByKeyQuery
         * @instance
         */
        GetByKeyQuery.prototype.key = null;

        /**
         * Creates a new GetByKeyQuery instance using the specified properties.
         * @function create
         * @memberof proto.GetByKeyQuery
         * @static
         * @param {proto.IGetByKeyQuery=} [properties] Properties to set
         * @returns {proto.GetByKeyQuery} GetByKeyQuery instance
         */
        GetByKeyQuery.create = function create(properties) {
            return new GetByKeyQuery(properties);
        };

        /**
         * Encodes the specified GetByKeyQuery message. Does not implicitly {@link proto.GetByKeyQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.GetByKeyQuery
         * @static
         * @param {proto.IGetByKeyQuery} m GetByKeyQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetByKeyQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.key != null && Object.hasOwnProperty.call(m, "key"))
                $root.proto.Key.encode(m.key, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a GetByKeyQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GetByKeyQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.GetByKeyQuery} GetByKeyQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetByKeyQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.GetByKeyQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.key = $root.proto.Key.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return GetByKeyQuery;
    })();

    proto.EntityID = (function() {

        /**
         * Properties of an EntityID.
         * @memberof proto
         * @interface IEntityID
         * @property {proto.IAccountID|null} [accountID] EntityID accountID
         * @property {proto.ILiveHash|null} [liveHash] EntityID liveHash
         * @property {proto.IFileID|null} [fileID] EntityID fileID
         * @property {proto.IContractID|null} [contractID] EntityID contractID
         */

        /**
         * Constructs a new EntityID.
         * @memberof proto
         * @classdesc Represents an EntityID.
         * @implements IEntityID
         * @constructor
         * @param {proto.IEntityID=} [p] Properties to set
         */
        function EntityID(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * EntityID accountID.
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.EntityID
         * @instance
         */
        EntityID.prototype.accountID = null;

        /**
         * EntityID liveHash.
         * @member {proto.ILiveHash|null|undefined} liveHash
         * @memberof proto.EntityID
         * @instance
         */
        EntityID.prototype.liveHash = null;

        /**
         * EntityID fileID.
         * @member {proto.IFileID|null|undefined} fileID
         * @memberof proto.EntityID
         * @instance
         */
        EntityID.prototype.fileID = null;

        /**
         * EntityID contractID.
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.EntityID
         * @instance
         */
        EntityID.prototype.contractID = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * EntityID entity.
         * @member {"accountID"|"liveHash"|"fileID"|"contractID"|undefined} entity
         * @memberof proto.EntityID
         * @instance
         */
        Object.defineProperty(EntityID.prototype, "entity", {
            get: $util.oneOfGetter($oneOfFields = ["accountID", "liveHash", "fileID", "contractID"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new EntityID instance using the specified properties.
         * @function create
         * @memberof proto.EntityID
         * @static
         * @param {proto.IEntityID=} [properties] Properties to set
         * @returns {proto.EntityID} EntityID instance
         */
        EntityID.create = function create(properties) {
            return new EntityID(properties);
        };

        /**
         * Encodes the specified EntityID message. Does not implicitly {@link proto.EntityID.verify|verify} messages.
         * @function encode
         * @memberof proto.EntityID
         * @static
         * @param {proto.IEntityID} m EntityID message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EntityID.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(10).fork()).ldelim();
            if (m.liveHash != null && Object.hasOwnProperty.call(m, "liveHash"))
                $root.proto.LiveHash.encode(m.liveHash, w.uint32(18).fork()).ldelim();
            if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                $root.proto.FileID.encode(m.fileID, w.uint32(26).fork()).ldelim();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(34).fork()).ldelim();
            return w;
        };

        /**
         * Decodes an EntityID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.EntityID
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.EntityID} EntityID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EntityID.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.EntityID();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 2:
                    m.liveHash = $root.proto.LiveHash.decode(r, r.uint32());
                    break;
                case 3:
                    m.fileID = $root.proto.FileID.decode(r, r.uint32());
                    break;
                case 4:
                    m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return EntityID;
    })();

    proto.GetByKeyResponse = (function() {

        /**
         * Properties of a GetByKeyResponse.
         * @memberof proto
         * @interface IGetByKeyResponse
         * @property {proto.IResponseHeader|null} [header] GetByKeyResponse header
         * @property {Array.<proto.IEntityID>|null} [entities] GetByKeyResponse entities
         */

        /**
         * Constructs a new GetByKeyResponse.
         * @memberof proto
         * @classdesc Represents a GetByKeyResponse.
         * @implements IGetByKeyResponse
         * @constructor
         * @param {proto.IGetByKeyResponse=} [p] Properties to set
         */
        function GetByKeyResponse(p) {
            this.entities = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * GetByKeyResponse header.
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.GetByKeyResponse
         * @instance
         */
        GetByKeyResponse.prototype.header = null;

        /**
         * GetByKeyResponse entities.
         * @member {Array.<proto.IEntityID>} entities
         * @memberof proto.GetByKeyResponse
         * @instance
         */
        GetByKeyResponse.prototype.entities = $util.emptyArray;

        /**
         * Creates a new GetByKeyResponse instance using the specified properties.
         * @function create
         * @memberof proto.GetByKeyResponse
         * @static
         * @param {proto.IGetByKeyResponse=} [properties] Properties to set
         * @returns {proto.GetByKeyResponse} GetByKeyResponse instance
         */
        GetByKeyResponse.create = function create(properties) {
            return new GetByKeyResponse(properties);
        };

        /**
         * Encodes the specified GetByKeyResponse message. Does not implicitly {@link proto.GetByKeyResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GetByKeyResponse
         * @static
         * @param {proto.IGetByKeyResponse} m GetByKeyResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetByKeyResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.entities != null && m.entities.length) {
                for (var i = 0; i < m.entities.length; ++i)
                    $root.proto.EntityID.encode(m.entities[i], w.uint32(18).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a GetByKeyResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GetByKeyResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.GetByKeyResponse} GetByKeyResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetByKeyResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.GetByKeyResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                    break;
                case 2:
                    if (!(m.entities && m.entities.length))
                        m.entities = [];
                    m.entities.push($root.proto.EntityID.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return GetByKeyResponse;
    })();

    proto.GetBySolidityIDQuery = (function() {

        /**
         * Properties of a GetBySolidityIDQuery.
         * @memberof proto
         * @interface IGetBySolidityIDQuery
         * @property {proto.IQueryHeader|null} [header] GetBySolidityIDQuery header
         * @property {string|null} [solidityID] GetBySolidityIDQuery solidityID
         */

        /**
         * Constructs a new GetBySolidityIDQuery.
         * @memberof proto
         * @classdesc Represents a GetBySolidityIDQuery.
         * @implements IGetBySolidityIDQuery
         * @constructor
         * @param {proto.IGetBySolidityIDQuery=} [p] Properties to set
         */
        function GetBySolidityIDQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * GetBySolidityIDQuery header.
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.GetBySolidityIDQuery
         * @instance
         */
        GetBySolidityIDQuery.prototype.header = null;

        /**
         * GetBySolidityIDQuery solidityID.
         * @member {string} solidityID
         * @memberof proto.GetBySolidityIDQuery
         * @instance
         */
        GetBySolidityIDQuery.prototype.solidityID = "";

        /**
         * Creates a new GetBySolidityIDQuery instance using the specified properties.
         * @function create
         * @memberof proto.GetBySolidityIDQuery
         * @static
         * @param {proto.IGetBySolidityIDQuery=} [properties] Properties to set
         * @returns {proto.GetBySolidityIDQuery} GetBySolidityIDQuery instance
         */
        GetBySolidityIDQuery.create = function create(properties) {
            return new GetBySolidityIDQuery(properties);
        };

        /**
         * Encodes the specified GetBySolidityIDQuery message. Does not implicitly {@link proto.GetBySolidityIDQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.GetBySolidityIDQuery
         * @static
         * @param {proto.IGetBySolidityIDQuery} m GetBySolidityIDQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetBySolidityIDQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.solidityID != null && Object.hasOwnProperty.call(m, "solidityID"))
                w.uint32(18).string(m.solidityID);
            return w;
        };

        /**
         * Decodes a GetBySolidityIDQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GetBySolidityIDQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.GetBySolidityIDQuery} GetBySolidityIDQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetBySolidityIDQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.GetBySolidityIDQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.solidityID = r.string();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return GetBySolidityIDQuery;
    })();

    proto.GetBySolidityIDResponse = (function() {

        /**
         * Properties of a GetBySolidityIDResponse.
         * @memberof proto
         * @interface IGetBySolidityIDResponse
         * @property {proto.IResponseHeader|null} [header] GetBySolidityIDResponse header
         * @property {proto.IAccountID|null} [accountID] GetBySolidityIDResponse accountID
         * @property {proto.IFileID|null} [fileID] GetBySolidityIDResponse fileID
         * @property {proto.IContractID|null} [contractID] GetBySolidityIDResponse contractID
         */

        /**
         * Constructs a new GetBySolidityIDResponse.
         * @memberof proto
         * @classdesc Represents a GetBySolidityIDResponse.
         * @implements IGetBySolidityIDResponse
         * @constructor
         * @param {proto.IGetBySolidityIDResponse=} [p] Properties to set
         */
        function GetBySolidityIDResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * GetBySolidityIDResponse header.
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.GetBySolidityIDResponse
         * @instance
         */
        GetBySolidityIDResponse.prototype.header = null;

        /**
         * GetBySolidityIDResponse accountID.
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.GetBySolidityIDResponse
         * @instance
         */
        GetBySolidityIDResponse.prototype.accountID = null;

        /**
         * GetBySolidityIDResponse fileID.
         * @member {proto.IFileID|null|undefined} fileID
         * @memberof proto.GetBySolidityIDResponse
         * @instance
         */
        GetBySolidityIDResponse.prototype.fileID = null;

        /**
         * GetBySolidityIDResponse contractID.
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.GetBySolidityIDResponse
         * @instance
         */
        GetBySolidityIDResponse.prototype.contractID = null;

        /**
         * Creates a new GetBySolidityIDResponse instance using the specified properties.
         * @function create
         * @memberof proto.GetBySolidityIDResponse
         * @static
         * @param {proto.IGetBySolidityIDResponse=} [properties] Properties to set
         * @returns {proto.GetBySolidityIDResponse} GetBySolidityIDResponse instance
         */
        GetBySolidityIDResponse.create = function create(properties) {
            return new GetBySolidityIDResponse(properties);
        };

        /**
         * Encodes the specified GetBySolidityIDResponse message. Does not implicitly {@link proto.GetBySolidityIDResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.GetBySolidityIDResponse
         * @static
         * @param {proto.IGetBySolidityIDResponse} m GetBySolidityIDResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetBySolidityIDResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
            if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                $root.proto.FileID.encode(m.fileID, w.uint32(26).fork()).ldelim();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(34).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a GetBySolidityIDResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GetBySolidityIDResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.GetBySolidityIDResponse} GetBySolidityIDResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetBySolidityIDResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.GetBySolidityIDResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 3:
                    m.fileID = $root.proto.FileID.decode(r, r.uint32());
                    break;
                case 4:
                    m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return GetBySolidityIDResponse;
    })();

    proto.ContractLoginfo = (function() {

        /**
         * Properties of a ContractLoginfo.
         * @memberof proto
         * @interface IContractLoginfo
         * @property {proto.IContractID|null} [contractID] ContractLoginfo contractID
         * @property {Uint8Array|null} [bloom] ContractLoginfo bloom
         * @property {Array.<Uint8Array>|null} [topic] ContractLoginfo topic
         * @property {Uint8Array|null} [data] ContractLoginfo data
         */

        /**
         * Constructs a new ContractLoginfo.
         * @memberof proto
         * @classdesc Represents a ContractLoginfo.
         * @implements IContractLoginfo
         * @constructor
         * @param {proto.IContractLoginfo=} [p] Properties to set
         */
        function ContractLoginfo(p) {
            this.topic = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ContractLoginfo contractID.
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.ContractLoginfo
         * @instance
         */
        ContractLoginfo.prototype.contractID = null;

        /**
         * ContractLoginfo bloom.
         * @member {Uint8Array} bloom
         * @memberof proto.ContractLoginfo
         * @instance
         */
        ContractLoginfo.prototype.bloom = $util.newBuffer([]);

        /**
         * ContractLoginfo topic.
         * @member {Array.<Uint8Array>} topic
         * @memberof proto.ContractLoginfo
         * @instance
         */
        ContractLoginfo.prototype.topic = $util.emptyArray;

        /**
         * ContractLoginfo data.
         * @member {Uint8Array} data
         * @memberof proto.ContractLoginfo
         * @instance
         */
        ContractLoginfo.prototype.data = $util.newBuffer([]);

        /**
         * Creates a new ContractLoginfo instance using the specified properties.
         * @function create
         * @memberof proto.ContractLoginfo
         * @static
         * @param {proto.IContractLoginfo=} [properties] Properties to set
         * @returns {proto.ContractLoginfo} ContractLoginfo instance
         */
        ContractLoginfo.create = function create(properties) {
            return new ContractLoginfo(properties);
        };

        /**
         * Encodes the specified ContractLoginfo message. Does not implicitly {@link proto.ContractLoginfo.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractLoginfo
         * @static
         * @param {proto.IContractLoginfo} m ContractLoginfo message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractLoginfo.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(10).fork()).ldelim();
            if (m.bloom != null && Object.hasOwnProperty.call(m, "bloom"))
                w.uint32(18).bytes(m.bloom);
            if (m.topic != null && m.topic.length) {
                for (var i = 0; i < m.topic.length; ++i)
                    w.uint32(26).bytes(m.topic[i]);
            }
            if (m.data != null && Object.hasOwnProperty.call(m, "data"))
                w.uint32(34).bytes(m.data);
            return w;
        };

        /**
         * Decodes a ContractLoginfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractLoginfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractLoginfo} ContractLoginfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractLoginfo.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ContractLoginfo();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                    break;
                case 2:
                    m.bloom = r.bytes();
                    break;
                case 3:
                    if (!(m.topic && m.topic.length))
                        m.topic = [];
                    m.topic.push(r.bytes());
                    break;
                case 4:
                    m.data = r.bytes();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ContractLoginfo;
    })();

    proto.ContractFunctionResult = (function() {

        /**
         * Properties of a ContractFunctionResult.
         * @memberof proto
         * @interface IContractFunctionResult
         * @property {proto.IContractID|null} [contractID] ContractFunctionResult contractID
         * @property {Uint8Array|null} [contractCallResult] ContractFunctionResult contractCallResult
         * @property {string|null} [errorMessage] ContractFunctionResult errorMessage
         * @property {Uint8Array|null} [bloom] ContractFunctionResult bloom
         * @property {Long|null} [gasUsed] ContractFunctionResult gasUsed
         * @property {Array.<proto.IContractLoginfo>|null} [logInfo] ContractFunctionResult logInfo
         * @property {Array.<proto.IContractID>|null} [createdContractIDs] ContractFunctionResult createdContractIDs
         */

        /**
         * Constructs a new ContractFunctionResult.
         * @memberof proto
         * @classdesc Represents a ContractFunctionResult.
         * @implements IContractFunctionResult
         * @constructor
         * @param {proto.IContractFunctionResult=} [p] Properties to set
         */
        function ContractFunctionResult(p) {
            this.logInfo = [];
            this.createdContractIDs = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ContractFunctionResult contractID.
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.ContractFunctionResult
         * @instance
         */
        ContractFunctionResult.prototype.contractID = null;

        /**
         * ContractFunctionResult contractCallResult.
         * @member {Uint8Array} contractCallResult
         * @memberof proto.ContractFunctionResult
         * @instance
         */
        ContractFunctionResult.prototype.contractCallResult = $util.newBuffer([]);

        /**
         * ContractFunctionResult errorMessage.
         * @member {string} errorMessage
         * @memberof proto.ContractFunctionResult
         * @instance
         */
        ContractFunctionResult.prototype.errorMessage = "";

        /**
         * ContractFunctionResult bloom.
         * @member {Uint8Array} bloom
         * @memberof proto.ContractFunctionResult
         * @instance
         */
        ContractFunctionResult.prototype.bloom = $util.newBuffer([]);

        /**
         * ContractFunctionResult gasUsed.
         * @member {Long} gasUsed
         * @memberof proto.ContractFunctionResult
         * @instance
         */
        ContractFunctionResult.prototype.gasUsed = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ContractFunctionResult logInfo.
         * @member {Array.<proto.IContractLoginfo>} logInfo
         * @memberof proto.ContractFunctionResult
         * @instance
         */
        ContractFunctionResult.prototype.logInfo = $util.emptyArray;

        /**
         * ContractFunctionResult createdContractIDs.
         * @member {Array.<proto.IContractID>} createdContractIDs
         * @memberof proto.ContractFunctionResult
         * @instance
         */
        ContractFunctionResult.prototype.createdContractIDs = $util.emptyArray;

        /**
         * Creates a new ContractFunctionResult instance using the specified properties.
         * @function create
         * @memberof proto.ContractFunctionResult
         * @static
         * @param {proto.IContractFunctionResult=} [properties] Properties to set
         * @returns {proto.ContractFunctionResult} ContractFunctionResult instance
         */
        ContractFunctionResult.create = function create(properties) {
            return new ContractFunctionResult(properties);
        };

        /**
         * Encodes the specified ContractFunctionResult message. Does not implicitly {@link proto.ContractFunctionResult.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractFunctionResult
         * @static
         * @param {proto.IContractFunctionResult} m ContractFunctionResult message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractFunctionResult.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(10).fork()).ldelim();
            if (m.contractCallResult != null && Object.hasOwnProperty.call(m, "contractCallResult"))
                w.uint32(18).bytes(m.contractCallResult);
            if (m.errorMessage != null && Object.hasOwnProperty.call(m, "errorMessage"))
                w.uint32(26).string(m.errorMessage);
            if (m.bloom != null && Object.hasOwnProperty.call(m, "bloom"))
                w.uint32(34).bytes(m.bloom);
            if (m.gasUsed != null && Object.hasOwnProperty.call(m, "gasUsed"))
                w.uint32(40).uint64(m.gasUsed);
            if (m.logInfo != null && m.logInfo.length) {
                for (var i = 0; i < m.logInfo.length; ++i)
                    $root.proto.ContractLoginfo.encode(m.logInfo[i], w.uint32(50).fork()).ldelim();
            }
            if (m.createdContractIDs != null && m.createdContractIDs.length) {
                for (var i = 0; i < m.createdContractIDs.length; ++i)
                    $root.proto.ContractID.encode(m.createdContractIDs[i], w.uint32(58).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a ContractFunctionResult message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractFunctionResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractFunctionResult} ContractFunctionResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractFunctionResult.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ContractFunctionResult();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                    break;
                case 2:
                    m.contractCallResult = r.bytes();
                    break;
                case 3:
                    m.errorMessage = r.string();
                    break;
                case 4:
                    m.bloom = r.bytes();
                    break;
                case 5:
                    m.gasUsed = r.uint64();
                    break;
                case 6:
                    if (!(m.logInfo && m.logInfo.length))
                        m.logInfo = [];
                    m.logInfo.push($root.proto.ContractLoginfo.decode(r, r.uint32()));
                    break;
                case 7:
                    if (!(m.createdContractIDs && m.createdContractIDs.length))
                        m.createdContractIDs = [];
                    m.createdContractIDs.push($root.proto.ContractID.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ContractFunctionResult;
    })();

    proto.ContractCallLocalQuery = (function() {

        /**
         * Properties of a ContractCallLocalQuery.
         * @memberof proto
         * @interface IContractCallLocalQuery
         * @property {proto.IQueryHeader|null} [header] ContractCallLocalQuery header
         * @property {proto.IContractID|null} [contractID] ContractCallLocalQuery contractID
         * @property {Long|null} [gas] ContractCallLocalQuery gas
         * @property {Uint8Array|null} [functionParameters] ContractCallLocalQuery functionParameters
         * @property {Long|null} [maxResultSize] ContractCallLocalQuery maxResultSize
         */

        /**
         * Constructs a new ContractCallLocalQuery.
         * @memberof proto
         * @classdesc Represents a ContractCallLocalQuery.
         * @implements IContractCallLocalQuery
         * @constructor
         * @param {proto.IContractCallLocalQuery=} [p] Properties to set
         */
        function ContractCallLocalQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ContractCallLocalQuery header.
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.ContractCallLocalQuery
         * @instance
         */
        ContractCallLocalQuery.prototype.header = null;

        /**
         * ContractCallLocalQuery contractID.
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.ContractCallLocalQuery
         * @instance
         */
        ContractCallLocalQuery.prototype.contractID = null;

        /**
         * ContractCallLocalQuery gas.
         * @member {Long} gas
         * @memberof proto.ContractCallLocalQuery
         * @instance
         */
        ContractCallLocalQuery.prototype.gas = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ContractCallLocalQuery functionParameters.
         * @member {Uint8Array} functionParameters
         * @memberof proto.ContractCallLocalQuery
         * @instance
         */
        ContractCallLocalQuery.prototype.functionParameters = $util.newBuffer([]);

        /**
         * ContractCallLocalQuery maxResultSize.
         * @member {Long} maxResultSize
         * @memberof proto.ContractCallLocalQuery
         * @instance
         */
        ContractCallLocalQuery.prototype.maxResultSize = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ContractCallLocalQuery instance using the specified properties.
         * @function create
         * @memberof proto.ContractCallLocalQuery
         * @static
         * @param {proto.IContractCallLocalQuery=} [properties] Properties to set
         * @returns {proto.ContractCallLocalQuery} ContractCallLocalQuery instance
         */
        ContractCallLocalQuery.create = function create(properties) {
            return new ContractCallLocalQuery(properties);
        };

        /**
         * Encodes the specified ContractCallLocalQuery message. Does not implicitly {@link proto.ContractCallLocalQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractCallLocalQuery
         * @static
         * @param {proto.IContractCallLocalQuery} m ContractCallLocalQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractCallLocalQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(18).fork()).ldelim();
            if (m.gas != null && Object.hasOwnProperty.call(m, "gas"))
                w.uint32(24).int64(m.gas);
            if (m.functionParameters != null && Object.hasOwnProperty.call(m, "functionParameters"))
                w.uint32(34).bytes(m.functionParameters);
            if (m.maxResultSize != null && Object.hasOwnProperty.call(m, "maxResultSize"))
                w.uint32(40).int64(m.maxResultSize);
            return w;
        };

        /**
         * Decodes a ContractCallLocalQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractCallLocalQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractCallLocalQuery} ContractCallLocalQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractCallLocalQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ContractCallLocalQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                    break;
                case 3:
                    m.gas = r.int64();
                    break;
                case 4:
                    m.functionParameters = r.bytes();
                    break;
                case 5:
                    m.maxResultSize = r.int64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ContractCallLocalQuery;
    })();

    proto.ContractCallLocalResponse = (function() {

        /**
         * Properties of a ContractCallLocalResponse.
         * @memberof proto
         * @interface IContractCallLocalResponse
         * @property {proto.IResponseHeader|null} [header] ContractCallLocalResponse header
         * @property {proto.IContractFunctionResult|null} [functionResult] ContractCallLocalResponse functionResult
         */

        /**
         * Constructs a new ContractCallLocalResponse.
         * @memberof proto
         * @classdesc Represents a ContractCallLocalResponse.
         * @implements IContractCallLocalResponse
         * @constructor
         * @param {proto.IContractCallLocalResponse=} [p] Properties to set
         */
        function ContractCallLocalResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ContractCallLocalResponse header.
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.ContractCallLocalResponse
         * @instance
         */
        ContractCallLocalResponse.prototype.header = null;

        /**
         * ContractCallLocalResponse functionResult.
         * @member {proto.IContractFunctionResult|null|undefined} functionResult
         * @memberof proto.ContractCallLocalResponse
         * @instance
         */
        ContractCallLocalResponse.prototype.functionResult = null;

        /**
         * Creates a new ContractCallLocalResponse instance using the specified properties.
         * @function create
         * @memberof proto.ContractCallLocalResponse
         * @static
         * @param {proto.IContractCallLocalResponse=} [properties] Properties to set
         * @returns {proto.ContractCallLocalResponse} ContractCallLocalResponse instance
         */
        ContractCallLocalResponse.create = function create(properties) {
            return new ContractCallLocalResponse(properties);
        };

        /**
         * Encodes the specified ContractCallLocalResponse message. Does not implicitly {@link proto.ContractCallLocalResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractCallLocalResponse
         * @static
         * @param {proto.IContractCallLocalResponse} m ContractCallLocalResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractCallLocalResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.functionResult != null && Object.hasOwnProperty.call(m, "functionResult"))
                $root.proto.ContractFunctionResult.encode(m.functionResult, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ContractCallLocalResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractCallLocalResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractCallLocalResponse} ContractCallLocalResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractCallLocalResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ContractCallLocalResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.functionResult = $root.proto.ContractFunctionResult.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ContractCallLocalResponse;
    })();

    proto.ContractGetInfoQuery = (function() {

        /**
         * Properties of a ContractGetInfoQuery.
         * @memberof proto
         * @interface IContractGetInfoQuery
         * @property {proto.IQueryHeader|null} [header] ContractGetInfoQuery header
         * @property {proto.IContractID|null} [contractID] ContractGetInfoQuery contractID
         */

        /**
         * Constructs a new ContractGetInfoQuery.
         * @memberof proto
         * @classdesc Represents a ContractGetInfoQuery.
         * @implements IContractGetInfoQuery
         * @constructor
         * @param {proto.IContractGetInfoQuery=} [p] Properties to set
         */
        function ContractGetInfoQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ContractGetInfoQuery header.
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.ContractGetInfoQuery
         * @instance
         */
        ContractGetInfoQuery.prototype.header = null;

        /**
         * ContractGetInfoQuery contractID.
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.ContractGetInfoQuery
         * @instance
         */
        ContractGetInfoQuery.prototype.contractID = null;

        /**
         * Creates a new ContractGetInfoQuery instance using the specified properties.
         * @function create
         * @memberof proto.ContractGetInfoQuery
         * @static
         * @param {proto.IContractGetInfoQuery=} [properties] Properties to set
         * @returns {proto.ContractGetInfoQuery} ContractGetInfoQuery instance
         */
        ContractGetInfoQuery.create = function create(properties) {
            return new ContractGetInfoQuery(properties);
        };

        /**
         * Encodes the specified ContractGetInfoQuery message. Does not implicitly {@link proto.ContractGetInfoQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractGetInfoQuery
         * @static
         * @param {proto.IContractGetInfoQuery} m ContractGetInfoQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractGetInfoQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ContractGetInfoQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractGetInfoQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractGetInfoQuery} ContractGetInfoQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractGetInfoQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ContractGetInfoQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ContractGetInfoQuery;
    })();

    proto.ContractGetInfoResponse = (function() {

        /**
         * Properties of a ContractGetInfoResponse.
         * @memberof proto
         * @interface IContractGetInfoResponse
         * @property {proto.IResponseHeader|null} [header] ContractGetInfoResponse header
         * @property {proto.ContractGetInfoResponse.IContractInfo|null} [contractInfo] ContractGetInfoResponse contractInfo
         */

        /**
         * Constructs a new ContractGetInfoResponse.
         * @memberof proto
         * @classdesc Represents a ContractGetInfoResponse.
         * @implements IContractGetInfoResponse
         * @constructor
         * @param {proto.IContractGetInfoResponse=} [p] Properties to set
         */
        function ContractGetInfoResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ContractGetInfoResponse header.
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.ContractGetInfoResponse
         * @instance
         */
        ContractGetInfoResponse.prototype.header = null;

        /**
         * ContractGetInfoResponse contractInfo.
         * @member {proto.ContractGetInfoResponse.IContractInfo|null|undefined} contractInfo
         * @memberof proto.ContractGetInfoResponse
         * @instance
         */
        ContractGetInfoResponse.prototype.contractInfo = null;

        /**
         * Creates a new ContractGetInfoResponse instance using the specified properties.
         * @function create
         * @memberof proto.ContractGetInfoResponse
         * @static
         * @param {proto.IContractGetInfoResponse=} [properties] Properties to set
         * @returns {proto.ContractGetInfoResponse} ContractGetInfoResponse instance
         */
        ContractGetInfoResponse.create = function create(properties) {
            return new ContractGetInfoResponse(properties);
        };

        /**
         * Encodes the specified ContractGetInfoResponse message. Does not implicitly {@link proto.ContractGetInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractGetInfoResponse
         * @static
         * @param {proto.IContractGetInfoResponse} m ContractGetInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractGetInfoResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.contractInfo != null && Object.hasOwnProperty.call(m, "contractInfo"))
                $root.proto.ContractGetInfoResponse.ContractInfo.encode(m.contractInfo, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ContractGetInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractGetInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractGetInfoResponse} ContractGetInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractGetInfoResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ContractGetInfoResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.contractInfo = $root.proto.ContractGetInfoResponse.ContractInfo.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        ContractGetInfoResponse.ContractInfo = (function() {

            /**
             * Properties of a ContractInfo.
             * @memberof proto.ContractGetInfoResponse
             * @interface IContractInfo
             * @property {proto.IContractID|null} [contractID] ContractInfo contractID
             * @property {proto.IAccountID|null} [accountID] ContractInfo accountID
             * @property {string|null} [contractAccountID] ContractInfo contractAccountID
             * @property {proto.IKey|null} [adminKey] ContractInfo adminKey
             * @property {proto.ITimestamp|null} [expirationTime] ContractInfo expirationTime
             * @property {proto.IDuration|null} [autoRenewPeriod] ContractInfo autoRenewPeriod
             * @property {Long|null} [storage] ContractInfo storage
             * @property {string|null} [memo] ContractInfo memo
             * @property {Long|null} [balance] ContractInfo balance
             * @property {boolean|null} [deleted] ContractInfo deleted
             * @property {Array.<proto.ITokenRelationship>|null} [tokenRelationships] ContractInfo tokenRelationships
             */

            /**
             * Constructs a new ContractInfo.
             * @memberof proto.ContractGetInfoResponse
             * @classdesc Represents a ContractInfo.
             * @implements IContractInfo
             * @constructor
             * @param {proto.ContractGetInfoResponse.IContractInfo=} [p] Properties to set
             */
            function ContractInfo(p) {
                this.tokenRelationships = [];
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * ContractInfo contractID.
             * @member {proto.IContractID|null|undefined} contractID
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.contractID = null;

            /**
             * ContractInfo accountID.
             * @member {proto.IAccountID|null|undefined} accountID
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.accountID = null;

            /**
             * ContractInfo contractAccountID.
             * @member {string} contractAccountID
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.contractAccountID = "";

            /**
             * ContractInfo adminKey.
             * @member {proto.IKey|null|undefined} adminKey
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.adminKey = null;

            /**
             * ContractInfo expirationTime.
             * @member {proto.ITimestamp|null|undefined} expirationTime
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.expirationTime = null;

            /**
             * ContractInfo autoRenewPeriod.
             * @member {proto.IDuration|null|undefined} autoRenewPeriod
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.autoRenewPeriod = null;

            /**
             * ContractInfo storage.
             * @member {Long} storage
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.storage = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ContractInfo memo.
             * @member {string} memo
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.memo = "";

            /**
             * ContractInfo balance.
             * @member {Long} balance
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.balance = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ContractInfo deleted.
             * @member {boolean} deleted
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.deleted = false;

            /**
             * ContractInfo tokenRelationships.
             * @member {Array.<proto.ITokenRelationship>} tokenRelationships
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @instance
             */
            ContractInfo.prototype.tokenRelationships = $util.emptyArray;

            /**
             * Creates a new ContractInfo instance using the specified properties.
             * @function create
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @static
             * @param {proto.ContractGetInfoResponse.IContractInfo=} [properties] Properties to set
             * @returns {proto.ContractGetInfoResponse.ContractInfo} ContractInfo instance
             */
            ContractInfo.create = function create(properties) {
                return new ContractInfo(properties);
            };

            /**
             * Encodes the specified ContractInfo message. Does not implicitly {@link proto.ContractGetInfoResponse.ContractInfo.verify|verify} messages.
             * @function encode
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @static
             * @param {proto.ContractGetInfoResponse.IContractInfo} m ContractInfo message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ContractInfo.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                    $root.proto.ContractID.encode(m.contractID, w.uint32(10).fork()).ldelim();
                if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                    $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
                if (m.contractAccountID != null && Object.hasOwnProperty.call(m, "contractAccountID"))
                    w.uint32(26).string(m.contractAccountID);
                if (m.adminKey != null && Object.hasOwnProperty.call(m, "adminKey"))
                    $root.proto.Key.encode(m.adminKey, w.uint32(34).fork()).ldelim();
                if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                    $root.proto.Timestamp.encode(m.expirationTime, w.uint32(42).fork()).ldelim();
                if (m.autoRenewPeriod != null && Object.hasOwnProperty.call(m, "autoRenewPeriod"))
                    $root.proto.Duration.encode(m.autoRenewPeriod, w.uint32(50).fork()).ldelim();
                if (m.storage != null && Object.hasOwnProperty.call(m, "storage"))
                    w.uint32(56).int64(m.storage);
                if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                    w.uint32(66).string(m.memo);
                if (m.balance != null && Object.hasOwnProperty.call(m, "balance"))
                    w.uint32(72).uint64(m.balance);
                if (m.deleted != null && Object.hasOwnProperty.call(m, "deleted"))
                    w.uint32(80).bool(m.deleted);
                if (m.tokenRelationships != null && m.tokenRelationships.length) {
                    for (var i = 0; i < m.tokenRelationships.length; ++i)
                        $root.proto.TokenRelationship.encode(m.tokenRelationships[i], w.uint32(90).fork()).ldelim();
                }
                return w;
            };

            /**
             * Decodes a ContractInfo message from the specified reader or buffer.
             * @function decode
             * @memberof proto.ContractGetInfoResponse.ContractInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {proto.ContractGetInfoResponse.ContractInfo} ContractInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ContractInfo.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ContractGetInfoResponse.ContractInfo();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                        break;
                    case 2:
                        m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    case 3:
                        m.contractAccountID = r.string();
                        break;
                    case 4:
                        m.adminKey = $root.proto.Key.decode(r, r.uint32());
                        break;
                    case 5:
                        m.expirationTime = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    case 6:
                        m.autoRenewPeriod = $root.proto.Duration.decode(r, r.uint32());
                        break;
                    case 7:
                        m.storage = r.int64();
                        break;
                    case 8:
                        m.memo = r.string();
                        break;
                    case 9:
                        m.balance = r.uint64();
                        break;
                    case 10:
                        m.deleted = r.bool();
                        break;
                    case 11:
                        if (!(m.tokenRelationships && m.tokenRelationships.length))
                            m.tokenRelationships = [];
                        m.tokenRelationships.push($root.proto.TokenRelationship.decode(r, r.uint32()));
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return ContractInfo;
        })();

        return ContractGetInfoResponse;
    })();

    proto.ContractGetBytecodeQuery = (function() {

        /**
         * Properties of a ContractGetBytecodeQuery.
         * @memberof proto
         * @interface IContractGetBytecodeQuery
         * @property {proto.IQueryHeader|null} [header] ContractGetBytecodeQuery header
         * @property {proto.IContractID|null} [contractID] ContractGetBytecodeQuery contractID
         */

        /**
         * Constructs a new ContractGetBytecodeQuery.
         * @memberof proto
         * @classdesc Represents a ContractGetBytecodeQuery.
         * @implements IContractGetBytecodeQuery
         * @constructor
         * @param {proto.IContractGetBytecodeQuery=} [p] Properties to set
         */
        function ContractGetBytecodeQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ContractGetBytecodeQuery header.
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.ContractGetBytecodeQuery
         * @instance
         */
        ContractGetBytecodeQuery.prototype.header = null;

        /**
         * ContractGetBytecodeQuery contractID.
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.ContractGetBytecodeQuery
         * @instance
         */
        ContractGetBytecodeQuery.prototype.contractID = null;

        /**
         * Creates a new ContractGetBytecodeQuery instance using the specified properties.
         * @function create
         * @memberof proto.ContractGetBytecodeQuery
         * @static
         * @param {proto.IContractGetBytecodeQuery=} [properties] Properties to set
         * @returns {proto.ContractGetBytecodeQuery} ContractGetBytecodeQuery instance
         */
        ContractGetBytecodeQuery.create = function create(properties) {
            return new ContractGetBytecodeQuery(properties);
        };

        /**
         * Encodes the specified ContractGetBytecodeQuery message. Does not implicitly {@link proto.ContractGetBytecodeQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractGetBytecodeQuery
         * @static
         * @param {proto.IContractGetBytecodeQuery} m ContractGetBytecodeQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractGetBytecodeQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ContractGetBytecodeQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractGetBytecodeQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractGetBytecodeQuery} ContractGetBytecodeQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractGetBytecodeQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ContractGetBytecodeQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ContractGetBytecodeQuery;
    })();

    proto.ContractGetBytecodeResponse = (function() {

        /**
         * Properties of a ContractGetBytecodeResponse.
         * @memberof proto
         * @interface IContractGetBytecodeResponse
         * @property {proto.IResponseHeader|null} [header] ContractGetBytecodeResponse header
         * @property {Uint8Array|null} [bytecode] ContractGetBytecodeResponse bytecode
         */

        /**
         * Constructs a new ContractGetBytecodeResponse.
         * @memberof proto
         * @classdesc Represents a ContractGetBytecodeResponse.
         * @implements IContractGetBytecodeResponse
         * @constructor
         * @param {proto.IContractGetBytecodeResponse=} [p] Properties to set
         */
        function ContractGetBytecodeResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ContractGetBytecodeResponse header.
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.ContractGetBytecodeResponse
         * @instance
         */
        ContractGetBytecodeResponse.prototype.header = null;

        /**
         * ContractGetBytecodeResponse bytecode.
         * @member {Uint8Array} bytecode
         * @memberof proto.ContractGetBytecodeResponse
         * @instance
         */
        ContractGetBytecodeResponse.prototype.bytecode = $util.newBuffer([]);

        /**
         * Creates a new ContractGetBytecodeResponse instance using the specified properties.
         * @function create
         * @memberof proto.ContractGetBytecodeResponse
         * @static
         * @param {proto.IContractGetBytecodeResponse=} [properties] Properties to set
         * @returns {proto.ContractGetBytecodeResponse} ContractGetBytecodeResponse instance
         */
        ContractGetBytecodeResponse.create = function create(properties) {
            return new ContractGetBytecodeResponse(properties);
        };

        /**
         * Encodes the specified ContractGetBytecodeResponse message. Does not implicitly {@link proto.ContractGetBytecodeResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractGetBytecodeResponse
         * @static
         * @param {proto.IContractGetBytecodeResponse} m ContractGetBytecodeResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractGetBytecodeResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.bytecode != null && Object.hasOwnProperty.call(m, "bytecode"))
                w.uint32(50).bytes(m.bytecode);
            return w;
        };

        /**
         * Decodes a ContractGetBytecodeResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractGetBytecodeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractGetBytecodeResponse} ContractGetBytecodeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractGetBytecodeResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ContractGetBytecodeResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                    break;
                case 6:
                    m.bytecode = r.bytes();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ContractGetBytecodeResponse;
    })();

    proto.ContractGetRecordsQuery = (function() {

        /**
         * Properties of a ContractGetRecordsQuery.
         * @memberof proto
         * @interface IContractGetRecordsQuery
         * @property {proto.IQueryHeader|null} [header] ContractGetRecordsQuery header
         * @property {proto.IContractID|null} [contractID] ContractGetRecordsQuery contractID
         */

        /**
         * Constructs a new ContractGetRecordsQuery.
         * @memberof proto
         * @classdesc Represents a ContractGetRecordsQuery.
         * @implements IContractGetRecordsQuery
         * @constructor
         * @param {proto.IContractGetRecordsQuery=} [p] Properties to set
         */
        function ContractGetRecordsQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ContractGetRecordsQuery header.
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.ContractGetRecordsQuery
         * @instance
         */
        ContractGetRecordsQuery.prototype.header = null;

        /**
         * ContractGetRecordsQuery contractID.
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.ContractGetRecordsQuery
         * @instance
         */
        ContractGetRecordsQuery.prototype.contractID = null;

        /**
         * Creates a new ContractGetRecordsQuery instance using the specified properties.
         * @function create
         * @memberof proto.ContractGetRecordsQuery
         * @static
         * @param {proto.IContractGetRecordsQuery=} [properties] Properties to set
         * @returns {proto.ContractGetRecordsQuery} ContractGetRecordsQuery instance
         */
        ContractGetRecordsQuery.create = function create(properties) {
            return new ContractGetRecordsQuery(properties);
        };

        /**
         * Encodes the specified ContractGetRecordsQuery message. Does not implicitly {@link proto.ContractGetRecordsQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractGetRecordsQuery
         * @static
         * @param {proto.IContractGetRecordsQuery} m ContractGetRecordsQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractGetRecordsQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ContractGetRecordsQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractGetRecordsQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractGetRecordsQuery} ContractGetRecordsQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractGetRecordsQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ContractGetRecordsQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ContractGetRecordsQuery;
    })();

    proto.ContractGetRecordsResponse = (function() {

        /**
         * Properties of a ContractGetRecordsResponse.
         * @memberof proto
         * @interface IContractGetRecordsResponse
         * @property {proto.IResponseHeader|null} [header] ContractGetRecordsResponse header
         * @property {proto.IContractID|null} [contractID] ContractGetRecordsResponse contractID
         * @property {Array.<proto.ITransactionRecord>|null} [records] ContractGetRecordsResponse records
         */

        /**
         * Constructs a new ContractGetRecordsResponse.
         * @memberof proto
         * @classdesc Represents a ContractGetRecordsResponse.
         * @implements IContractGetRecordsResponse
         * @constructor
         * @param {proto.IContractGetRecordsResponse=} [p] Properties to set
         */
        function ContractGetRecordsResponse(p) {
            this.records = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ContractGetRecordsResponse header.
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.ContractGetRecordsResponse
         * @instance
         */
        ContractGetRecordsResponse.prototype.header = null;

        /**
         * ContractGetRecordsResponse contractID.
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.ContractGetRecordsResponse
         * @instance
         */
        ContractGetRecordsResponse.prototype.contractID = null;

        /**
         * ContractGetRecordsResponse records.
         * @member {Array.<proto.ITransactionRecord>} records
         * @memberof proto.ContractGetRecordsResponse
         * @instance
         */
        ContractGetRecordsResponse.prototype.records = $util.emptyArray;

        /**
         * Creates a new ContractGetRecordsResponse instance using the specified properties.
         * @function create
         * @memberof proto.ContractGetRecordsResponse
         * @static
         * @param {proto.IContractGetRecordsResponse=} [properties] Properties to set
         * @returns {proto.ContractGetRecordsResponse} ContractGetRecordsResponse instance
         */
        ContractGetRecordsResponse.create = function create(properties) {
            return new ContractGetRecordsResponse(properties);
        };

        /**
         * Encodes the specified ContractGetRecordsResponse message. Does not implicitly {@link proto.ContractGetRecordsResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ContractGetRecordsResponse
         * @static
         * @param {proto.IContractGetRecordsResponse} m ContractGetRecordsResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractGetRecordsResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(18).fork()).ldelim();
            if (m.records != null && m.records.length) {
                for (var i = 0; i < m.records.length; ++i)
                    $root.proto.TransactionRecord.encode(m.records[i], w.uint32(26).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a ContractGetRecordsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ContractGetRecordsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ContractGetRecordsResponse} ContractGetRecordsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractGetRecordsResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ContractGetRecordsResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                    break;
                case 3:
                    if (!(m.records && m.records.length))
                        m.records = [];
                    m.records.push($root.proto.TransactionRecord.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ContractGetRecordsResponse;
    })();

    proto.TransactionRecord = (function() {

        /**
         * Properties of a TransactionRecord.
         * @memberof proto
         * @interface ITransactionRecord
         * @property {proto.ITransactionReceipt|null} [receipt] TransactionRecord receipt
         * @property {Uint8Array|null} [transactionHash] TransactionRecord transactionHash
         * @property {proto.ITimestamp|null} [consensusTimestamp] TransactionRecord consensusTimestamp
         * @property {proto.ITransactionID|null} [transactionID] TransactionRecord transactionID
         * @property {string|null} [memo] TransactionRecord memo
         * @property {Long|null} [transactionFee] TransactionRecord transactionFee
         * @property {proto.IContractFunctionResult|null} [contractCallResult] TransactionRecord contractCallResult
         * @property {proto.IContractFunctionResult|null} [contractCreateResult] TransactionRecord contractCreateResult
         * @property {proto.ITransferList|null} [transferList] TransactionRecord transferList
         * @property {Array.<proto.ITokenTransferList>|null} [tokenTransferLists] TransactionRecord tokenTransferLists
         * @property {proto.IScheduleID|null} [scheduleRef] TransactionRecord scheduleRef
         * @property {Array.<proto.IAssessedCustomFee>|null} [assessedCustomFees] TransactionRecord assessedCustomFees
         */

        /**
         * Constructs a new TransactionRecord.
         * @memberof proto
         * @classdesc Represents a TransactionRecord.
         * @implements ITransactionRecord
         * @constructor
         * @param {proto.ITransactionRecord=} [p] Properties to set
         */
        function TransactionRecord(p) {
            this.tokenTransferLists = [];
            this.assessedCustomFees = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TransactionRecord receipt.
         * @member {proto.ITransactionReceipt|null|undefined} receipt
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.receipt = null;

        /**
         * TransactionRecord transactionHash.
         * @member {Uint8Array} transactionHash
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.transactionHash = $util.newBuffer([]);

        /**
         * TransactionRecord consensusTimestamp.
         * @member {proto.ITimestamp|null|undefined} consensusTimestamp
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.consensusTimestamp = null;

        /**
         * TransactionRecord transactionID.
         * @member {proto.ITransactionID|null|undefined} transactionID
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.transactionID = null;

        /**
         * TransactionRecord memo.
         * @member {string} memo
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.memo = "";

        /**
         * TransactionRecord transactionFee.
         * @member {Long} transactionFee
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.transactionFee = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TransactionRecord contractCallResult.
         * @member {proto.IContractFunctionResult|null|undefined} contractCallResult
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.contractCallResult = null;

        /**
         * TransactionRecord contractCreateResult.
         * @member {proto.IContractFunctionResult|null|undefined} contractCreateResult
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.contractCreateResult = null;

        /**
         * TransactionRecord transferList.
         * @member {proto.ITransferList|null|undefined} transferList
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.transferList = null;

        /**
         * TransactionRecord tokenTransferLists.
         * @member {Array.<proto.ITokenTransferList>} tokenTransferLists
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.tokenTransferLists = $util.emptyArray;

        /**
         * TransactionRecord scheduleRef.
         * @member {proto.IScheduleID|null|undefined} scheduleRef
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.scheduleRef = null;

        /**
         * TransactionRecord assessedCustomFees.
         * @member {Array.<proto.IAssessedCustomFee>} assessedCustomFees
         * @memberof proto.TransactionRecord
         * @instance
         */
        TransactionRecord.prototype.assessedCustomFees = $util.emptyArray;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * TransactionRecord body.
         * @member {"contractCallResult"|"contractCreateResult"|undefined} body
         * @memberof proto.TransactionRecord
         * @instance
         */
        Object.defineProperty(TransactionRecord.prototype, "body", {
            get: $util.oneOfGetter($oneOfFields = ["contractCallResult", "contractCreateResult"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new TransactionRecord instance using the specified properties.
         * @function create
         * @memberof proto.TransactionRecord
         * @static
         * @param {proto.ITransactionRecord=} [properties] Properties to set
         * @returns {proto.TransactionRecord} TransactionRecord instance
         */
        TransactionRecord.create = function create(properties) {
            return new TransactionRecord(properties);
        };

        /**
         * Encodes the specified TransactionRecord message. Does not implicitly {@link proto.TransactionRecord.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionRecord
         * @static
         * @param {proto.ITransactionRecord} m TransactionRecord message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionRecord.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.receipt != null && Object.hasOwnProperty.call(m, "receipt"))
                $root.proto.TransactionReceipt.encode(m.receipt, w.uint32(10).fork()).ldelim();
            if (m.transactionHash != null && Object.hasOwnProperty.call(m, "transactionHash"))
                w.uint32(18).bytes(m.transactionHash);
            if (m.consensusTimestamp != null && Object.hasOwnProperty.call(m, "consensusTimestamp"))
                $root.proto.Timestamp.encode(m.consensusTimestamp, w.uint32(26).fork()).ldelim();
            if (m.transactionID != null && Object.hasOwnProperty.call(m, "transactionID"))
                $root.proto.TransactionID.encode(m.transactionID, w.uint32(34).fork()).ldelim();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                w.uint32(42).string(m.memo);
            if (m.transactionFee != null && Object.hasOwnProperty.call(m, "transactionFee"))
                w.uint32(48).uint64(m.transactionFee);
            if (m.contractCallResult != null && Object.hasOwnProperty.call(m, "contractCallResult"))
                $root.proto.ContractFunctionResult.encode(m.contractCallResult, w.uint32(58).fork()).ldelim();
            if (m.contractCreateResult != null && Object.hasOwnProperty.call(m, "contractCreateResult"))
                $root.proto.ContractFunctionResult.encode(m.contractCreateResult, w.uint32(66).fork()).ldelim();
            if (m.transferList != null && Object.hasOwnProperty.call(m, "transferList"))
                $root.proto.TransferList.encode(m.transferList, w.uint32(82).fork()).ldelim();
            if (m.tokenTransferLists != null && m.tokenTransferLists.length) {
                for (var i = 0; i < m.tokenTransferLists.length; ++i)
                    $root.proto.TokenTransferList.encode(m.tokenTransferLists[i], w.uint32(90).fork()).ldelim();
            }
            if (m.scheduleRef != null && Object.hasOwnProperty.call(m, "scheduleRef"))
                $root.proto.ScheduleID.encode(m.scheduleRef, w.uint32(98).fork()).ldelim();
            if (m.assessedCustomFees != null && m.assessedCustomFees.length) {
                for (var i = 0; i < m.assessedCustomFees.length; ++i)
                    $root.proto.AssessedCustomFee.encode(m.assessedCustomFees[i], w.uint32(106).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TransactionRecord message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionRecord} TransactionRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionRecord.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TransactionRecord();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.receipt = $root.proto.TransactionReceipt.decode(r, r.uint32());
                    break;
                case 2:
                    m.transactionHash = r.bytes();
                    break;
                case 3:
                    m.consensusTimestamp = $root.proto.Timestamp.decode(r, r.uint32());
                    break;
                case 4:
                    m.transactionID = $root.proto.TransactionID.decode(r, r.uint32());
                    break;
                case 5:
                    m.memo = r.string();
                    break;
                case 6:
                    m.transactionFee = r.uint64();
                    break;
                case 7:
                    m.contractCallResult = $root.proto.ContractFunctionResult.decode(r, r.uint32());
                    break;
                case 8:
                    m.contractCreateResult = $root.proto.ContractFunctionResult.decode(r, r.uint32());
                    break;
                case 10:
                    m.transferList = $root.proto.TransferList.decode(r, r.uint32());
                    break;
                case 11:
                    if (!(m.tokenTransferLists && m.tokenTransferLists.length))
                        m.tokenTransferLists = [];
                    m.tokenTransferLists.push($root.proto.TokenTransferList.decode(r, r.uint32()));
                    break;
                case 12:
                    m.scheduleRef = $root.proto.ScheduleID.decode(r, r.uint32());
                    break;
                case 13:
                    if (!(m.assessedCustomFees && m.assessedCustomFees.length))
                        m.assessedCustomFees = [];
                    m.assessedCustomFees.push($root.proto.AssessedCustomFee.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TransactionRecord;
    })();

    proto.TransactionReceipt = (function() {

        /**
         * Properties of a TransactionReceipt.
         * @memberof proto
         * @interface ITransactionReceipt
         * @property {proto.ResponseCodeEnum|null} [status] TransactionReceipt status
         * @property {proto.IAccountID|null} [accountID] TransactionReceipt accountID
         * @property {proto.IFileID|null} [fileID] TransactionReceipt fileID
         * @property {proto.IContractID|null} [contractID] TransactionReceipt contractID
         * @property {proto.IExchangeRateSet|null} [exchangeRate] TransactionReceipt exchangeRate
         * @property {proto.ITopicID|null} [topicID] TransactionReceipt topicID
         * @property {Long|null} [topicSequenceNumber] TransactionReceipt topicSequenceNumber
         * @property {Uint8Array|null} [topicRunningHash] TransactionReceipt topicRunningHash
         * @property {Long|null} [topicRunningHashVersion] TransactionReceipt topicRunningHashVersion
         * @property {proto.ITokenID|null} [tokenID] TransactionReceipt tokenID
         * @property {Long|null} [newTotalSupply] TransactionReceipt newTotalSupply
         * @property {proto.IScheduleID|null} [scheduleID] TransactionReceipt scheduleID
         * @property {proto.ITransactionID|null} [scheduledTransactionID] TransactionReceipt scheduledTransactionID
         * @property {Array.<Long>|null} [serialNumbers] TransactionReceipt serialNumbers
         */

        /**
         * Constructs a new TransactionReceipt.
         * @memberof proto
         * @classdesc Represents a TransactionReceipt.
         * @implements ITransactionReceipt
         * @constructor
         * @param {proto.ITransactionReceipt=} [p] Properties to set
         */
        function TransactionReceipt(p) {
            this.serialNumbers = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TransactionReceipt status.
         * @member {proto.ResponseCodeEnum} status
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.status = 0;

        /**
         * TransactionReceipt accountID.
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.accountID = null;

        /**
         * TransactionReceipt fileID.
         * @member {proto.IFileID|null|undefined} fileID
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.fileID = null;

        /**
         * TransactionReceipt contractID.
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.contractID = null;

        /**
         * TransactionReceipt exchangeRate.
         * @member {proto.IExchangeRateSet|null|undefined} exchangeRate
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.exchangeRate = null;

        /**
         * TransactionReceipt topicID.
         * @member {proto.ITopicID|null|undefined} topicID
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.topicID = null;

        /**
         * TransactionReceipt topicSequenceNumber.
         * @member {Long} topicSequenceNumber
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.topicSequenceNumber = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TransactionReceipt topicRunningHash.
         * @member {Uint8Array} topicRunningHash
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.topicRunningHash = $util.newBuffer([]);

        /**
         * TransactionReceipt topicRunningHashVersion.
         * @member {Long} topicRunningHashVersion
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.topicRunningHashVersion = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TransactionReceipt tokenID.
         * @member {proto.ITokenID|null|undefined} tokenID
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.tokenID = null;

        /**
         * TransactionReceipt newTotalSupply.
         * @member {Long} newTotalSupply
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.newTotalSupply = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TransactionReceipt scheduleID.
         * @member {proto.IScheduleID|null|undefined} scheduleID
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.scheduleID = null;

        /**
         * TransactionReceipt scheduledTransactionID.
         * @member {proto.ITransactionID|null|undefined} scheduledTransactionID
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.scheduledTransactionID = null;

        /**
         * TransactionReceipt serialNumbers.
         * @member {Array.<Long>} serialNumbers
         * @memberof proto.TransactionReceipt
         * @instance
         */
        TransactionReceipt.prototype.serialNumbers = $util.emptyArray;

        /**
         * Creates a new TransactionReceipt instance using the specified properties.
         * @function create
         * @memberof proto.TransactionReceipt
         * @static
         * @param {proto.ITransactionReceipt=} [properties] Properties to set
         * @returns {proto.TransactionReceipt} TransactionReceipt instance
         */
        TransactionReceipt.create = function create(properties) {
            return new TransactionReceipt(properties);
        };

        /**
         * Encodes the specified TransactionReceipt message. Does not implicitly {@link proto.TransactionReceipt.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionReceipt
         * @static
         * @param {proto.ITransactionReceipt} m TransactionReceipt message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionReceipt.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.status != null && Object.hasOwnProperty.call(m, "status"))
                w.uint32(8).int32(m.status);
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
            if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                $root.proto.FileID.encode(m.fileID, w.uint32(26).fork()).ldelim();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(34).fork()).ldelim();
            if (m.exchangeRate != null && Object.hasOwnProperty.call(m, "exchangeRate"))
                $root.proto.ExchangeRateSet.encode(m.exchangeRate, w.uint32(42).fork()).ldelim();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
                $root.proto.TopicID.encode(m.topicID, w.uint32(50).fork()).ldelim();
            if (m.topicSequenceNumber != null && Object.hasOwnProperty.call(m, "topicSequenceNumber"))
                w.uint32(56).uint64(m.topicSequenceNumber);
            if (m.topicRunningHash != null && Object.hasOwnProperty.call(m, "topicRunningHash"))
                w.uint32(66).bytes(m.topicRunningHash);
            if (m.topicRunningHashVersion != null && Object.hasOwnProperty.call(m, "topicRunningHashVersion"))
                w.uint32(72).uint64(m.topicRunningHashVersion);
            if (m.tokenID != null && Object.hasOwnProperty.call(m, "tokenID"))
                $root.proto.TokenID.encode(m.tokenID, w.uint32(82).fork()).ldelim();
            if (m.newTotalSupply != null && Object.hasOwnProperty.call(m, "newTotalSupply"))
                w.uint32(88).uint64(m.newTotalSupply);
            if (m.scheduleID != null && Object.hasOwnProperty.call(m, "scheduleID"))
                $root.proto.ScheduleID.encode(m.scheduleID, w.uint32(98).fork()).ldelim();
            if (m.scheduledTransactionID != null && Object.hasOwnProperty.call(m, "scheduledTransactionID"))
                $root.proto.TransactionID.encode(m.scheduledTransactionID, w.uint32(106).fork()).ldelim();
            if (m.serialNumbers != null && m.serialNumbers.length) {
                w.uint32(114).fork();
                for (var i = 0; i < m.serialNumbers.length; ++i)
                    w.int64(m.serialNumbers[i]);
                w.ldelim();
            }
            return w;
        };

        /**
         * Decodes a TransactionReceipt message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionReceipt
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionReceipt} TransactionReceipt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionReceipt.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TransactionReceipt();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.status = r.int32();
                    break;
                case 2:
                    m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 3:
                    m.fileID = $root.proto.FileID.decode(r, r.uint32());
                    break;
                case 4:
                    m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                    break;
                case 5:
                    m.exchangeRate = $root.proto.ExchangeRateSet.decode(r, r.uint32());
                    break;
                case 6:
                    m.topicID = $root.proto.TopicID.decode(r, r.uint32());
                    break;
                case 7:
                    m.topicSequenceNumber = r.uint64();
                    break;
                case 8:
                    m.topicRunningHash = r.bytes();
                    break;
                case 9:
                    m.topicRunningHashVersion = r.uint64();
                    break;
                case 10:
                    m.tokenID = $root.proto.TokenID.decode(r, r.uint32());
                    break;
                case 11:
                    m.newTotalSupply = r.uint64();
                    break;
                case 12:
                    m.scheduleID = $root.proto.ScheduleID.decode(r, r.uint32());
                    break;
                case 13:
                    m.scheduledTransactionID = $root.proto.TransactionID.decode(r, r.uint32());
                    break;
                case 14:
                    if (!(m.serialNumbers && m.serialNumbers.length))
                        m.serialNumbers = [];
                    if ((t & 7) === 2) {
                        var c2 = r.uint32() + r.pos;
                        while (r.pos < c2)
                            m.serialNumbers.push(r.int64());
                    } else
                        m.serialNumbers.push(r.int64());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TransactionReceipt;
    })();

    proto.ExchangeRate = (function() {

        /**
         * Properties of an ExchangeRate.
         * @memberof proto
         * @interface IExchangeRate
         * @property {number|null} [hbarEquiv] ExchangeRate hbarEquiv
         * @property {number|null} [centEquiv] ExchangeRate centEquiv
         * @property {proto.ITimestampSeconds|null} [expirationTime] ExchangeRate expirationTime
         */

        /**
         * Constructs a new ExchangeRate.
         * @memberof proto
         * @classdesc Represents an ExchangeRate.
         * @implements IExchangeRate
         * @constructor
         * @param {proto.IExchangeRate=} [p] Properties to set
         */
        function ExchangeRate(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ExchangeRate hbarEquiv.
         * @member {number} hbarEquiv
         * @memberof proto.ExchangeRate
         * @instance
         */
        ExchangeRate.prototype.hbarEquiv = 0;

        /**
         * ExchangeRate centEquiv.
         * @member {number} centEquiv
         * @memberof proto.ExchangeRate
         * @instance
         */
        ExchangeRate.prototype.centEquiv = 0;

        /**
         * ExchangeRate expirationTime.
         * @member {proto.ITimestampSeconds|null|undefined} expirationTime
         * @memberof proto.ExchangeRate
         * @instance
         */
        ExchangeRate.prototype.expirationTime = null;

        /**
         * Creates a new ExchangeRate instance using the specified properties.
         * @function create
         * @memberof proto.ExchangeRate
         * @static
         * @param {proto.IExchangeRate=} [properties] Properties to set
         * @returns {proto.ExchangeRate} ExchangeRate instance
         */
        ExchangeRate.create = function create(properties) {
            return new ExchangeRate(properties);
        };

        /**
         * Encodes the specified ExchangeRate message. Does not implicitly {@link proto.ExchangeRate.verify|verify} messages.
         * @function encode
         * @memberof proto.ExchangeRate
         * @static
         * @param {proto.IExchangeRate} m ExchangeRate message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExchangeRate.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.hbarEquiv != null && Object.hasOwnProperty.call(m, "hbarEquiv"))
                w.uint32(8).int32(m.hbarEquiv);
            if (m.centEquiv != null && Object.hasOwnProperty.call(m, "centEquiv"))
                w.uint32(16).int32(m.centEquiv);
            if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                $root.proto.TimestampSeconds.encode(m.expirationTime, w.uint32(26).fork()).ldelim();
            return w;
        };

        /**
         * Decodes an ExchangeRate message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ExchangeRate
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ExchangeRate} ExchangeRate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExchangeRate.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ExchangeRate();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.hbarEquiv = r.int32();
                    break;
                case 2:
                    m.centEquiv = r.int32();
                    break;
                case 3:
                    m.expirationTime = $root.proto.TimestampSeconds.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ExchangeRate;
    })();

    proto.ExchangeRateSet = (function() {

        /**
         * Properties of an ExchangeRateSet.
         * @memberof proto
         * @interface IExchangeRateSet
         * @property {proto.IExchangeRate|null} [currentRate] ExchangeRateSet currentRate
         * @property {proto.IExchangeRate|null} [nextRate] ExchangeRateSet nextRate
         */

        /**
         * Constructs a new ExchangeRateSet.
         * @memberof proto
         * @classdesc Represents an ExchangeRateSet.
         * @implements IExchangeRateSet
         * @constructor
         * @param {proto.IExchangeRateSet=} [p] Properties to set
         */
        function ExchangeRateSet(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ExchangeRateSet currentRate.
         * @member {proto.IExchangeRate|null|undefined} currentRate
         * @memberof proto.ExchangeRateSet
         * @instance
         */
        ExchangeRateSet.prototype.currentRate = null;

        /**
         * ExchangeRateSet nextRate.
         * @member {proto.IExchangeRate|null|undefined} nextRate
         * @memberof proto.ExchangeRateSet
         * @instance
         */
        ExchangeRateSet.prototype.nextRate = null;

        /**
         * Creates a new ExchangeRateSet instance using the specified properties.
         * @function create
         * @memberof proto.ExchangeRateSet
         * @static
         * @param {proto.IExchangeRateSet=} [properties] Properties to set
         * @returns {proto.ExchangeRateSet} ExchangeRateSet instance
         */
        ExchangeRateSet.create = function create(properties) {
            return new ExchangeRateSet(properties);
        };

        /**
         * Encodes the specified ExchangeRateSet message. Does not implicitly {@link proto.ExchangeRateSet.verify|verify} messages.
         * @function encode
         * @memberof proto.ExchangeRateSet
         * @static
         * @param {proto.IExchangeRateSet} m ExchangeRateSet message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExchangeRateSet.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.currentRate != null && Object.hasOwnProperty.call(m, "currentRate"))
                $root.proto.ExchangeRate.encode(m.currentRate, w.uint32(10).fork()).ldelim();
            if (m.nextRate != null && Object.hasOwnProperty.call(m, "nextRate"))
                $root.proto.ExchangeRate.encode(m.nextRate, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes an ExchangeRateSet message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ExchangeRateSet
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ExchangeRateSet} ExchangeRateSet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExchangeRateSet.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ExchangeRateSet();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.currentRate = $root.proto.ExchangeRate.decode(r, r.uint32());
                    break;
                case 2:
                    m.nextRate = $root.proto.ExchangeRate.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ExchangeRateSet;
    })();

    proto.CryptoGetAccountBalanceQuery = (function() {

        /**
         * Properties of a CryptoGetAccountBalanceQuery.
         * @memberof proto
         * @interface ICryptoGetAccountBalanceQuery
         * @property {proto.IQueryHeader|null} [header] CryptoGetAccountBalanceQuery header
         * @property {proto.IAccountID|null} [accountID] CryptoGetAccountBalanceQuery accountID
         * @property {proto.IContractID|null} [contractID] CryptoGetAccountBalanceQuery contractID
         */

        /**
         * Constructs a new CryptoGetAccountBalanceQuery.
         * @memberof proto
         * @classdesc Represents a CryptoGetAccountBalanceQuery.
         * @implements ICryptoGetAccountBalanceQuery
         * @constructor
         * @param {proto.ICryptoGetAccountBalanceQuery=} [p] Properties to set
         */
        function CryptoGetAccountBalanceQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * CryptoGetAccountBalanceQuery header.
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.CryptoGetAccountBalanceQuery
         * @instance
         */
        CryptoGetAccountBalanceQuery.prototype.header = null;

        /**
         * CryptoGetAccountBalanceQuery accountID.
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.CryptoGetAccountBalanceQuery
         * @instance
         */
        CryptoGetAccountBalanceQuery.prototype.accountID = null;

        /**
         * CryptoGetAccountBalanceQuery contractID.
         * @member {proto.IContractID|null|undefined} contractID
         * @memberof proto.CryptoGetAccountBalanceQuery
         * @instance
         */
        CryptoGetAccountBalanceQuery.prototype.contractID = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * CryptoGetAccountBalanceQuery balanceSource.
         * @member {"accountID"|"contractID"|undefined} balanceSource
         * @memberof proto.CryptoGetAccountBalanceQuery
         * @instance
         */
        Object.defineProperty(CryptoGetAccountBalanceQuery.prototype, "balanceSource", {
            get: $util.oneOfGetter($oneOfFields = ["accountID", "contractID"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new CryptoGetAccountBalanceQuery instance using the specified properties.
         * @function create
         * @memberof proto.CryptoGetAccountBalanceQuery
         * @static
         * @param {proto.ICryptoGetAccountBalanceQuery=} [properties] Properties to set
         * @returns {proto.CryptoGetAccountBalanceQuery} CryptoGetAccountBalanceQuery instance
         */
        CryptoGetAccountBalanceQuery.create = function create(properties) {
            return new CryptoGetAccountBalanceQuery(properties);
        };

        /**
         * Encodes the specified CryptoGetAccountBalanceQuery message. Does not implicitly {@link proto.CryptoGetAccountBalanceQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoGetAccountBalanceQuery
         * @static
         * @param {proto.ICryptoGetAccountBalanceQuery} m CryptoGetAccountBalanceQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoGetAccountBalanceQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
            if (m.contractID != null && Object.hasOwnProperty.call(m, "contractID"))
                $root.proto.ContractID.encode(m.contractID, w.uint32(26).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a CryptoGetAccountBalanceQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoGetAccountBalanceQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoGetAccountBalanceQuery} CryptoGetAccountBalanceQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoGetAccountBalanceQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoGetAccountBalanceQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 3:
                    m.contractID = $root.proto.ContractID.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return CryptoGetAccountBalanceQuery;
    })();

    proto.CryptoGetAccountBalanceResponse = (function() {

        /**
         * Properties of a CryptoGetAccountBalanceResponse.
         * @memberof proto
         * @interface ICryptoGetAccountBalanceResponse
         * @property {proto.IResponseHeader|null} [header] CryptoGetAccountBalanceResponse header
         * @property {proto.IAccountID|null} [accountID] CryptoGetAccountBalanceResponse accountID
         * @property {Long|null} [balance] CryptoGetAccountBalanceResponse balance
         * @property {Array.<proto.ITokenBalance>|null} [tokenBalances] CryptoGetAccountBalanceResponse tokenBalances
         */

        /**
         * Constructs a new CryptoGetAccountBalanceResponse.
         * @memberof proto
         * @classdesc Represents a CryptoGetAccountBalanceResponse.
         * @implements ICryptoGetAccountBalanceResponse
         * @constructor
         * @param {proto.ICryptoGetAccountBalanceResponse=} [p] Properties to set
         */
        function CryptoGetAccountBalanceResponse(p) {
            this.tokenBalances = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * CryptoGetAccountBalanceResponse header.
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.CryptoGetAccountBalanceResponse
         * @instance
         */
        CryptoGetAccountBalanceResponse.prototype.header = null;

        /**
         * CryptoGetAccountBalanceResponse accountID.
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.CryptoGetAccountBalanceResponse
         * @instance
         */
        CryptoGetAccountBalanceResponse.prototype.accountID = null;

        /**
         * CryptoGetAccountBalanceResponse balance.
         * @member {Long} balance
         * @memberof proto.CryptoGetAccountBalanceResponse
         * @instance
         */
        CryptoGetAccountBalanceResponse.prototype.balance = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * CryptoGetAccountBalanceResponse tokenBalances.
         * @member {Array.<proto.ITokenBalance>} tokenBalances
         * @memberof proto.CryptoGetAccountBalanceResponse
         * @instance
         */
        CryptoGetAccountBalanceResponse.prototype.tokenBalances = $util.emptyArray;

        /**
         * Creates a new CryptoGetAccountBalanceResponse instance using the specified properties.
         * @function create
         * @memberof proto.CryptoGetAccountBalanceResponse
         * @static
         * @param {proto.ICryptoGetAccountBalanceResponse=} [properties] Properties to set
         * @returns {proto.CryptoGetAccountBalanceResponse} CryptoGetAccountBalanceResponse instance
         */
        CryptoGetAccountBalanceResponse.create = function create(properties) {
            return new CryptoGetAccountBalanceResponse(properties);
        };

        /**
         * Encodes the specified CryptoGetAccountBalanceResponse message. Does not implicitly {@link proto.CryptoGetAccountBalanceResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoGetAccountBalanceResponse
         * @static
         * @param {proto.ICryptoGetAccountBalanceResponse} m CryptoGetAccountBalanceResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoGetAccountBalanceResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
            if (m.balance != null && Object.hasOwnProperty.call(m, "balance"))
                w.uint32(24).uint64(m.balance);
            if (m.tokenBalances != null && m.tokenBalances.length) {
                for (var i = 0; i < m.tokenBalances.length; ++i)
                    $root.proto.TokenBalance.encode(m.tokenBalances[i], w.uint32(34).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a CryptoGetAccountBalanceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoGetAccountBalanceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoGetAccountBalanceResponse} CryptoGetAccountBalanceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoGetAccountBalanceResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoGetAccountBalanceResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 3:
                    m.balance = r.uint64();
                    break;
                case 4:
                    if (!(m.tokenBalances && m.tokenBalances.length))
                        m.tokenBalances = [];
                    m.tokenBalances.push($root.proto.TokenBalance.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return CryptoGetAccountBalanceResponse;
    })();

    proto.CryptoGetAccountRecordsQuery = (function() {

        /**
         * Properties of a CryptoGetAccountRecordsQuery.
         * @memberof proto
         * @interface ICryptoGetAccountRecordsQuery
         * @property {proto.IQueryHeader|null} [header] CryptoGetAccountRecordsQuery header
         * @property {proto.IAccountID|null} [accountID] CryptoGetAccountRecordsQuery accountID
         */

        /**
         * Constructs a new CryptoGetAccountRecordsQuery.
         * @memberof proto
         * @classdesc Represents a CryptoGetAccountRecordsQuery.
         * @implements ICryptoGetAccountRecordsQuery
         * @constructor
         * @param {proto.ICryptoGetAccountRecordsQuery=} [p] Properties to set
         */
        function CryptoGetAccountRecordsQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * CryptoGetAccountRecordsQuery header.
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.CryptoGetAccountRecordsQuery
         * @instance
         */
        CryptoGetAccountRecordsQuery.prototype.header = null;

        /**
         * CryptoGetAccountRecordsQuery accountID.
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.CryptoGetAccountRecordsQuery
         * @instance
         */
        CryptoGetAccountRecordsQuery.prototype.accountID = null;

        /**
         * Creates a new CryptoGetAccountRecordsQuery instance using the specified properties.
         * @function create
         * @memberof proto.CryptoGetAccountRecordsQuery
         * @static
         * @param {proto.ICryptoGetAccountRecordsQuery=} [properties] Properties to set
         * @returns {proto.CryptoGetAccountRecordsQuery} CryptoGetAccountRecordsQuery instance
         */
        CryptoGetAccountRecordsQuery.create = function create(properties) {
            return new CryptoGetAccountRecordsQuery(properties);
        };

        /**
         * Encodes the specified CryptoGetAccountRecordsQuery message. Does not implicitly {@link proto.CryptoGetAccountRecordsQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoGetAccountRecordsQuery
         * @static
         * @param {proto.ICryptoGetAccountRecordsQuery} m CryptoGetAccountRecordsQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoGetAccountRecordsQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a CryptoGetAccountRecordsQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoGetAccountRecordsQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoGetAccountRecordsQuery} CryptoGetAccountRecordsQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoGetAccountRecordsQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoGetAccountRecordsQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return CryptoGetAccountRecordsQuery;
    })();

    proto.CryptoGetAccountRecordsResponse = (function() {

        /**
         * Properties of a CryptoGetAccountRecordsResponse.
         * @memberof proto
         * @interface ICryptoGetAccountRecordsResponse
         * @property {proto.IResponseHeader|null} [header] CryptoGetAccountRecordsResponse header
         * @property {proto.IAccountID|null} [accountID] CryptoGetAccountRecordsResponse accountID
         * @property {Array.<proto.ITransactionRecord>|null} [records] CryptoGetAccountRecordsResponse records
         */

        /**
         * Constructs a new CryptoGetAccountRecordsResponse.
         * @memberof proto
         * @classdesc Represents a CryptoGetAccountRecordsResponse.
         * @implements ICryptoGetAccountRecordsResponse
         * @constructor
         * @param {proto.ICryptoGetAccountRecordsResponse=} [p] Properties to set
         */
        function CryptoGetAccountRecordsResponse(p) {
            this.records = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * CryptoGetAccountRecordsResponse header.
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.CryptoGetAccountRecordsResponse
         * @instance
         */
        CryptoGetAccountRecordsResponse.prototype.header = null;

        /**
         * CryptoGetAccountRecordsResponse accountID.
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.CryptoGetAccountRecordsResponse
         * @instance
         */
        CryptoGetAccountRecordsResponse.prototype.accountID = null;

        /**
         * CryptoGetAccountRecordsResponse records.
         * @member {Array.<proto.ITransactionRecord>} records
         * @memberof proto.CryptoGetAccountRecordsResponse
         * @instance
         */
        CryptoGetAccountRecordsResponse.prototype.records = $util.emptyArray;

        /**
         * Creates a new CryptoGetAccountRecordsResponse instance using the specified properties.
         * @function create
         * @memberof proto.CryptoGetAccountRecordsResponse
         * @static
         * @param {proto.ICryptoGetAccountRecordsResponse=} [properties] Properties to set
         * @returns {proto.CryptoGetAccountRecordsResponse} CryptoGetAccountRecordsResponse instance
         */
        CryptoGetAccountRecordsResponse.create = function create(properties) {
            return new CryptoGetAccountRecordsResponse(properties);
        };

        /**
         * Encodes the specified CryptoGetAccountRecordsResponse message. Does not implicitly {@link proto.CryptoGetAccountRecordsResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoGetAccountRecordsResponse
         * @static
         * @param {proto.ICryptoGetAccountRecordsResponse} m CryptoGetAccountRecordsResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoGetAccountRecordsResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
            if (m.records != null && m.records.length) {
                for (var i = 0; i < m.records.length; ++i)
                    $root.proto.TransactionRecord.encode(m.records[i], w.uint32(26).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a CryptoGetAccountRecordsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoGetAccountRecordsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoGetAccountRecordsResponse} CryptoGetAccountRecordsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoGetAccountRecordsResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoGetAccountRecordsResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 3:
                    if (!(m.records && m.records.length))
                        m.records = [];
                    m.records.push($root.proto.TransactionRecord.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return CryptoGetAccountRecordsResponse;
    })();

    proto.CryptoGetInfoQuery = (function() {

        /**
         * Properties of a CryptoGetInfoQuery.
         * @memberof proto
         * @interface ICryptoGetInfoQuery
         * @property {proto.IQueryHeader|null} [header] CryptoGetInfoQuery header
         * @property {proto.IAccountID|null} [accountID] CryptoGetInfoQuery accountID
         */

        /**
         * Constructs a new CryptoGetInfoQuery.
         * @memberof proto
         * @classdesc Represents a CryptoGetInfoQuery.
         * @implements ICryptoGetInfoQuery
         * @constructor
         * @param {proto.ICryptoGetInfoQuery=} [p] Properties to set
         */
        function CryptoGetInfoQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * CryptoGetInfoQuery header.
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.CryptoGetInfoQuery
         * @instance
         */
        CryptoGetInfoQuery.prototype.header = null;

        /**
         * CryptoGetInfoQuery accountID.
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.CryptoGetInfoQuery
         * @instance
         */
        CryptoGetInfoQuery.prototype.accountID = null;

        /**
         * Creates a new CryptoGetInfoQuery instance using the specified properties.
         * @function create
         * @memberof proto.CryptoGetInfoQuery
         * @static
         * @param {proto.ICryptoGetInfoQuery=} [properties] Properties to set
         * @returns {proto.CryptoGetInfoQuery} CryptoGetInfoQuery instance
         */
        CryptoGetInfoQuery.create = function create(properties) {
            return new CryptoGetInfoQuery(properties);
        };

        /**
         * Encodes the specified CryptoGetInfoQuery message. Does not implicitly {@link proto.CryptoGetInfoQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoGetInfoQuery
         * @static
         * @param {proto.ICryptoGetInfoQuery} m CryptoGetInfoQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoGetInfoQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a CryptoGetInfoQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoGetInfoQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoGetInfoQuery} CryptoGetInfoQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoGetInfoQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoGetInfoQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return CryptoGetInfoQuery;
    })();

    proto.CryptoGetInfoResponse = (function() {

        /**
         * Properties of a CryptoGetInfoResponse.
         * @memberof proto
         * @interface ICryptoGetInfoResponse
         * @property {proto.IResponseHeader|null} [header] CryptoGetInfoResponse header
         * @property {proto.CryptoGetInfoResponse.IAccountInfo|null} [accountInfo] CryptoGetInfoResponse accountInfo
         */

        /**
         * Constructs a new CryptoGetInfoResponse.
         * @memberof proto
         * @classdesc Represents a CryptoGetInfoResponse.
         * @implements ICryptoGetInfoResponse
         * @constructor
         * @param {proto.ICryptoGetInfoResponse=} [p] Properties to set
         */
        function CryptoGetInfoResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * CryptoGetInfoResponse header.
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.CryptoGetInfoResponse
         * @instance
         */
        CryptoGetInfoResponse.prototype.header = null;

        /**
         * CryptoGetInfoResponse accountInfo.
         * @member {proto.CryptoGetInfoResponse.IAccountInfo|null|undefined} accountInfo
         * @memberof proto.CryptoGetInfoResponse
         * @instance
         */
        CryptoGetInfoResponse.prototype.accountInfo = null;

        /**
         * Creates a new CryptoGetInfoResponse instance using the specified properties.
         * @function create
         * @memberof proto.CryptoGetInfoResponse
         * @static
         * @param {proto.ICryptoGetInfoResponse=} [properties] Properties to set
         * @returns {proto.CryptoGetInfoResponse} CryptoGetInfoResponse instance
         */
        CryptoGetInfoResponse.create = function create(properties) {
            return new CryptoGetInfoResponse(properties);
        };

        /**
         * Encodes the specified CryptoGetInfoResponse message. Does not implicitly {@link proto.CryptoGetInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoGetInfoResponse
         * @static
         * @param {proto.ICryptoGetInfoResponse} m CryptoGetInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoGetInfoResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.accountInfo != null && Object.hasOwnProperty.call(m, "accountInfo"))
                $root.proto.CryptoGetInfoResponse.AccountInfo.encode(m.accountInfo, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a CryptoGetInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoGetInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoGetInfoResponse} CryptoGetInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoGetInfoResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoGetInfoResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.accountInfo = $root.proto.CryptoGetInfoResponse.AccountInfo.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        CryptoGetInfoResponse.AccountInfo = (function() {

            /**
             * Properties of an AccountInfo.
             * @memberof proto.CryptoGetInfoResponse
             * @interface IAccountInfo
             * @property {proto.IAccountID|null} [accountID] AccountInfo accountID
             * @property {string|null} [contractAccountID] AccountInfo contractAccountID
             * @property {boolean|null} [deleted] AccountInfo deleted
             * @property {proto.IAccountID|null} [proxyAccountID] AccountInfo proxyAccountID
             * @property {Long|null} [proxyReceived] AccountInfo proxyReceived
             * @property {proto.IKey|null} [key] AccountInfo key
             * @property {Long|null} [balance] AccountInfo balance
             * @property {Long|null} [generateSendRecordThreshold] AccountInfo generateSendRecordThreshold
             * @property {Long|null} [generateReceiveRecordThreshold] AccountInfo generateReceiveRecordThreshold
             * @property {boolean|null} [receiverSigRequired] AccountInfo receiverSigRequired
             * @property {proto.ITimestamp|null} [expirationTime] AccountInfo expirationTime
             * @property {proto.IDuration|null} [autoRenewPeriod] AccountInfo autoRenewPeriod
             * @property {Array.<proto.ILiveHash>|null} [liveHashes] AccountInfo liveHashes
             * @property {Array.<proto.ITokenRelationship>|null} [tokenRelationships] AccountInfo tokenRelationships
             * @property {string|null} [memo] AccountInfo memo
             * @property {Long|null} [ownedNfts] AccountInfo ownedNfts
             */

            /**
             * Constructs a new AccountInfo.
             * @memberof proto.CryptoGetInfoResponse
             * @classdesc Represents an AccountInfo.
             * @implements IAccountInfo
             * @constructor
             * @param {proto.CryptoGetInfoResponse.IAccountInfo=} [p] Properties to set
             */
            function AccountInfo(p) {
                this.liveHashes = [];
                this.tokenRelationships = [];
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * AccountInfo accountID.
             * @member {proto.IAccountID|null|undefined} accountID
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.accountID = null;

            /**
             * AccountInfo contractAccountID.
             * @member {string} contractAccountID
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.contractAccountID = "";

            /**
             * AccountInfo deleted.
             * @member {boolean} deleted
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.deleted = false;

            /**
             * AccountInfo proxyAccountID.
             * @member {proto.IAccountID|null|undefined} proxyAccountID
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.proxyAccountID = null;

            /**
             * AccountInfo proxyReceived.
             * @member {Long} proxyReceived
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.proxyReceived = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AccountInfo key.
             * @member {proto.IKey|null|undefined} key
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.key = null;

            /**
             * AccountInfo balance.
             * @member {Long} balance
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.balance = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * AccountInfo generateSendRecordThreshold.
             * @member {Long} generateSendRecordThreshold
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.generateSendRecordThreshold = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * AccountInfo generateReceiveRecordThreshold.
             * @member {Long} generateReceiveRecordThreshold
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.generateReceiveRecordThreshold = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * AccountInfo receiverSigRequired.
             * @member {boolean} receiverSigRequired
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.receiverSigRequired = false;

            /**
             * AccountInfo expirationTime.
             * @member {proto.ITimestamp|null|undefined} expirationTime
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.expirationTime = null;

            /**
             * AccountInfo autoRenewPeriod.
             * @member {proto.IDuration|null|undefined} autoRenewPeriod
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.autoRenewPeriod = null;

            /**
             * AccountInfo liveHashes.
             * @member {Array.<proto.ILiveHash>} liveHashes
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.liveHashes = $util.emptyArray;

            /**
             * AccountInfo tokenRelationships.
             * @member {Array.<proto.ITokenRelationship>} tokenRelationships
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.tokenRelationships = $util.emptyArray;

            /**
             * AccountInfo memo.
             * @member {string} memo
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.memo = "";

            /**
             * AccountInfo ownedNfts.
             * @member {Long} ownedNfts
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @instance
             */
            AccountInfo.prototype.ownedNfts = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new AccountInfo instance using the specified properties.
             * @function create
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @static
             * @param {proto.CryptoGetInfoResponse.IAccountInfo=} [properties] Properties to set
             * @returns {proto.CryptoGetInfoResponse.AccountInfo} AccountInfo instance
             */
            AccountInfo.create = function create(properties) {
                return new AccountInfo(properties);
            };

            /**
             * Encodes the specified AccountInfo message. Does not implicitly {@link proto.CryptoGetInfoResponse.AccountInfo.verify|verify} messages.
             * @function encode
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @static
             * @param {proto.CryptoGetInfoResponse.IAccountInfo} m AccountInfo message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AccountInfo.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                    $root.proto.AccountID.encode(m.accountID, w.uint32(10).fork()).ldelim();
                if (m.contractAccountID != null && Object.hasOwnProperty.call(m, "contractAccountID"))
                    w.uint32(18).string(m.contractAccountID);
                if (m.deleted != null && Object.hasOwnProperty.call(m, "deleted"))
                    w.uint32(24).bool(m.deleted);
                if (m.proxyAccountID != null && Object.hasOwnProperty.call(m, "proxyAccountID"))
                    $root.proto.AccountID.encode(m.proxyAccountID, w.uint32(34).fork()).ldelim();
                if (m.proxyReceived != null && Object.hasOwnProperty.call(m, "proxyReceived"))
                    w.uint32(48).int64(m.proxyReceived);
                if (m.key != null && Object.hasOwnProperty.call(m, "key"))
                    $root.proto.Key.encode(m.key, w.uint32(58).fork()).ldelim();
                if (m.balance != null && Object.hasOwnProperty.call(m, "balance"))
                    w.uint32(64).uint64(m.balance);
                if (m.generateSendRecordThreshold != null && Object.hasOwnProperty.call(m, "generateSendRecordThreshold"))
                    w.uint32(72).uint64(m.generateSendRecordThreshold);
                if (m.generateReceiveRecordThreshold != null && Object.hasOwnProperty.call(m, "generateReceiveRecordThreshold"))
                    w.uint32(80).uint64(m.generateReceiveRecordThreshold);
                if (m.receiverSigRequired != null && Object.hasOwnProperty.call(m, "receiverSigRequired"))
                    w.uint32(88).bool(m.receiverSigRequired);
                if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                    $root.proto.Timestamp.encode(m.expirationTime, w.uint32(98).fork()).ldelim();
                if (m.autoRenewPeriod != null && Object.hasOwnProperty.call(m, "autoRenewPeriod"))
                    $root.proto.Duration.encode(m.autoRenewPeriod, w.uint32(106).fork()).ldelim();
                if (m.liveHashes != null && m.liveHashes.length) {
                    for (var i = 0; i < m.liveHashes.length; ++i)
                        $root.proto.LiveHash.encode(m.liveHashes[i], w.uint32(114).fork()).ldelim();
                }
                if (m.tokenRelationships != null && m.tokenRelationships.length) {
                    for (var i = 0; i < m.tokenRelationships.length; ++i)
                        $root.proto.TokenRelationship.encode(m.tokenRelationships[i], w.uint32(122).fork()).ldelim();
                }
                if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                    w.uint32(130).string(m.memo);
                if (m.ownedNfts != null && Object.hasOwnProperty.call(m, "ownedNfts"))
                    w.uint32(136).int64(m.ownedNfts);
                return w;
            };

            /**
             * Decodes an AccountInfo message from the specified reader or buffer.
             * @function decode
             * @memberof proto.CryptoGetInfoResponse.AccountInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {proto.CryptoGetInfoResponse.AccountInfo} AccountInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AccountInfo.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoGetInfoResponse.AccountInfo();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    case 2:
                        m.contractAccountID = r.string();
                        break;
                    case 3:
                        m.deleted = r.bool();
                        break;
                    case 4:
                        m.proxyAccountID = $root.proto.AccountID.decode(r, r.uint32());
                        break;
                    case 6:
                        m.proxyReceived = r.int64();
                        break;
                    case 7:
                        m.key = $root.proto.Key.decode(r, r.uint32());
                        break;
                    case 8:
                        m.balance = r.uint64();
                        break;
                    case 9:
                        m.generateSendRecordThreshold = r.uint64();
                        break;
                    case 10:
                        m.generateReceiveRecordThreshold = r.uint64();
                        break;
                    case 11:
                        m.receiverSigRequired = r.bool();
                        break;
                    case 12:
                        m.expirationTime = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    case 13:
                        m.autoRenewPeriod = $root.proto.Duration.decode(r, r.uint32());
                        break;
                    case 14:
                        if (!(m.liveHashes && m.liveHashes.length))
                            m.liveHashes = [];
                        m.liveHashes.push($root.proto.LiveHash.decode(r, r.uint32()));
                        break;
                    case 15:
                        if (!(m.tokenRelationships && m.tokenRelationships.length))
                            m.tokenRelationships = [];
                        m.tokenRelationships.push($root.proto.TokenRelationship.decode(r, r.uint32()));
                        break;
                    case 16:
                        m.memo = r.string();
                        break;
                    case 17:
                        m.ownedNfts = r.int64();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return AccountInfo;
        })();

        return CryptoGetInfoResponse;
    })();

    proto.CryptoGetLiveHashQuery = (function() {

        /**
         * Properties of a CryptoGetLiveHashQuery.
         * @memberof proto
         * @interface ICryptoGetLiveHashQuery
         * @property {proto.IQueryHeader|null} [header] CryptoGetLiveHashQuery header
         * @property {proto.IAccountID|null} [accountID] CryptoGetLiveHashQuery accountID
         * @property {Uint8Array|null} [hash] CryptoGetLiveHashQuery hash
         */

        /**
         * Constructs a new CryptoGetLiveHashQuery.
         * @memberof proto
         * @classdesc Represents a CryptoGetLiveHashQuery.
         * @implements ICryptoGetLiveHashQuery
         * @constructor
         * @param {proto.ICryptoGetLiveHashQuery=} [p] Properties to set
         */
        function CryptoGetLiveHashQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * CryptoGetLiveHashQuery header.
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.CryptoGetLiveHashQuery
         * @instance
         */
        CryptoGetLiveHashQuery.prototype.header = null;

        /**
         * CryptoGetLiveHashQuery accountID.
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.CryptoGetLiveHashQuery
         * @instance
         */
        CryptoGetLiveHashQuery.prototype.accountID = null;

        /**
         * CryptoGetLiveHashQuery hash.
         * @member {Uint8Array} hash
         * @memberof proto.CryptoGetLiveHashQuery
         * @instance
         */
        CryptoGetLiveHashQuery.prototype.hash = $util.newBuffer([]);

        /**
         * Creates a new CryptoGetLiveHashQuery instance using the specified properties.
         * @function create
         * @memberof proto.CryptoGetLiveHashQuery
         * @static
         * @param {proto.ICryptoGetLiveHashQuery=} [properties] Properties to set
         * @returns {proto.CryptoGetLiveHashQuery} CryptoGetLiveHashQuery instance
         */
        CryptoGetLiveHashQuery.create = function create(properties) {
            return new CryptoGetLiveHashQuery(properties);
        };

        /**
         * Encodes the specified CryptoGetLiveHashQuery message. Does not implicitly {@link proto.CryptoGetLiveHashQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoGetLiveHashQuery
         * @static
         * @param {proto.ICryptoGetLiveHashQuery} m CryptoGetLiveHashQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoGetLiveHashQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
            if (m.hash != null && Object.hasOwnProperty.call(m, "hash"))
                w.uint32(26).bytes(m.hash);
            return w;
        };

        /**
         * Decodes a CryptoGetLiveHashQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoGetLiveHashQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoGetLiveHashQuery} CryptoGetLiveHashQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoGetLiveHashQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoGetLiveHashQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 3:
                    m.hash = r.bytes();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return CryptoGetLiveHashQuery;
    })();

    proto.CryptoGetLiveHashResponse = (function() {

        /**
         * Properties of a CryptoGetLiveHashResponse.
         * @memberof proto
         * @interface ICryptoGetLiveHashResponse
         * @property {proto.IResponseHeader|null} [header] CryptoGetLiveHashResponse header
         * @property {proto.ILiveHash|null} [liveHash] CryptoGetLiveHashResponse liveHash
         */

        /**
         * Constructs a new CryptoGetLiveHashResponse.
         * @memberof proto
         * @classdesc Represents a CryptoGetLiveHashResponse.
         * @implements ICryptoGetLiveHashResponse
         * @constructor
         * @param {proto.ICryptoGetLiveHashResponse=} [p] Properties to set
         */
        function CryptoGetLiveHashResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * CryptoGetLiveHashResponse header.
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.CryptoGetLiveHashResponse
         * @instance
         */
        CryptoGetLiveHashResponse.prototype.header = null;

        /**
         * CryptoGetLiveHashResponse liveHash.
         * @member {proto.ILiveHash|null|undefined} liveHash
         * @memberof proto.CryptoGetLiveHashResponse
         * @instance
         */
        CryptoGetLiveHashResponse.prototype.liveHash = null;

        /**
         * Creates a new CryptoGetLiveHashResponse instance using the specified properties.
         * @function create
         * @memberof proto.CryptoGetLiveHashResponse
         * @static
         * @param {proto.ICryptoGetLiveHashResponse=} [properties] Properties to set
         * @returns {proto.CryptoGetLiveHashResponse} CryptoGetLiveHashResponse instance
         */
        CryptoGetLiveHashResponse.create = function create(properties) {
            return new CryptoGetLiveHashResponse(properties);
        };

        /**
         * Encodes the specified CryptoGetLiveHashResponse message. Does not implicitly {@link proto.CryptoGetLiveHashResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoGetLiveHashResponse
         * @static
         * @param {proto.ICryptoGetLiveHashResponse} m CryptoGetLiveHashResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoGetLiveHashResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.liveHash != null && Object.hasOwnProperty.call(m, "liveHash"))
                $root.proto.LiveHash.encode(m.liveHash, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a CryptoGetLiveHashResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoGetLiveHashResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoGetLiveHashResponse} CryptoGetLiveHashResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoGetLiveHashResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoGetLiveHashResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.liveHash = $root.proto.LiveHash.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return CryptoGetLiveHashResponse;
    })();

    proto.CryptoGetStakersQuery = (function() {

        /**
         * Properties of a CryptoGetStakersQuery.
         * @memberof proto
         * @interface ICryptoGetStakersQuery
         * @property {proto.IQueryHeader|null} [header] CryptoGetStakersQuery header
         * @property {proto.IAccountID|null} [accountID] CryptoGetStakersQuery accountID
         */

        /**
         * Constructs a new CryptoGetStakersQuery.
         * @memberof proto
         * @classdesc Represents a CryptoGetStakersQuery.
         * @implements ICryptoGetStakersQuery
         * @constructor
         * @param {proto.ICryptoGetStakersQuery=} [p] Properties to set
         */
        function CryptoGetStakersQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * CryptoGetStakersQuery header.
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.CryptoGetStakersQuery
         * @instance
         */
        CryptoGetStakersQuery.prototype.header = null;

        /**
         * CryptoGetStakersQuery accountID.
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.CryptoGetStakersQuery
         * @instance
         */
        CryptoGetStakersQuery.prototype.accountID = null;

        /**
         * Creates a new CryptoGetStakersQuery instance using the specified properties.
         * @function create
         * @memberof proto.CryptoGetStakersQuery
         * @static
         * @param {proto.ICryptoGetStakersQuery=} [properties] Properties to set
         * @returns {proto.CryptoGetStakersQuery} CryptoGetStakersQuery instance
         */
        CryptoGetStakersQuery.create = function create(properties) {
            return new CryptoGetStakersQuery(properties);
        };

        /**
         * Encodes the specified CryptoGetStakersQuery message. Does not implicitly {@link proto.CryptoGetStakersQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoGetStakersQuery
         * @static
         * @param {proto.ICryptoGetStakersQuery} m CryptoGetStakersQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoGetStakersQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a CryptoGetStakersQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoGetStakersQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoGetStakersQuery} CryptoGetStakersQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoGetStakersQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoGetStakersQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return CryptoGetStakersQuery;
    })();

    proto.ProxyStaker = (function() {

        /**
         * Properties of a ProxyStaker.
         * @memberof proto
         * @interface IProxyStaker
         * @property {proto.IAccountID|null} [accountID] ProxyStaker accountID
         * @property {Long|null} [amount] ProxyStaker amount
         */

        /**
         * Constructs a new ProxyStaker.
         * @memberof proto
         * @classdesc Represents a ProxyStaker.
         * @implements IProxyStaker
         * @constructor
         * @param {proto.IProxyStaker=} [p] Properties to set
         */
        function ProxyStaker(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ProxyStaker accountID.
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.ProxyStaker
         * @instance
         */
        ProxyStaker.prototype.accountID = null;

        /**
         * ProxyStaker amount.
         * @member {Long} amount
         * @memberof proto.ProxyStaker
         * @instance
         */
        ProxyStaker.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ProxyStaker instance using the specified properties.
         * @function create
         * @memberof proto.ProxyStaker
         * @static
         * @param {proto.IProxyStaker=} [properties] Properties to set
         * @returns {proto.ProxyStaker} ProxyStaker instance
         */
        ProxyStaker.create = function create(properties) {
            return new ProxyStaker(properties);
        };

        /**
         * Encodes the specified ProxyStaker message. Does not implicitly {@link proto.ProxyStaker.verify|verify} messages.
         * @function encode
         * @memberof proto.ProxyStaker
         * @static
         * @param {proto.IProxyStaker} m ProxyStaker message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProxyStaker.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(10).fork()).ldelim();
            if (m.amount != null && Object.hasOwnProperty.call(m, "amount"))
                w.uint32(16).int64(m.amount);
            return w;
        };

        /**
         * Decodes a ProxyStaker message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ProxyStaker
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ProxyStaker} ProxyStaker
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProxyStaker.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ProxyStaker();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 2:
                    m.amount = r.int64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ProxyStaker;
    })();

    proto.AllProxyStakers = (function() {

        /**
         * Properties of an AllProxyStakers.
         * @memberof proto
         * @interface IAllProxyStakers
         * @property {proto.IAccountID|null} [accountID] AllProxyStakers accountID
         * @property {Array.<proto.IProxyStaker>|null} [proxyStaker] AllProxyStakers proxyStaker
         */

        /**
         * Constructs a new AllProxyStakers.
         * @memberof proto
         * @classdesc Represents an AllProxyStakers.
         * @implements IAllProxyStakers
         * @constructor
         * @param {proto.IAllProxyStakers=} [p] Properties to set
         */
        function AllProxyStakers(p) {
            this.proxyStaker = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * AllProxyStakers accountID.
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.AllProxyStakers
         * @instance
         */
        AllProxyStakers.prototype.accountID = null;

        /**
         * AllProxyStakers proxyStaker.
         * @member {Array.<proto.IProxyStaker>} proxyStaker
         * @memberof proto.AllProxyStakers
         * @instance
         */
        AllProxyStakers.prototype.proxyStaker = $util.emptyArray;

        /**
         * Creates a new AllProxyStakers instance using the specified properties.
         * @function create
         * @memberof proto.AllProxyStakers
         * @static
         * @param {proto.IAllProxyStakers=} [properties] Properties to set
         * @returns {proto.AllProxyStakers} AllProxyStakers instance
         */
        AllProxyStakers.create = function create(properties) {
            return new AllProxyStakers(properties);
        };

        /**
         * Encodes the specified AllProxyStakers message. Does not implicitly {@link proto.AllProxyStakers.verify|verify} messages.
         * @function encode
         * @memberof proto.AllProxyStakers
         * @static
         * @param {proto.IAllProxyStakers} m AllProxyStakers message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AllProxyStakers.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(10).fork()).ldelim();
            if (m.proxyStaker != null && m.proxyStaker.length) {
                for (var i = 0; i < m.proxyStaker.length; ++i)
                    $root.proto.ProxyStaker.encode(m.proxyStaker[i], w.uint32(18).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes an AllProxyStakers message from the specified reader or buffer.
         * @function decode
         * @memberof proto.AllProxyStakers
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.AllProxyStakers} AllProxyStakers
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AllProxyStakers.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.AllProxyStakers();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 2:
                    if (!(m.proxyStaker && m.proxyStaker.length))
                        m.proxyStaker = [];
                    m.proxyStaker.push($root.proto.ProxyStaker.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return AllProxyStakers;
    })();

    proto.CryptoGetStakersResponse = (function() {

        /**
         * Properties of a CryptoGetStakersResponse.
         * @memberof proto
         * @interface ICryptoGetStakersResponse
         * @property {proto.IResponseHeader|null} [header] CryptoGetStakersResponse header
         * @property {proto.IAllProxyStakers|null} [stakers] CryptoGetStakersResponse stakers
         */

        /**
         * Constructs a new CryptoGetStakersResponse.
         * @memberof proto
         * @classdesc Represents a CryptoGetStakersResponse.
         * @implements ICryptoGetStakersResponse
         * @constructor
         * @param {proto.ICryptoGetStakersResponse=} [p] Properties to set
         */
        function CryptoGetStakersResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * CryptoGetStakersResponse header.
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.CryptoGetStakersResponse
         * @instance
         */
        CryptoGetStakersResponse.prototype.header = null;

        /**
         * CryptoGetStakersResponse stakers.
         * @member {proto.IAllProxyStakers|null|undefined} stakers
         * @memberof proto.CryptoGetStakersResponse
         * @instance
         */
        CryptoGetStakersResponse.prototype.stakers = null;

        /**
         * Creates a new CryptoGetStakersResponse instance using the specified properties.
         * @function create
         * @memberof proto.CryptoGetStakersResponse
         * @static
         * @param {proto.ICryptoGetStakersResponse=} [properties] Properties to set
         * @returns {proto.CryptoGetStakersResponse} CryptoGetStakersResponse instance
         */
        CryptoGetStakersResponse.create = function create(properties) {
            return new CryptoGetStakersResponse(properties);
        };

        /**
         * Encodes the specified CryptoGetStakersResponse message. Does not implicitly {@link proto.CryptoGetStakersResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoGetStakersResponse
         * @static
         * @param {proto.ICryptoGetStakersResponse} m CryptoGetStakersResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoGetStakersResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.stakers != null && Object.hasOwnProperty.call(m, "stakers"))
                $root.proto.AllProxyStakers.encode(m.stakers, w.uint32(26).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a CryptoGetStakersResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoGetStakersResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoGetStakersResponse} CryptoGetStakersResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoGetStakersResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoGetStakersResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                    break;
                case 3:
                    m.stakers = $root.proto.AllProxyStakers.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return CryptoGetStakersResponse;
    })();

    proto.FileGetContentsQuery = (function() {

        /**
         * Properties of a FileGetContentsQuery.
         * @memberof proto
         * @interface IFileGetContentsQuery
         * @property {proto.IQueryHeader|null} [header] FileGetContentsQuery header
         * @property {proto.IFileID|null} [fileID] FileGetContentsQuery fileID
         */

        /**
         * Constructs a new FileGetContentsQuery.
         * @memberof proto
         * @classdesc Represents a FileGetContentsQuery.
         * @implements IFileGetContentsQuery
         * @constructor
         * @param {proto.IFileGetContentsQuery=} [p] Properties to set
         */
        function FileGetContentsQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * FileGetContentsQuery header.
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.FileGetContentsQuery
         * @instance
         */
        FileGetContentsQuery.prototype.header = null;

        /**
         * FileGetContentsQuery fileID.
         * @member {proto.IFileID|null|undefined} fileID
         * @memberof proto.FileGetContentsQuery
         * @instance
         */
        FileGetContentsQuery.prototype.fileID = null;

        /**
         * Creates a new FileGetContentsQuery instance using the specified properties.
         * @function create
         * @memberof proto.FileGetContentsQuery
         * @static
         * @param {proto.IFileGetContentsQuery=} [properties] Properties to set
         * @returns {proto.FileGetContentsQuery} FileGetContentsQuery instance
         */
        FileGetContentsQuery.create = function create(properties) {
            return new FileGetContentsQuery(properties);
        };

        /**
         * Encodes the specified FileGetContentsQuery message. Does not implicitly {@link proto.FileGetContentsQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.FileGetContentsQuery
         * @static
         * @param {proto.IFileGetContentsQuery} m FileGetContentsQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileGetContentsQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                $root.proto.FileID.encode(m.fileID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a FileGetContentsQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileGetContentsQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FileGetContentsQuery} FileGetContentsQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileGetContentsQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.FileGetContentsQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.fileID = $root.proto.FileID.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return FileGetContentsQuery;
    })();

    proto.FileGetContentsResponse = (function() {

        /**
         * Properties of a FileGetContentsResponse.
         * @memberof proto
         * @interface IFileGetContentsResponse
         * @property {proto.IResponseHeader|null} [header] FileGetContentsResponse header
         * @property {proto.FileGetContentsResponse.IFileContents|null} [fileContents] FileGetContentsResponse fileContents
         */

        /**
         * Constructs a new FileGetContentsResponse.
         * @memberof proto
         * @classdesc Represents a FileGetContentsResponse.
         * @implements IFileGetContentsResponse
         * @constructor
         * @param {proto.IFileGetContentsResponse=} [p] Properties to set
         */
        function FileGetContentsResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * FileGetContentsResponse header.
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.FileGetContentsResponse
         * @instance
         */
        FileGetContentsResponse.prototype.header = null;

        /**
         * FileGetContentsResponse fileContents.
         * @member {proto.FileGetContentsResponse.IFileContents|null|undefined} fileContents
         * @memberof proto.FileGetContentsResponse
         * @instance
         */
        FileGetContentsResponse.prototype.fileContents = null;

        /**
         * Creates a new FileGetContentsResponse instance using the specified properties.
         * @function create
         * @memberof proto.FileGetContentsResponse
         * @static
         * @param {proto.IFileGetContentsResponse=} [properties] Properties to set
         * @returns {proto.FileGetContentsResponse} FileGetContentsResponse instance
         */
        FileGetContentsResponse.create = function create(properties) {
            return new FileGetContentsResponse(properties);
        };

        /**
         * Encodes the specified FileGetContentsResponse message. Does not implicitly {@link proto.FileGetContentsResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.FileGetContentsResponse
         * @static
         * @param {proto.IFileGetContentsResponse} m FileGetContentsResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileGetContentsResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.fileContents != null && Object.hasOwnProperty.call(m, "fileContents"))
                $root.proto.FileGetContentsResponse.FileContents.encode(m.fileContents, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a FileGetContentsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileGetContentsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FileGetContentsResponse} FileGetContentsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileGetContentsResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.FileGetContentsResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.fileContents = $root.proto.FileGetContentsResponse.FileContents.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        FileGetContentsResponse.FileContents = (function() {

            /**
             * Properties of a FileContents.
             * @memberof proto.FileGetContentsResponse
             * @interface IFileContents
             * @property {proto.IFileID|null} [fileID] FileContents fileID
             * @property {Uint8Array|null} [contents] FileContents contents
             */

            /**
             * Constructs a new FileContents.
             * @memberof proto.FileGetContentsResponse
             * @classdesc Represents a FileContents.
             * @implements IFileContents
             * @constructor
             * @param {proto.FileGetContentsResponse.IFileContents=} [p] Properties to set
             */
            function FileContents(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * FileContents fileID.
             * @member {proto.IFileID|null|undefined} fileID
             * @memberof proto.FileGetContentsResponse.FileContents
             * @instance
             */
            FileContents.prototype.fileID = null;

            /**
             * FileContents contents.
             * @member {Uint8Array} contents
             * @memberof proto.FileGetContentsResponse.FileContents
             * @instance
             */
            FileContents.prototype.contents = $util.newBuffer([]);

            /**
             * Creates a new FileContents instance using the specified properties.
             * @function create
             * @memberof proto.FileGetContentsResponse.FileContents
             * @static
             * @param {proto.FileGetContentsResponse.IFileContents=} [properties] Properties to set
             * @returns {proto.FileGetContentsResponse.FileContents} FileContents instance
             */
            FileContents.create = function create(properties) {
                return new FileContents(properties);
            };

            /**
             * Encodes the specified FileContents message. Does not implicitly {@link proto.FileGetContentsResponse.FileContents.verify|verify} messages.
             * @function encode
             * @memberof proto.FileGetContentsResponse.FileContents
             * @static
             * @param {proto.FileGetContentsResponse.IFileContents} m FileContents message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileContents.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                    $root.proto.FileID.encode(m.fileID, w.uint32(10).fork()).ldelim();
                if (m.contents != null && Object.hasOwnProperty.call(m, "contents"))
                    w.uint32(18).bytes(m.contents);
                return w;
            };

            /**
             * Decodes a FileContents message from the specified reader or buffer.
             * @function decode
             * @memberof proto.FileGetContentsResponse.FileContents
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {proto.FileGetContentsResponse.FileContents} FileContents
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileContents.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.FileGetContentsResponse.FileContents();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.fileID = $root.proto.FileID.decode(r, r.uint32());
                        break;
                    case 2:
                        m.contents = r.bytes();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return FileContents;
        })();

        return FileGetContentsResponse;
    })();

    proto.FileGetInfoQuery = (function() {

        /**
         * Properties of a FileGetInfoQuery.
         * @memberof proto
         * @interface IFileGetInfoQuery
         * @property {proto.IQueryHeader|null} [header] FileGetInfoQuery header
         * @property {proto.IFileID|null} [fileID] FileGetInfoQuery fileID
         */

        /**
         * Constructs a new FileGetInfoQuery.
         * @memberof proto
         * @classdesc Represents a FileGetInfoQuery.
         * @implements IFileGetInfoQuery
         * @constructor
         * @param {proto.IFileGetInfoQuery=} [p] Properties to set
         */
        function FileGetInfoQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * FileGetInfoQuery header.
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.FileGetInfoQuery
         * @instance
         */
        FileGetInfoQuery.prototype.header = null;

        /**
         * FileGetInfoQuery fileID.
         * @member {proto.IFileID|null|undefined} fileID
         * @memberof proto.FileGetInfoQuery
         * @instance
         */
        FileGetInfoQuery.prototype.fileID = null;

        /**
         * Creates a new FileGetInfoQuery instance using the specified properties.
         * @function create
         * @memberof proto.FileGetInfoQuery
         * @static
         * @param {proto.IFileGetInfoQuery=} [properties] Properties to set
         * @returns {proto.FileGetInfoQuery} FileGetInfoQuery instance
         */
        FileGetInfoQuery.create = function create(properties) {
            return new FileGetInfoQuery(properties);
        };

        /**
         * Encodes the specified FileGetInfoQuery message. Does not implicitly {@link proto.FileGetInfoQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.FileGetInfoQuery
         * @static
         * @param {proto.IFileGetInfoQuery} m FileGetInfoQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileGetInfoQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                $root.proto.FileID.encode(m.fileID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a FileGetInfoQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileGetInfoQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FileGetInfoQuery} FileGetInfoQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileGetInfoQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.FileGetInfoQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.fileID = $root.proto.FileID.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return FileGetInfoQuery;
    })();

    proto.FileGetInfoResponse = (function() {

        /**
         * Properties of a FileGetInfoResponse.
         * @memberof proto
         * @interface IFileGetInfoResponse
         * @property {proto.IResponseHeader|null} [header] FileGetInfoResponse header
         * @property {proto.FileGetInfoResponse.IFileInfo|null} [fileInfo] FileGetInfoResponse fileInfo
         */

        /**
         * Constructs a new FileGetInfoResponse.
         * @memberof proto
         * @classdesc Represents a FileGetInfoResponse.
         * @implements IFileGetInfoResponse
         * @constructor
         * @param {proto.IFileGetInfoResponse=} [p] Properties to set
         */
        function FileGetInfoResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * FileGetInfoResponse header.
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.FileGetInfoResponse
         * @instance
         */
        FileGetInfoResponse.prototype.header = null;

        /**
         * FileGetInfoResponse fileInfo.
         * @member {proto.FileGetInfoResponse.IFileInfo|null|undefined} fileInfo
         * @memberof proto.FileGetInfoResponse
         * @instance
         */
        FileGetInfoResponse.prototype.fileInfo = null;

        /**
         * Creates a new FileGetInfoResponse instance using the specified properties.
         * @function create
         * @memberof proto.FileGetInfoResponse
         * @static
         * @param {proto.IFileGetInfoResponse=} [properties] Properties to set
         * @returns {proto.FileGetInfoResponse} FileGetInfoResponse instance
         */
        FileGetInfoResponse.create = function create(properties) {
            return new FileGetInfoResponse(properties);
        };

        /**
         * Encodes the specified FileGetInfoResponse message. Does not implicitly {@link proto.FileGetInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.FileGetInfoResponse
         * @static
         * @param {proto.IFileGetInfoResponse} m FileGetInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileGetInfoResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.fileInfo != null && Object.hasOwnProperty.call(m, "fileInfo"))
                $root.proto.FileGetInfoResponse.FileInfo.encode(m.fileInfo, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a FileGetInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FileGetInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FileGetInfoResponse} FileGetInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileGetInfoResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.FileGetInfoResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.fileInfo = $root.proto.FileGetInfoResponse.FileInfo.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        FileGetInfoResponse.FileInfo = (function() {

            /**
             * Properties of a FileInfo.
             * @memberof proto.FileGetInfoResponse
             * @interface IFileInfo
             * @property {proto.IFileID|null} [fileID] FileInfo fileID
             * @property {Long|null} [size] FileInfo size
             * @property {proto.ITimestamp|null} [expirationTime] FileInfo expirationTime
             * @property {boolean|null} [deleted] FileInfo deleted
             * @property {proto.IKeyList|null} [keys] FileInfo keys
             * @property {string|null} [memo] FileInfo memo
             */

            /**
             * Constructs a new FileInfo.
             * @memberof proto.FileGetInfoResponse
             * @classdesc Represents a FileInfo.
             * @implements IFileInfo
             * @constructor
             * @param {proto.FileGetInfoResponse.IFileInfo=} [p] Properties to set
             */
            function FileInfo(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * FileInfo fileID.
             * @member {proto.IFileID|null|undefined} fileID
             * @memberof proto.FileGetInfoResponse.FileInfo
             * @instance
             */
            FileInfo.prototype.fileID = null;

            /**
             * FileInfo size.
             * @member {Long} size
             * @memberof proto.FileGetInfoResponse.FileInfo
             * @instance
             */
            FileInfo.prototype.size = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * FileInfo expirationTime.
             * @member {proto.ITimestamp|null|undefined} expirationTime
             * @memberof proto.FileGetInfoResponse.FileInfo
             * @instance
             */
            FileInfo.prototype.expirationTime = null;

            /**
             * FileInfo deleted.
             * @member {boolean} deleted
             * @memberof proto.FileGetInfoResponse.FileInfo
             * @instance
             */
            FileInfo.prototype.deleted = false;

            /**
             * FileInfo keys.
             * @member {proto.IKeyList|null|undefined} keys
             * @memberof proto.FileGetInfoResponse.FileInfo
             * @instance
             */
            FileInfo.prototype.keys = null;

            /**
             * FileInfo memo.
             * @member {string} memo
             * @memberof proto.FileGetInfoResponse.FileInfo
             * @instance
             */
            FileInfo.prototype.memo = "";

            /**
             * Creates a new FileInfo instance using the specified properties.
             * @function create
             * @memberof proto.FileGetInfoResponse.FileInfo
             * @static
             * @param {proto.FileGetInfoResponse.IFileInfo=} [properties] Properties to set
             * @returns {proto.FileGetInfoResponse.FileInfo} FileInfo instance
             */
            FileInfo.create = function create(properties) {
                return new FileInfo(properties);
            };

            /**
             * Encodes the specified FileInfo message. Does not implicitly {@link proto.FileGetInfoResponse.FileInfo.verify|verify} messages.
             * @function encode
             * @memberof proto.FileGetInfoResponse.FileInfo
             * @static
             * @param {proto.FileGetInfoResponse.IFileInfo} m FileInfo message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileInfo.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.fileID != null && Object.hasOwnProperty.call(m, "fileID"))
                    $root.proto.FileID.encode(m.fileID, w.uint32(10).fork()).ldelim();
                if (m.size != null && Object.hasOwnProperty.call(m, "size"))
                    w.uint32(16).int64(m.size);
                if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                    $root.proto.Timestamp.encode(m.expirationTime, w.uint32(26).fork()).ldelim();
                if (m.deleted != null && Object.hasOwnProperty.call(m, "deleted"))
                    w.uint32(32).bool(m.deleted);
                if (m.keys != null && Object.hasOwnProperty.call(m, "keys"))
                    $root.proto.KeyList.encode(m.keys, w.uint32(42).fork()).ldelim();
                if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                    w.uint32(50).string(m.memo);
                return w;
            };

            /**
             * Decodes a FileInfo message from the specified reader or buffer.
             * @function decode
             * @memberof proto.FileGetInfoResponse.FileInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {proto.FileGetInfoResponse.FileInfo} FileInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileInfo.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.FileGetInfoResponse.FileInfo();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.fileID = $root.proto.FileID.decode(r, r.uint32());
                        break;
                    case 2:
                        m.size = r.int64();
                        break;
                    case 3:
                        m.expirationTime = $root.proto.Timestamp.decode(r, r.uint32());
                        break;
                    case 4:
                        m.deleted = r.bool();
                        break;
                    case 5:
                        m.keys = $root.proto.KeyList.decode(r, r.uint32());
                        break;
                    case 6:
                        m.memo = r.string();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return FileInfo;
        })();

        return FileGetInfoResponse;
    })();

    proto.TransactionGetReceiptQuery = (function() {

        /**
         * Properties of a TransactionGetReceiptQuery.
         * @memberof proto
         * @interface ITransactionGetReceiptQuery
         * @property {proto.IQueryHeader|null} [header] TransactionGetReceiptQuery header
         * @property {proto.ITransactionID|null} [transactionID] TransactionGetReceiptQuery transactionID
         * @property {boolean|null} [includeDuplicates] TransactionGetReceiptQuery includeDuplicates
         */

        /**
         * Constructs a new TransactionGetReceiptQuery.
         * @memberof proto
         * @classdesc Represents a TransactionGetReceiptQuery.
         * @implements ITransactionGetReceiptQuery
         * @constructor
         * @param {proto.ITransactionGetReceiptQuery=} [p] Properties to set
         */
        function TransactionGetReceiptQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TransactionGetReceiptQuery header.
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.TransactionGetReceiptQuery
         * @instance
         */
        TransactionGetReceiptQuery.prototype.header = null;

        /**
         * TransactionGetReceiptQuery transactionID.
         * @member {proto.ITransactionID|null|undefined} transactionID
         * @memberof proto.TransactionGetReceiptQuery
         * @instance
         */
        TransactionGetReceiptQuery.prototype.transactionID = null;

        /**
         * TransactionGetReceiptQuery includeDuplicates.
         * @member {boolean} includeDuplicates
         * @memberof proto.TransactionGetReceiptQuery
         * @instance
         */
        TransactionGetReceiptQuery.prototype.includeDuplicates = false;

        /**
         * Creates a new TransactionGetReceiptQuery instance using the specified properties.
         * @function create
         * @memberof proto.TransactionGetReceiptQuery
         * @static
         * @param {proto.ITransactionGetReceiptQuery=} [properties] Properties to set
         * @returns {proto.TransactionGetReceiptQuery} TransactionGetReceiptQuery instance
         */
        TransactionGetReceiptQuery.create = function create(properties) {
            return new TransactionGetReceiptQuery(properties);
        };

        /**
         * Encodes the specified TransactionGetReceiptQuery message. Does not implicitly {@link proto.TransactionGetReceiptQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionGetReceiptQuery
         * @static
         * @param {proto.ITransactionGetReceiptQuery} m TransactionGetReceiptQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionGetReceiptQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.transactionID != null && Object.hasOwnProperty.call(m, "transactionID"))
                $root.proto.TransactionID.encode(m.transactionID, w.uint32(18).fork()).ldelim();
            if (m.includeDuplicates != null && Object.hasOwnProperty.call(m, "includeDuplicates"))
                w.uint32(24).bool(m.includeDuplicates);
            return w;
        };

        /**
         * Decodes a TransactionGetReceiptQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionGetReceiptQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionGetReceiptQuery} TransactionGetReceiptQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionGetReceiptQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TransactionGetReceiptQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.transactionID = $root.proto.TransactionID.decode(r, r.uint32());
                    break;
                case 3:
                    m.includeDuplicates = r.bool();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TransactionGetReceiptQuery;
    })();

    proto.TransactionGetReceiptResponse = (function() {

        /**
         * Properties of a TransactionGetReceiptResponse.
         * @memberof proto
         * @interface ITransactionGetReceiptResponse
         * @property {proto.IResponseHeader|null} [header] TransactionGetReceiptResponse header
         * @property {proto.ITransactionReceipt|null} [receipt] TransactionGetReceiptResponse receipt
         * @property {Array.<proto.ITransactionReceipt>|null} [duplicateTransactionReceipts] TransactionGetReceiptResponse duplicateTransactionReceipts
         */

        /**
         * Constructs a new TransactionGetReceiptResponse.
         * @memberof proto
         * @classdesc Represents a TransactionGetReceiptResponse.
         * @implements ITransactionGetReceiptResponse
         * @constructor
         * @param {proto.ITransactionGetReceiptResponse=} [p] Properties to set
         */
        function TransactionGetReceiptResponse(p) {
            this.duplicateTransactionReceipts = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TransactionGetReceiptResponse header.
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.TransactionGetReceiptResponse
         * @instance
         */
        TransactionGetReceiptResponse.prototype.header = null;

        /**
         * TransactionGetReceiptResponse receipt.
         * @member {proto.ITransactionReceipt|null|undefined} receipt
         * @memberof proto.TransactionGetReceiptResponse
         * @instance
         */
        TransactionGetReceiptResponse.prototype.receipt = null;

        /**
         * TransactionGetReceiptResponse duplicateTransactionReceipts.
         * @member {Array.<proto.ITransactionReceipt>} duplicateTransactionReceipts
         * @memberof proto.TransactionGetReceiptResponse
         * @instance
         */
        TransactionGetReceiptResponse.prototype.duplicateTransactionReceipts = $util.emptyArray;

        /**
         * Creates a new TransactionGetReceiptResponse instance using the specified properties.
         * @function create
         * @memberof proto.TransactionGetReceiptResponse
         * @static
         * @param {proto.ITransactionGetReceiptResponse=} [properties] Properties to set
         * @returns {proto.TransactionGetReceiptResponse} TransactionGetReceiptResponse instance
         */
        TransactionGetReceiptResponse.create = function create(properties) {
            return new TransactionGetReceiptResponse(properties);
        };

        /**
         * Encodes the specified TransactionGetReceiptResponse message. Does not implicitly {@link proto.TransactionGetReceiptResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionGetReceiptResponse
         * @static
         * @param {proto.ITransactionGetReceiptResponse} m TransactionGetReceiptResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionGetReceiptResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.receipt != null && Object.hasOwnProperty.call(m, "receipt"))
                $root.proto.TransactionReceipt.encode(m.receipt, w.uint32(18).fork()).ldelim();
            if (m.duplicateTransactionReceipts != null && m.duplicateTransactionReceipts.length) {
                for (var i = 0; i < m.duplicateTransactionReceipts.length; ++i)
                    $root.proto.TransactionReceipt.encode(m.duplicateTransactionReceipts[i], w.uint32(34).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TransactionGetReceiptResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionGetReceiptResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionGetReceiptResponse} TransactionGetReceiptResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionGetReceiptResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TransactionGetReceiptResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.receipt = $root.proto.TransactionReceipt.decode(r, r.uint32());
                    break;
                case 4:
                    if (!(m.duplicateTransactionReceipts && m.duplicateTransactionReceipts.length))
                        m.duplicateTransactionReceipts = [];
                    m.duplicateTransactionReceipts.push($root.proto.TransactionReceipt.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TransactionGetReceiptResponse;
    })();

    proto.TransactionGetRecordQuery = (function() {

        /**
         * Properties of a TransactionGetRecordQuery.
         * @memberof proto
         * @interface ITransactionGetRecordQuery
         * @property {proto.IQueryHeader|null} [header] TransactionGetRecordQuery header
         * @property {proto.ITransactionID|null} [transactionID] TransactionGetRecordQuery transactionID
         * @property {boolean|null} [includeDuplicates] TransactionGetRecordQuery includeDuplicates
         */

        /**
         * Constructs a new TransactionGetRecordQuery.
         * @memberof proto
         * @classdesc Represents a TransactionGetRecordQuery.
         * @implements ITransactionGetRecordQuery
         * @constructor
         * @param {proto.ITransactionGetRecordQuery=} [p] Properties to set
         */
        function TransactionGetRecordQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TransactionGetRecordQuery header.
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.TransactionGetRecordQuery
         * @instance
         */
        TransactionGetRecordQuery.prototype.header = null;

        /**
         * TransactionGetRecordQuery transactionID.
         * @member {proto.ITransactionID|null|undefined} transactionID
         * @memberof proto.TransactionGetRecordQuery
         * @instance
         */
        TransactionGetRecordQuery.prototype.transactionID = null;

        /**
         * TransactionGetRecordQuery includeDuplicates.
         * @member {boolean} includeDuplicates
         * @memberof proto.TransactionGetRecordQuery
         * @instance
         */
        TransactionGetRecordQuery.prototype.includeDuplicates = false;

        /**
         * Creates a new TransactionGetRecordQuery instance using the specified properties.
         * @function create
         * @memberof proto.TransactionGetRecordQuery
         * @static
         * @param {proto.ITransactionGetRecordQuery=} [properties] Properties to set
         * @returns {proto.TransactionGetRecordQuery} TransactionGetRecordQuery instance
         */
        TransactionGetRecordQuery.create = function create(properties) {
            return new TransactionGetRecordQuery(properties);
        };

        /**
         * Encodes the specified TransactionGetRecordQuery message. Does not implicitly {@link proto.TransactionGetRecordQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionGetRecordQuery
         * @static
         * @param {proto.ITransactionGetRecordQuery} m TransactionGetRecordQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionGetRecordQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.transactionID != null && Object.hasOwnProperty.call(m, "transactionID"))
                $root.proto.TransactionID.encode(m.transactionID, w.uint32(18).fork()).ldelim();
            if (m.includeDuplicates != null && Object.hasOwnProperty.call(m, "includeDuplicates"))
                w.uint32(24).bool(m.includeDuplicates);
            return w;
        };

        /**
         * Decodes a TransactionGetRecordQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionGetRecordQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionGetRecordQuery} TransactionGetRecordQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionGetRecordQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TransactionGetRecordQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.transactionID = $root.proto.TransactionID.decode(r, r.uint32());
                    break;
                case 3:
                    m.includeDuplicates = r.bool();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TransactionGetRecordQuery;
    })();

    proto.TransactionGetRecordResponse = (function() {

        /**
         * Properties of a TransactionGetRecordResponse.
         * @memberof proto
         * @interface ITransactionGetRecordResponse
         * @property {proto.IResponseHeader|null} [header] TransactionGetRecordResponse header
         * @property {proto.ITransactionRecord|null} [transactionRecord] TransactionGetRecordResponse transactionRecord
         * @property {Array.<proto.ITransactionRecord>|null} [duplicateTransactionRecords] TransactionGetRecordResponse duplicateTransactionRecords
         */

        /**
         * Constructs a new TransactionGetRecordResponse.
         * @memberof proto
         * @classdesc Represents a TransactionGetRecordResponse.
         * @implements ITransactionGetRecordResponse
         * @constructor
         * @param {proto.ITransactionGetRecordResponse=} [p] Properties to set
         */
        function TransactionGetRecordResponse(p) {
            this.duplicateTransactionRecords = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TransactionGetRecordResponse header.
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.TransactionGetRecordResponse
         * @instance
         */
        TransactionGetRecordResponse.prototype.header = null;

        /**
         * TransactionGetRecordResponse transactionRecord.
         * @member {proto.ITransactionRecord|null|undefined} transactionRecord
         * @memberof proto.TransactionGetRecordResponse
         * @instance
         */
        TransactionGetRecordResponse.prototype.transactionRecord = null;

        /**
         * TransactionGetRecordResponse duplicateTransactionRecords.
         * @member {Array.<proto.ITransactionRecord>} duplicateTransactionRecords
         * @memberof proto.TransactionGetRecordResponse
         * @instance
         */
        TransactionGetRecordResponse.prototype.duplicateTransactionRecords = $util.emptyArray;

        /**
         * Creates a new TransactionGetRecordResponse instance using the specified properties.
         * @function create
         * @memberof proto.TransactionGetRecordResponse
         * @static
         * @param {proto.ITransactionGetRecordResponse=} [properties] Properties to set
         * @returns {proto.TransactionGetRecordResponse} TransactionGetRecordResponse instance
         */
        TransactionGetRecordResponse.create = function create(properties) {
            return new TransactionGetRecordResponse(properties);
        };

        /**
         * Encodes the specified TransactionGetRecordResponse message. Does not implicitly {@link proto.TransactionGetRecordResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionGetRecordResponse
         * @static
         * @param {proto.ITransactionGetRecordResponse} m TransactionGetRecordResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionGetRecordResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.transactionRecord != null && Object.hasOwnProperty.call(m, "transactionRecord"))
                $root.proto.TransactionRecord.encode(m.transactionRecord, w.uint32(26).fork()).ldelim();
            if (m.duplicateTransactionRecords != null && m.duplicateTransactionRecords.length) {
                for (var i = 0; i < m.duplicateTransactionRecords.length; ++i)
                    $root.proto.TransactionRecord.encode(m.duplicateTransactionRecords[i], w.uint32(34).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TransactionGetRecordResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionGetRecordResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionGetRecordResponse} TransactionGetRecordResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionGetRecordResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TransactionGetRecordResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                    break;
                case 3:
                    m.transactionRecord = $root.proto.TransactionRecord.decode(r, r.uint32());
                    break;
                case 4:
                    if (!(m.duplicateTransactionRecords && m.duplicateTransactionRecords.length))
                        m.duplicateTransactionRecords = [];
                    m.duplicateTransactionRecords.push($root.proto.TransactionRecord.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TransactionGetRecordResponse;
    })();

    proto.TransactionGetFastRecordQuery = (function() {

        /**
         * Properties of a TransactionGetFastRecordQuery.
         * @memberof proto
         * @interface ITransactionGetFastRecordQuery
         * @property {proto.IQueryHeader|null} [header] TransactionGetFastRecordQuery header
         * @property {proto.ITransactionID|null} [transactionID] TransactionGetFastRecordQuery transactionID
         */

        /**
         * Constructs a new TransactionGetFastRecordQuery.
         * @memberof proto
         * @classdesc Represents a TransactionGetFastRecordQuery.
         * @implements ITransactionGetFastRecordQuery
         * @constructor
         * @param {proto.ITransactionGetFastRecordQuery=} [p] Properties to set
         */
        function TransactionGetFastRecordQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TransactionGetFastRecordQuery header.
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.TransactionGetFastRecordQuery
         * @instance
         */
        TransactionGetFastRecordQuery.prototype.header = null;

        /**
         * TransactionGetFastRecordQuery transactionID.
         * @member {proto.ITransactionID|null|undefined} transactionID
         * @memberof proto.TransactionGetFastRecordQuery
         * @instance
         */
        TransactionGetFastRecordQuery.prototype.transactionID = null;

        /**
         * Creates a new TransactionGetFastRecordQuery instance using the specified properties.
         * @function create
         * @memberof proto.TransactionGetFastRecordQuery
         * @static
         * @param {proto.ITransactionGetFastRecordQuery=} [properties] Properties to set
         * @returns {proto.TransactionGetFastRecordQuery} TransactionGetFastRecordQuery instance
         */
        TransactionGetFastRecordQuery.create = function create(properties) {
            return new TransactionGetFastRecordQuery(properties);
        };

        /**
         * Encodes the specified TransactionGetFastRecordQuery message. Does not implicitly {@link proto.TransactionGetFastRecordQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionGetFastRecordQuery
         * @static
         * @param {proto.ITransactionGetFastRecordQuery} m TransactionGetFastRecordQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionGetFastRecordQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.transactionID != null && Object.hasOwnProperty.call(m, "transactionID"))
                $root.proto.TransactionID.encode(m.transactionID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TransactionGetFastRecordQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionGetFastRecordQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionGetFastRecordQuery} TransactionGetFastRecordQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionGetFastRecordQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TransactionGetFastRecordQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.transactionID = $root.proto.TransactionID.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TransactionGetFastRecordQuery;
    })();

    proto.TransactionGetFastRecordResponse = (function() {

        /**
         * Properties of a TransactionGetFastRecordResponse.
         * @memberof proto
         * @interface ITransactionGetFastRecordResponse
         * @property {proto.IResponseHeader|null} [header] TransactionGetFastRecordResponse header
         * @property {proto.ITransactionRecord|null} [transactionRecord] TransactionGetFastRecordResponse transactionRecord
         */

        /**
         * Constructs a new TransactionGetFastRecordResponse.
         * @memberof proto
         * @classdesc Represents a TransactionGetFastRecordResponse.
         * @implements ITransactionGetFastRecordResponse
         * @constructor
         * @param {proto.ITransactionGetFastRecordResponse=} [p] Properties to set
         */
        function TransactionGetFastRecordResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TransactionGetFastRecordResponse header.
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.TransactionGetFastRecordResponse
         * @instance
         */
        TransactionGetFastRecordResponse.prototype.header = null;

        /**
         * TransactionGetFastRecordResponse transactionRecord.
         * @member {proto.ITransactionRecord|null|undefined} transactionRecord
         * @memberof proto.TransactionGetFastRecordResponse
         * @instance
         */
        TransactionGetFastRecordResponse.prototype.transactionRecord = null;

        /**
         * Creates a new TransactionGetFastRecordResponse instance using the specified properties.
         * @function create
         * @memberof proto.TransactionGetFastRecordResponse
         * @static
         * @param {proto.ITransactionGetFastRecordResponse=} [properties] Properties to set
         * @returns {proto.TransactionGetFastRecordResponse} TransactionGetFastRecordResponse instance
         */
        TransactionGetFastRecordResponse.create = function create(properties) {
            return new TransactionGetFastRecordResponse(properties);
        };

        /**
         * Encodes the specified TransactionGetFastRecordResponse message. Does not implicitly {@link proto.TransactionGetFastRecordResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionGetFastRecordResponse
         * @static
         * @param {proto.ITransactionGetFastRecordResponse} m TransactionGetFastRecordResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionGetFastRecordResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.transactionRecord != null && Object.hasOwnProperty.call(m, "transactionRecord"))
                $root.proto.TransactionRecord.encode(m.transactionRecord, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TransactionGetFastRecordResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionGetFastRecordResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionGetFastRecordResponse} TransactionGetFastRecordResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionGetFastRecordResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TransactionGetFastRecordResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.transactionRecord = $root.proto.TransactionRecord.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TransactionGetFastRecordResponse;
    })();

    proto.NetworkGetVersionInfoQuery = (function() {

        /**
         * Properties of a NetworkGetVersionInfoQuery.
         * @memberof proto
         * @interface INetworkGetVersionInfoQuery
         * @property {proto.IQueryHeader|null} [header] NetworkGetVersionInfoQuery header
         */

        /**
         * Constructs a new NetworkGetVersionInfoQuery.
         * @memberof proto
         * @classdesc Represents a NetworkGetVersionInfoQuery.
         * @implements INetworkGetVersionInfoQuery
         * @constructor
         * @param {proto.INetworkGetVersionInfoQuery=} [p] Properties to set
         */
        function NetworkGetVersionInfoQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * NetworkGetVersionInfoQuery header.
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.NetworkGetVersionInfoQuery
         * @instance
         */
        NetworkGetVersionInfoQuery.prototype.header = null;

        /**
         * Creates a new NetworkGetVersionInfoQuery instance using the specified properties.
         * @function create
         * @memberof proto.NetworkGetVersionInfoQuery
         * @static
         * @param {proto.INetworkGetVersionInfoQuery=} [properties] Properties to set
         * @returns {proto.NetworkGetVersionInfoQuery} NetworkGetVersionInfoQuery instance
         */
        NetworkGetVersionInfoQuery.create = function create(properties) {
            return new NetworkGetVersionInfoQuery(properties);
        };

        /**
         * Encodes the specified NetworkGetVersionInfoQuery message. Does not implicitly {@link proto.NetworkGetVersionInfoQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.NetworkGetVersionInfoQuery
         * @static
         * @param {proto.INetworkGetVersionInfoQuery} m NetworkGetVersionInfoQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetworkGetVersionInfoQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a NetworkGetVersionInfoQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.NetworkGetVersionInfoQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.NetworkGetVersionInfoQuery} NetworkGetVersionInfoQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetworkGetVersionInfoQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.NetworkGetVersionInfoQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return NetworkGetVersionInfoQuery;
    })();

    proto.NetworkGetVersionInfoResponse = (function() {

        /**
         * Properties of a NetworkGetVersionInfoResponse.
         * @memberof proto
         * @interface INetworkGetVersionInfoResponse
         * @property {proto.IResponseHeader|null} [header] NetworkGetVersionInfoResponse header
         * @property {proto.ISemanticVersion|null} [hapiProtoVersion] NetworkGetVersionInfoResponse hapiProtoVersion
         * @property {proto.ISemanticVersion|null} [hederaServicesVersion] NetworkGetVersionInfoResponse hederaServicesVersion
         */

        /**
         * Constructs a new NetworkGetVersionInfoResponse.
         * @memberof proto
         * @classdesc Represents a NetworkGetVersionInfoResponse.
         * @implements INetworkGetVersionInfoResponse
         * @constructor
         * @param {proto.INetworkGetVersionInfoResponse=} [p] Properties to set
         */
        function NetworkGetVersionInfoResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * NetworkGetVersionInfoResponse header.
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.NetworkGetVersionInfoResponse
         * @instance
         */
        NetworkGetVersionInfoResponse.prototype.header = null;

        /**
         * NetworkGetVersionInfoResponse hapiProtoVersion.
         * @member {proto.ISemanticVersion|null|undefined} hapiProtoVersion
         * @memberof proto.NetworkGetVersionInfoResponse
         * @instance
         */
        NetworkGetVersionInfoResponse.prototype.hapiProtoVersion = null;

        /**
         * NetworkGetVersionInfoResponse hederaServicesVersion.
         * @member {proto.ISemanticVersion|null|undefined} hederaServicesVersion
         * @memberof proto.NetworkGetVersionInfoResponse
         * @instance
         */
        NetworkGetVersionInfoResponse.prototype.hederaServicesVersion = null;

        /**
         * Creates a new NetworkGetVersionInfoResponse instance using the specified properties.
         * @function create
         * @memberof proto.NetworkGetVersionInfoResponse
         * @static
         * @param {proto.INetworkGetVersionInfoResponse=} [properties] Properties to set
         * @returns {proto.NetworkGetVersionInfoResponse} NetworkGetVersionInfoResponse instance
         */
        NetworkGetVersionInfoResponse.create = function create(properties) {
            return new NetworkGetVersionInfoResponse(properties);
        };

        /**
         * Encodes the specified NetworkGetVersionInfoResponse message. Does not implicitly {@link proto.NetworkGetVersionInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.NetworkGetVersionInfoResponse
         * @static
         * @param {proto.INetworkGetVersionInfoResponse} m NetworkGetVersionInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetworkGetVersionInfoResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.hapiProtoVersion != null && Object.hasOwnProperty.call(m, "hapiProtoVersion"))
                $root.proto.SemanticVersion.encode(m.hapiProtoVersion, w.uint32(18).fork()).ldelim();
            if (m.hederaServicesVersion != null && Object.hasOwnProperty.call(m, "hederaServicesVersion"))
                $root.proto.SemanticVersion.encode(m.hederaServicesVersion, w.uint32(26).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a NetworkGetVersionInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.NetworkGetVersionInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.NetworkGetVersionInfoResponse} NetworkGetVersionInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetworkGetVersionInfoResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.NetworkGetVersionInfoResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.hapiProtoVersion = $root.proto.SemanticVersion.decode(r, r.uint32());
                    break;
                case 3:
                    m.hederaServicesVersion = $root.proto.SemanticVersion.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return NetworkGetVersionInfoResponse;
    })();

    proto.TokenGetInfoQuery = (function() {

        /**
         * Properties of a TokenGetInfoQuery.
         * @memberof proto
         * @interface ITokenGetInfoQuery
         * @property {proto.IQueryHeader|null} [header] TokenGetInfoQuery header
         * @property {proto.ITokenID|null} [token] TokenGetInfoQuery token
         */

        /**
         * Constructs a new TokenGetInfoQuery.
         * @memberof proto
         * @classdesc Represents a TokenGetInfoQuery.
         * @implements ITokenGetInfoQuery
         * @constructor
         * @param {proto.ITokenGetInfoQuery=} [p] Properties to set
         */
        function TokenGetInfoQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TokenGetInfoQuery header.
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.TokenGetInfoQuery
         * @instance
         */
        TokenGetInfoQuery.prototype.header = null;

        /**
         * TokenGetInfoQuery token.
         * @member {proto.ITokenID|null|undefined} token
         * @memberof proto.TokenGetInfoQuery
         * @instance
         */
        TokenGetInfoQuery.prototype.token = null;

        /**
         * Creates a new TokenGetInfoQuery instance using the specified properties.
         * @function create
         * @memberof proto.TokenGetInfoQuery
         * @static
         * @param {proto.ITokenGetInfoQuery=} [properties] Properties to set
         * @returns {proto.TokenGetInfoQuery} TokenGetInfoQuery instance
         */
        TokenGetInfoQuery.create = function create(properties) {
            return new TokenGetInfoQuery(properties);
        };

        /**
         * Encodes the specified TokenGetInfoQuery message. Does not implicitly {@link proto.TokenGetInfoQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenGetInfoQuery
         * @static
         * @param {proto.ITokenGetInfoQuery} m TokenGetInfoQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenGetInfoQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.token != null && Object.hasOwnProperty.call(m, "token"))
                $root.proto.TokenID.encode(m.token, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenGetInfoQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenGetInfoQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenGetInfoQuery} TokenGetInfoQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenGetInfoQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenGetInfoQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.token = $root.proto.TokenID.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TokenGetInfoQuery;
    })();

    proto.TokenInfo = (function() {

        /**
         * Properties of a TokenInfo.
         * @memberof proto
         * @interface ITokenInfo
         * @property {proto.ITokenID|null} [tokenId] TokenInfo tokenId
         * @property {string|null} [name] TokenInfo name
         * @property {string|null} [symbol] TokenInfo symbol
         * @property {number|null} [decimals] TokenInfo decimals
         * @property {Long|null} [totalSupply] TokenInfo totalSupply
         * @property {proto.IAccountID|null} [treasury] TokenInfo treasury
         * @property {proto.IKey|null} [adminKey] TokenInfo adminKey
         * @property {proto.IKey|null} [kycKey] TokenInfo kycKey
         * @property {proto.IKey|null} [freezeKey] TokenInfo freezeKey
         * @property {proto.IKey|null} [wipeKey] TokenInfo wipeKey
         * @property {proto.IKey|null} [supplyKey] TokenInfo supplyKey
         * @property {proto.TokenFreezeStatus|null} [defaultFreezeStatus] TokenInfo defaultFreezeStatus
         * @property {proto.TokenKycStatus|null} [defaultKycStatus] TokenInfo defaultKycStatus
         * @property {boolean|null} [deleted] TokenInfo deleted
         * @property {proto.IAccountID|null} [autoRenewAccount] TokenInfo autoRenewAccount
         * @property {proto.IDuration|null} [autoRenewPeriod] TokenInfo autoRenewPeriod
         * @property {proto.ITimestamp|null} [expiry] TokenInfo expiry
         * @property {string|null} [memo] TokenInfo memo
         * @property {proto.TokenType|null} [tokenType] TokenInfo tokenType
         * @property {proto.TokenSupplyType|null} [supplyType] TokenInfo supplyType
         * @property {Long|null} [maxSupply] TokenInfo maxSupply
         * @property {proto.IKey|null} [feeScheduleKey] TokenInfo feeScheduleKey
         * @property {Array.<proto.ICustomFee>|null} [customFees] TokenInfo customFees
         */

        /**
         * Constructs a new TokenInfo.
         * @memberof proto
         * @classdesc Represents a TokenInfo.
         * @implements ITokenInfo
         * @constructor
         * @param {proto.ITokenInfo=} [p] Properties to set
         */
        function TokenInfo(p) {
            this.customFees = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TokenInfo tokenId.
         * @member {proto.ITokenID|null|undefined} tokenId
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.tokenId = null;

        /**
         * TokenInfo name.
         * @member {string} name
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.name = "";

        /**
         * TokenInfo symbol.
         * @member {string} symbol
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.symbol = "";

        /**
         * TokenInfo decimals.
         * @member {number} decimals
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.decimals = 0;

        /**
         * TokenInfo totalSupply.
         * @member {Long} totalSupply
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.totalSupply = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TokenInfo treasury.
         * @member {proto.IAccountID|null|undefined} treasury
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.treasury = null;

        /**
         * TokenInfo adminKey.
         * @member {proto.IKey|null|undefined} adminKey
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.adminKey = null;

        /**
         * TokenInfo kycKey.
         * @member {proto.IKey|null|undefined} kycKey
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.kycKey = null;

        /**
         * TokenInfo freezeKey.
         * @member {proto.IKey|null|undefined} freezeKey
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.freezeKey = null;

        /**
         * TokenInfo wipeKey.
         * @member {proto.IKey|null|undefined} wipeKey
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.wipeKey = null;

        /**
         * TokenInfo supplyKey.
         * @member {proto.IKey|null|undefined} supplyKey
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.supplyKey = null;

        /**
         * TokenInfo defaultFreezeStatus.
         * @member {proto.TokenFreezeStatus} defaultFreezeStatus
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.defaultFreezeStatus = 0;

        /**
         * TokenInfo defaultKycStatus.
         * @member {proto.TokenKycStatus} defaultKycStatus
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.defaultKycStatus = 0;

        /**
         * TokenInfo deleted.
         * @member {boolean} deleted
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.deleted = false;

        /**
         * TokenInfo autoRenewAccount.
         * @member {proto.IAccountID|null|undefined} autoRenewAccount
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.autoRenewAccount = null;

        /**
         * TokenInfo autoRenewPeriod.
         * @member {proto.IDuration|null|undefined} autoRenewPeriod
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.autoRenewPeriod = null;

        /**
         * TokenInfo expiry.
         * @member {proto.ITimestamp|null|undefined} expiry
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.expiry = null;

        /**
         * TokenInfo memo.
         * @member {string} memo
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.memo = "";

        /**
         * TokenInfo tokenType.
         * @member {proto.TokenType} tokenType
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.tokenType = 0;

        /**
         * TokenInfo supplyType.
         * @member {proto.TokenSupplyType} supplyType
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.supplyType = 0;

        /**
         * TokenInfo maxSupply.
         * @member {Long} maxSupply
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.maxSupply = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TokenInfo feeScheduleKey.
         * @member {proto.IKey|null|undefined} feeScheduleKey
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.feeScheduleKey = null;

        /**
         * TokenInfo customFees.
         * @member {Array.<proto.ICustomFee>} customFees
         * @memberof proto.TokenInfo
         * @instance
         */
        TokenInfo.prototype.customFees = $util.emptyArray;

        /**
         * Creates a new TokenInfo instance using the specified properties.
         * @function create
         * @memberof proto.TokenInfo
         * @static
         * @param {proto.ITokenInfo=} [properties] Properties to set
         * @returns {proto.TokenInfo} TokenInfo instance
         */
        TokenInfo.create = function create(properties) {
            return new TokenInfo(properties);
        };

        /**
         * Encodes the specified TokenInfo message. Does not implicitly {@link proto.TokenInfo.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenInfo
         * @static
         * @param {proto.ITokenInfo} m TokenInfo message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenInfo.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.tokenId != null && Object.hasOwnProperty.call(m, "tokenId"))
                $root.proto.TokenID.encode(m.tokenId, w.uint32(10).fork()).ldelim();
            if (m.name != null && Object.hasOwnProperty.call(m, "name"))
                w.uint32(18).string(m.name);
            if (m.symbol != null && Object.hasOwnProperty.call(m, "symbol"))
                w.uint32(26).string(m.symbol);
            if (m.decimals != null && Object.hasOwnProperty.call(m, "decimals"))
                w.uint32(32).uint32(m.decimals);
            if (m.totalSupply != null && Object.hasOwnProperty.call(m, "totalSupply"))
                w.uint32(40).uint64(m.totalSupply);
            if (m.treasury != null && Object.hasOwnProperty.call(m, "treasury"))
                $root.proto.AccountID.encode(m.treasury, w.uint32(50).fork()).ldelim();
            if (m.adminKey != null && Object.hasOwnProperty.call(m, "adminKey"))
                $root.proto.Key.encode(m.adminKey, w.uint32(58).fork()).ldelim();
            if (m.kycKey != null && Object.hasOwnProperty.call(m, "kycKey"))
                $root.proto.Key.encode(m.kycKey, w.uint32(66).fork()).ldelim();
            if (m.freezeKey != null && Object.hasOwnProperty.call(m, "freezeKey"))
                $root.proto.Key.encode(m.freezeKey, w.uint32(74).fork()).ldelim();
            if (m.wipeKey != null && Object.hasOwnProperty.call(m, "wipeKey"))
                $root.proto.Key.encode(m.wipeKey, w.uint32(82).fork()).ldelim();
            if (m.supplyKey != null && Object.hasOwnProperty.call(m, "supplyKey"))
                $root.proto.Key.encode(m.supplyKey, w.uint32(90).fork()).ldelim();
            if (m.defaultFreezeStatus != null && Object.hasOwnProperty.call(m, "defaultFreezeStatus"))
                w.uint32(96).int32(m.defaultFreezeStatus);
            if (m.defaultKycStatus != null && Object.hasOwnProperty.call(m, "defaultKycStatus"))
                w.uint32(104).int32(m.defaultKycStatus);
            if (m.deleted != null && Object.hasOwnProperty.call(m, "deleted"))
                w.uint32(112).bool(m.deleted);
            if (m.autoRenewAccount != null && Object.hasOwnProperty.call(m, "autoRenewAccount"))
                $root.proto.AccountID.encode(m.autoRenewAccount, w.uint32(122).fork()).ldelim();
            if (m.autoRenewPeriod != null && Object.hasOwnProperty.call(m, "autoRenewPeriod"))
                $root.proto.Duration.encode(m.autoRenewPeriod, w.uint32(130).fork()).ldelim();
            if (m.expiry != null && Object.hasOwnProperty.call(m, "expiry"))
                $root.proto.Timestamp.encode(m.expiry, w.uint32(138).fork()).ldelim();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                w.uint32(146).string(m.memo);
            if (m.tokenType != null && Object.hasOwnProperty.call(m, "tokenType"))
                w.uint32(152).int32(m.tokenType);
            if (m.supplyType != null && Object.hasOwnProperty.call(m, "supplyType"))
                w.uint32(160).int32(m.supplyType);
            if (m.maxSupply != null && Object.hasOwnProperty.call(m, "maxSupply"))
                w.uint32(168).int64(m.maxSupply);
            if (m.feeScheduleKey != null && Object.hasOwnProperty.call(m, "feeScheduleKey"))
                $root.proto.Key.encode(m.feeScheduleKey, w.uint32(178).fork()).ldelim();
            if (m.customFees != null && m.customFees.length) {
                for (var i = 0; i < m.customFees.length; ++i)
                    $root.proto.CustomFee.encode(m.customFees[i], w.uint32(186).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TokenInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenInfo} TokenInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenInfo.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenInfo();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.tokenId = $root.proto.TokenID.decode(r, r.uint32());
                    break;
                case 2:
                    m.name = r.string();
                    break;
                case 3:
                    m.symbol = r.string();
                    break;
                case 4:
                    m.decimals = r.uint32();
                    break;
                case 5:
                    m.totalSupply = r.uint64();
                    break;
                case 6:
                    m.treasury = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 7:
                    m.adminKey = $root.proto.Key.decode(r, r.uint32());
                    break;
                case 8:
                    m.kycKey = $root.proto.Key.decode(r, r.uint32());
                    break;
                case 9:
                    m.freezeKey = $root.proto.Key.decode(r, r.uint32());
                    break;
                case 10:
                    m.wipeKey = $root.proto.Key.decode(r, r.uint32());
                    break;
                case 11:
                    m.supplyKey = $root.proto.Key.decode(r, r.uint32());
                    break;
                case 12:
                    m.defaultFreezeStatus = r.int32();
                    break;
                case 13:
                    m.defaultKycStatus = r.int32();
                    break;
                case 14:
                    m.deleted = r.bool();
                    break;
                case 15:
                    m.autoRenewAccount = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 16:
                    m.autoRenewPeriod = $root.proto.Duration.decode(r, r.uint32());
                    break;
                case 17:
                    m.expiry = $root.proto.Timestamp.decode(r, r.uint32());
                    break;
                case 18:
                    m.memo = r.string();
                    break;
                case 19:
                    m.tokenType = r.int32();
                    break;
                case 20:
                    m.supplyType = r.int32();
                    break;
                case 21:
                    m.maxSupply = r.int64();
                    break;
                case 22:
                    m.feeScheduleKey = $root.proto.Key.decode(r, r.uint32());
                    break;
                case 23:
                    if (!(m.customFees && m.customFees.length))
                        m.customFees = [];
                    m.customFees.push($root.proto.CustomFee.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TokenInfo;
    })();

    proto.TokenGetInfoResponse = (function() {

        /**
         * Properties of a TokenGetInfoResponse.
         * @memberof proto
         * @interface ITokenGetInfoResponse
         * @property {proto.IResponseHeader|null} [header] TokenGetInfoResponse header
         * @property {proto.ITokenInfo|null} [tokenInfo] TokenGetInfoResponse tokenInfo
         */

        /**
         * Constructs a new TokenGetInfoResponse.
         * @memberof proto
         * @classdesc Represents a TokenGetInfoResponse.
         * @implements ITokenGetInfoResponse
         * @constructor
         * @param {proto.ITokenGetInfoResponse=} [p] Properties to set
         */
        function TokenGetInfoResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TokenGetInfoResponse header.
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.TokenGetInfoResponse
         * @instance
         */
        TokenGetInfoResponse.prototype.header = null;

        /**
         * TokenGetInfoResponse tokenInfo.
         * @member {proto.ITokenInfo|null|undefined} tokenInfo
         * @memberof proto.TokenGetInfoResponse
         * @instance
         */
        TokenGetInfoResponse.prototype.tokenInfo = null;

        /**
         * Creates a new TokenGetInfoResponse instance using the specified properties.
         * @function create
         * @memberof proto.TokenGetInfoResponse
         * @static
         * @param {proto.ITokenGetInfoResponse=} [properties] Properties to set
         * @returns {proto.TokenGetInfoResponse} TokenGetInfoResponse instance
         */
        TokenGetInfoResponse.create = function create(properties) {
            return new TokenGetInfoResponse(properties);
        };

        /**
         * Encodes the specified TokenGetInfoResponse message. Does not implicitly {@link proto.TokenGetInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenGetInfoResponse
         * @static
         * @param {proto.ITokenGetInfoResponse} m TokenGetInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenGetInfoResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.tokenInfo != null && Object.hasOwnProperty.call(m, "tokenInfo"))
                $root.proto.TokenInfo.encode(m.tokenInfo, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenGetInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenGetInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenGetInfoResponse} TokenGetInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenGetInfoResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenGetInfoResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.tokenInfo = $root.proto.TokenInfo.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TokenGetInfoResponse;
    })();

    proto.ScheduleGetInfoQuery = (function() {

        /**
         * Properties of a ScheduleGetInfoQuery.
         * @memberof proto
         * @interface IScheduleGetInfoQuery
         * @property {proto.IQueryHeader|null} [header] ScheduleGetInfoQuery header
         * @property {proto.IScheduleID|null} [scheduleID] ScheduleGetInfoQuery scheduleID
         */

        /**
         * Constructs a new ScheduleGetInfoQuery.
         * @memberof proto
         * @classdesc Represents a ScheduleGetInfoQuery.
         * @implements IScheduleGetInfoQuery
         * @constructor
         * @param {proto.IScheduleGetInfoQuery=} [p] Properties to set
         */
        function ScheduleGetInfoQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ScheduleGetInfoQuery header.
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.ScheduleGetInfoQuery
         * @instance
         */
        ScheduleGetInfoQuery.prototype.header = null;

        /**
         * ScheduleGetInfoQuery scheduleID.
         * @member {proto.IScheduleID|null|undefined} scheduleID
         * @memberof proto.ScheduleGetInfoQuery
         * @instance
         */
        ScheduleGetInfoQuery.prototype.scheduleID = null;

        /**
         * Creates a new ScheduleGetInfoQuery instance using the specified properties.
         * @function create
         * @memberof proto.ScheduleGetInfoQuery
         * @static
         * @param {proto.IScheduleGetInfoQuery=} [properties] Properties to set
         * @returns {proto.ScheduleGetInfoQuery} ScheduleGetInfoQuery instance
         */
        ScheduleGetInfoQuery.create = function create(properties) {
            return new ScheduleGetInfoQuery(properties);
        };

        /**
         * Encodes the specified ScheduleGetInfoQuery message. Does not implicitly {@link proto.ScheduleGetInfoQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.ScheduleGetInfoQuery
         * @static
         * @param {proto.IScheduleGetInfoQuery} m ScheduleGetInfoQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScheduleGetInfoQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.scheduleID != null && Object.hasOwnProperty.call(m, "scheduleID"))
                $root.proto.ScheduleID.encode(m.scheduleID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ScheduleGetInfoQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ScheduleGetInfoQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ScheduleGetInfoQuery} ScheduleGetInfoQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScheduleGetInfoQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ScheduleGetInfoQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.scheduleID = $root.proto.ScheduleID.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ScheduleGetInfoQuery;
    })();

    proto.ScheduleInfo = (function() {

        /**
         * Properties of a ScheduleInfo.
         * @memberof proto
         * @interface IScheduleInfo
         * @property {proto.IScheduleID|null} [scheduleID] ScheduleInfo scheduleID
         * @property {proto.ITimestamp|null} [deletionTime] ScheduleInfo deletionTime
         * @property {proto.ITimestamp|null} [executionTime] ScheduleInfo executionTime
         * @property {proto.ITimestamp|null} [expirationTime] ScheduleInfo expirationTime
         * @property {proto.ISchedulableTransactionBody|null} [scheduledTransactionBody] ScheduleInfo scheduledTransactionBody
         * @property {string|null} [memo] ScheduleInfo memo
         * @property {proto.IKey|null} [adminKey] ScheduleInfo adminKey
         * @property {proto.IKeyList|null} [signers] ScheduleInfo signers
         * @property {proto.IAccountID|null} [creatorAccountID] ScheduleInfo creatorAccountID
         * @property {proto.IAccountID|null} [payerAccountID] ScheduleInfo payerAccountID
         * @property {proto.ITransactionID|null} [scheduledTransactionID] ScheduleInfo scheduledTransactionID
         */

        /**
         * Constructs a new ScheduleInfo.
         * @memberof proto
         * @classdesc Represents a ScheduleInfo.
         * @implements IScheduleInfo
         * @constructor
         * @param {proto.IScheduleInfo=} [p] Properties to set
         */
        function ScheduleInfo(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ScheduleInfo scheduleID.
         * @member {proto.IScheduleID|null|undefined} scheduleID
         * @memberof proto.ScheduleInfo
         * @instance
         */
        ScheduleInfo.prototype.scheduleID = null;

        /**
         * ScheduleInfo deletionTime.
         * @member {proto.ITimestamp|null|undefined} deletionTime
         * @memberof proto.ScheduleInfo
         * @instance
         */
        ScheduleInfo.prototype.deletionTime = null;

        /**
         * ScheduleInfo executionTime.
         * @member {proto.ITimestamp|null|undefined} executionTime
         * @memberof proto.ScheduleInfo
         * @instance
         */
        ScheduleInfo.prototype.executionTime = null;

        /**
         * ScheduleInfo expirationTime.
         * @member {proto.ITimestamp|null|undefined} expirationTime
         * @memberof proto.ScheduleInfo
         * @instance
         */
        ScheduleInfo.prototype.expirationTime = null;

        /**
         * ScheduleInfo scheduledTransactionBody.
         * @member {proto.ISchedulableTransactionBody|null|undefined} scheduledTransactionBody
         * @memberof proto.ScheduleInfo
         * @instance
         */
        ScheduleInfo.prototype.scheduledTransactionBody = null;

        /**
         * ScheduleInfo memo.
         * @member {string} memo
         * @memberof proto.ScheduleInfo
         * @instance
         */
        ScheduleInfo.prototype.memo = "";

        /**
         * ScheduleInfo adminKey.
         * @member {proto.IKey|null|undefined} adminKey
         * @memberof proto.ScheduleInfo
         * @instance
         */
        ScheduleInfo.prototype.adminKey = null;

        /**
         * ScheduleInfo signers.
         * @member {proto.IKeyList|null|undefined} signers
         * @memberof proto.ScheduleInfo
         * @instance
         */
        ScheduleInfo.prototype.signers = null;

        /**
         * ScheduleInfo creatorAccountID.
         * @member {proto.IAccountID|null|undefined} creatorAccountID
         * @memberof proto.ScheduleInfo
         * @instance
         */
        ScheduleInfo.prototype.creatorAccountID = null;

        /**
         * ScheduleInfo payerAccountID.
         * @member {proto.IAccountID|null|undefined} payerAccountID
         * @memberof proto.ScheduleInfo
         * @instance
         */
        ScheduleInfo.prototype.payerAccountID = null;

        /**
         * ScheduleInfo scheduledTransactionID.
         * @member {proto.ITransactionID|null|undefined} scheduledTransactionID
         * @memberof proto.ScheduleInfo
         * @instance
         */
        ScheduleInfo.prototype.scheduledTransactionID = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * ScheduleInfo data.
         * @member {"deletionTime"|"executionTime"|undefined} data
         * @memberof proto.ScheduleInfo
         * @instance
         */
        Object.defineProperty(ScheduleInfo.prototype, "data", {
            get: $util.oneOfGetter($oneOfFields = ["deletionTime", "executionTime"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ScheduleInfo instance using the specified properties.
         * @function create
         * @memberof proto.ScheduleInfo
         * @static
         * @param {proto.IScheduleInfo=} [properties] Properties to set
         * @returns {proto.ScheduleInfo} ScheduleInfo instance
         */
        ScheduleInfo.create = function create(properties) {
            return new ScheduleInfo(properties);
        };

        /**
         * Encodes the specified ScheduleInfo message. Does not implicitly {@link proto.ScheduleInfo.verify|verify} messages.
         * @function encode
         * @memberof proto.ScheduleInfo
         * @static
         * @param {proto.IScheduleInfo} m ScheduleInfo message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScheduleInfo.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.scheduleID != null && Object.hasOwnProperty.call(m, "scheduleID"))
                $root.proto.ScheduleID.encode(m.scheduleID, w.uint32(10).fork()).ldelim();
            if (m.deletionTime != null && Object.hasOwnProperty.call(m, "deletionTime"))
                $root.proto.Timestamp.encode(m.deletionTime, w.uint32(18).fork()).ldelim();
            if (m.executionTime != null && Object.hasOwnProperty.call(m, "executionTime"))
                $root.proto.Timestamp.encode(m.executionTime, w.uint32(26).fork()).ldelim();
            if (m.expirationTime != null && Object.hasOwnProperty.call(m, "expirationTime"))
                $root.proto.Timestamp.encode(m.expirationTime, w.uint32(34).fork()).ldelim();
            if (m.scheduledTransactionBody != null && Object.hasOwnProperty.call(m, "scheduledTransactionBody"))
                $root.proto.SchedulableTransactionBody.encode(m.scheduledTransactionBody, w.uint32(42).fork()).ldelim();
            if (m.memo != null && Object.hasOwnProperty.call(m, "memo"))
                w.uint32(50).string(m.memo);
            if (m.adminKey != null && Object.hasOwnProperty.call(m, "adminKey"))
                $root.proto.Key.encode(m.adminKey, w.uint32(58).fork()).ldelim();
            if (m.signers != null && Object.hasOwnProperty.call(m, "signers"))
                $root.proto.KeyList.encode(m.signers, w.uint32(66).fork()).ldelim();
            if (m.creatorAccountID != null && Object.hasOwnProperty.call(m, "creatorAccountID"))
                $root.proto.AccountID.encode(m.creatorAccountID, w.uint32(74).fork()).ldelim();
            if (m.payerAccountID != null && Object.hasOwnProperty.call(m, "payerAccountID"))
                $root.proto.AccountID.encode(m.payerAccountID, w.uint32(82).fork()).ldelim();
            if (m.scheduledTransactionID != null && Object.hasOwnProperty.call(m, "scheduledTransactionID"))
                $root.proto.TransactionID.encode(m.scheduledTransactionID, w.uint32(90).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ScheduleInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ScheduleInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ScheduleInfo} ScheduleInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScheduleInfo.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ScheduleInfo();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.scheduleID = $root.proto.ScheduleID.decode(r, r.uint32());
                    break;
                case 2:
                    m.deletionTime = $root.proto.Timestamp.decode(r, r.uint32());
                    break;
                case 3:
                    m.executionTime = $root.proto.Timestamp.decode(r, r.uint32());
                    break;
                case 4:
                    m.expirationTime = $root.proto.Timestamp.decode(r, r.uint32());
                    break;
                case 5:
                    m.scheduledTransactionBody = $root.proto.SchedulableTransactionBody.decode(r, r.uint32());
                    break;
                case 6:
                    m.memo = r.string();
                    break;
                case 7:
                    m.adminKey = $root.proto.Key.decode(r, r.uint32());
                    break;
                case 8:
                    m.signers = $root.proto.KeyList.decode(r, r.uint32());
                    break;
                case 9:
                    m.creatorAccountID = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 10:
                    m.payerAccountID = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 11:
                    m.scheduledTransactionID = $root.proto.TransactionID.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ScheduleInfo;
    })();

    proto.ScheduleGetInfoResponse = (function() {

        /**
         * Properties of a ScheduleGetInfoResponse.
         * @memberof proto
         * @interface IScheduleGetInfoResponse
         * @property {proto.IResponseHeader|null} [header] ScheduleGetInfoResponse header
         * @property {proto.IScheduleInfo|null} [scheduleInfo] ScheduleGetInfoResponse scheduleInfo
         */

        /**
         * Constructs a new ScheduleGetInfoResponse.
         * @memberof proto
         * @classdesc Represents a ScheduleGetInfoResponse.
         * @implements IScheduleGetInfoResponse
         * @constructor
         * @param {proto.IScheduleGetInfoResponse=} [p] Properties to set
         */
        function ScheduleGetInfoResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ScheduleGetInfoResponse header.
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.ScheduleGetInfoResponse
         * @instance
         */
        ScheduleGetInfoResponse.prototype.header = null;

        /**
         * ScheduleGetInfoResponse scheduleInfo.
         * @member {proto.IScheduleInfo|null|undefined} scheduleInfo
         * @memberof proto.ScheduleGetInfoResponse
         * @instance
         */
        ScheduleGetInfoResponse.prototype.scheduleInfo = null;

        /**
         * Creates a new ScheduleGetInfoResponse instance using the specified properties.
         * @function create
         * @memberof proto.ScheduleGetInfoResponse
         * @static
         * @param {proto.IScheduleGetInfoResponse=} [properties] Properties to set
         * @returns {proto.ScheduleGetInfoResponse} ScheduleGetInfoResponse instance
         */
        ScheduleGetInfoResponse.create = function create(properties) {
            return new ScheduleGetInfoResponse(properties);
        };

        /**
         * Encodes the specified ScheduleGetInfoResponse message. Does not implicitly {@link proto.ScheduleGetInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ScheduleGetInfoResponse
         * @static
         * @param {proto.IScheduleGetInfoResponse} m ScheduleGetInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ScheduleGetInfoResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.scheduleInfo != null && Object.hasOwnProperty.call(m, "scheduleInfo"))
                $root.proto.ScheduleInfo.encode(m.scheduleInfo, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ScheduleGetInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ScheduleGetInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ScheduleGetInfoResponse} ScheduleGetInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ScheduleGetInfoResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ScheduleGetInfoResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.scheduleInfo = $root.proto.ScheduleInfo.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ScheduleGetInfoResponse;
    })();

    proto.TokenGetAccountNftInfosQuery = (function() {

        /**
         * Properties of a TokenGetAccountNftInfosQuery.
         * @memberof proto
         * @interface ITokenGetAccountNftInfosQuery
         * @property {proto.IQueryHeader|null} [header] TokenGetAccountNftInfosQuery header
         * @property {proto.IAccountID|null} [accountID] TokenGetAccountNftInfosQuery accountID
         * @property {Long|null} [start] TokenGetAccountNftInfosQuery start
         * @property {Long|null} [end] TokenGetAccountNftInfosQuery end
         */

        /**
         * Constructs a new TokenGetAccountNftInfosQuery.
         * @memberof proto
         * @classdesc Represents a TokenGetAccountNftInfosQuery.
         * @implements ITokenGetAccountNftInfosQuery
         * @constructor
         * @param {proto.ITokenGetAccountNftInfosQuery=} [p] Properties to set
         */
        function TokenGetAccountNftInfosQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TokenGetAccountNftInfosQuery header.
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.TokenGetAccountNftInfosQuery
         * @instance
         */
        TokenGetAccountNftInfosQuery.prototype.header = null;

        /**
         * TokenGetAccountNftInfosQuery accountID.
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.TokenGetAccountNftInfosQuery
         * @instance
         */
        TokenGetAccountNftInfosQuery.prototype.accountID = null;

        /**
         * TokenGetAccountNftInfosQuery start.
         * @member {Long} start
         * @memberof proto.TokenGetAccountNftInfosQuery
         * @instance
         */
        TokenGetAccountNftInfosQuery.prototype.start = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TokenGetAccountNftInfosQuery end.
         * @member {Long} end
         * @memberof proto.TokenGetAccountNftInfosQuery
         * @instance
         */
        TokenGetAccountNftInfosQuery.prototype.end = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new TokenGetAccountNftInfosQuery instance using the specified properties.
         * @function create
         * @memberof proto.TokenGetAccountNftInfosQuery
         * @static
         * @param {proto.ITokenGetAccountNftInfosQuery=} [properties] Properties to set
         * @returns {proto.TokenGetAccountNftInfosQuery} TokenGetAccountNftInfosQuery instance
         */
        TokenGetAccountNftInfosQuery.create = function create(properties) {
            return new TokenGetAccountNftInfosQuery(properties);
        };

        /**
         * Encodes the specified TokenGetAccountNftInfosQuery message. Does not implicitly {@link proto.TokenGetAccountNftInfosQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenGetAccountNftInfosQuery
         * @static
         * @param {proto.ITokenGetAccountNftInfosQuery} m TokenGetAccountNftInfosQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenGetAccountNftInfosQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
            if (m.start != null && Object.hasOwnProperty.call(m, "start"))
                w.uint32(24).int64(m.start);
            if (m.end != null && Object.hasOwnProperty.call(m, "end"))
                w.uint32(32).int64(m.end);
            return w;
        };

        /**
         * Decodes a TokenGetAccountNftInfosQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenGetAccountNftInfosQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenGetAccountNftInfosQuery} TokenGetAccountNftInfosQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenGetAccountNftInfosQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenGetAccountNftInfosQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 3:
                    m.start = r.int64();
                    break;
                case 4:
                    m.end = r.int64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TokenGetAccountNftInfosQuery;
    })();

    proto.TokenGetAccountNftInfosResponse = (function() {

        /**
         * Properties of a TokenGetAccountNftInfosResponse.
         * @memberof proto
         * @interface ITokenGetAccountNftInfosResponse
         * @property {proto.IResponseHeader|null} [header] TokenGetAccountNftInfosResponse header
         * @property {Array.<proto.ITokenNftInfo>|null} [nfts] TokenGetAccountNftInfosResponse nfts
         */

        /**
         * Constructs a new TokenGetAccountNftInfosResponse.
         * @memberof proto
         * @classdesc Represents a TokenGetAccountNftInfosResponse.
         * @implements ITokenGetAccountNftInfosResponse
         * @constructor
         * @param {proto.ITokenGetAccountNftInfosResponse=} [p] Properties to set
         */
        function TokenGetAccountNftInfosResponse(p) {
            this.nfts = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TokenGetAccountNftInfosResponse header.
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.TokenGetAccountNftInfosResponse
         * @instance
         */
        TokenGetAccountNftInfosResponse.prototype.header = null;

        /**
         * TokenGetAccountNftInfosResponse nfts.
         * @member {Array.<proto.ITokenNftInfo>} nfts
         * @memberof proto.TokenGetAccountNftInfosResponse
         * @instance
         */
        TokenGetAccountNftInfosResponse.prototype.nfts = $util.emptyArray;

        /**
         * Creates a new TokenGetAccountNftInfosResponse instance using the specified properties.
         * @function create
         * @memberof proto.TokenGetAccountNftInfosResponse
         * @static
         * @param {proto.ITokenGetAccountNftInfosResponse=} [properties] Properties to set
         * @returns {proto.TokenGetAccountNftInfosResponse} TokenGetAccountNftInfosResponse instance
         */
        TokenGetAccountNftInfosResponse.create = function create(properties) {
            return new TokenGetAccountNftInfosResponse(properties);
        };

        /**
         * Encodes the specified TokenGetAccountNftInfosResponse message. Does not implicitly {@link proto.TokenGetAccountNftInfosResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenGetAccountNftInfosResponse
         * @static
         * @param {proto.ITokenGetAccountNftInfosResponse} m TokenGetAccountNftInfosResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenGetAccountNftInfosResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.nfts != null && m.nfts.length) {
                for (var i = 0; i < m.nfts.length; ++i)
                    $root.proto.TokenNftInfo.encode(m.nfts[i], w.uint32(18).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TokenGetAccountNftInfosResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenGetAccountNftInfosResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenGetAccountNftInfosResponse} TokenGetAccountNftInfosResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenGetAccountNftInfosResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenGetAccountNftInfosResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                    break;
                case 2:
                    if (!(m.nfts && m.nfts.length))
                        m.nfts = [];
                    m.nfts.push($root.proto.TokenNftInfo.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TokenGetAccountNftInfosResponse;
    })();

    proto.NftID = (function() {

        /**
         * Properties of a NftID.
         * @memberof proto
         * @interface INftID
         * @property {proto.ITokenID|null} [tokenID] NftID tokenID
         * @property {Long|null} [serialNumber] NftID serialNumber
         */

        /**
         * Constructs a new NftID.
         * @memberof proto
         * @classdesc Represents a NftID.
         * @implements INftID
         * @constructor
         * @param {proto.INftID=} [p] Properties to set
         */
        function NftID(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * NftID tokenID.
         * @member {proto.ITokenID|null|undefined} tokenID
         * @memberof proto.NftID
         * @instance
         */
        NftID.prototype.tokenID = null;

        /**
         * NftID serialNumber.
         * @member {Long} serialNumber
         * @memberof proto.NftID
         * @instance
         */
        NftID.prototype.serialNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new NftID instance using the specified properties.
         * @function create
         * @memberof proto.NftID
         * @static
         * @param {proto.INftID=} [properties] Properties to set
         * @returns {proto.NftID} NftID instance
         */
        NftID.create = function create(properties) {
            return new NftID(properties);
        };

        /**
         * Encodes the specified NftID message. Does not implicitly {@link proto.NftID.verify|verify} messages.
         * @function encode
         * @memberof proto.NftID
         * @static
         * @param {proto.INftID} m NftID message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NftID.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.tokenID != null && Object.hasOwnProperty.call(m, "tokenID"))
                $root.proto.TokenID.encode(m.tokenID, w.uint32(10).fork()).ldelim();
            if (m.serialNumber != null && Object.hasOwnProperty.call(m, "serialNumber"))
                w.uint32(16).int64(m.serialNumber);
            return w;
        };

        /**
         * Decodes a NftID message from the specified reader or buffer.
         * @function decode
         * @memberof proto.NftID
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.NftID} NftID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NftID.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.NftID();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.tokenID = $root.proto.TokenID.decode(r, r.uint32());
                    break;
                case 2:
                    m.serialNumber = r.int64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return NftID;
    })();

    proto.TokenGetNftInfoQuery = (function() {

        /**
         * Properties of a TokenGetNftInfoQuery.
         * @memberof proto
         * @interface ITokenGetNftInfoQuery
         * @property {proto.IQueryHeader|null} [header] TokenGetNftInfoQuery header
         * @property {proto.INftID|null} [nftID] TokenGetNftInfoQuery nftID
         */

        /**
         * Constructs a new TokenGetNftInfoQuery.
         * @memberof proto
         * @classdesc Represents a TokenGetNftInfoQuery.
         * @implements ITokenGetNftInfoQuery
         * @constructor
         * @param {proto.ITokenGetNftInfoQuery=} [p] Properties to set
         */
        function TokenGetNftInfoQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TokenGetNftInfoQuery header.
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.TokenGetNftInfoQuery
         * @instance
         */
        TokenGetNftInfoQuery.prototype.header = null;

        /**
         * TokenGetNftInfoQuery nftID.
         * @member {proto.INftID|null|undefined} nftID
         * @memberof proto.TokenGetNftInfoQuery
         * @instance
         */
        TokenGetNftInfoQuery.prototype.nftID = null;

        /**
         * Creates a new TokenGetNftInfoQuery instance using the specified properties.
         * @function create
         * @memberof proto.TokenGetNftInfoQuery
         * @static
         * @param {proto.ITokenGetNftInfoQuery=} [properties] Properties to set
         * @returns {proto.TokenGetNftInfoQuery} TokenGetNftInfoQuery instance
         */
        TokenGetNftInfoQuery.create = function create(properties) {
            return new TokenGetNftInfoQuery(properties);
        };

        /**
         * Encodes the specified TokenGetNftInfoQuery message. Does not implicitly {@link proto.TokenGetNftInfoQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenGetNftInfoQuery
         * @static
         * @param {proto.ITokenGetNftInfoQuery} m TokenGetNftInfoQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenGetNftInfoQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.nftID != null && Object.hasOwnProperty.call(m, "nftID"))
                $root.proto.NftID.encode(m.nftID, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenGetNftInfoQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenGetNftInfoQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenGetNftInfoQuery} TokenGetNftInfoQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenGetNftInfoQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenGetNftInfoQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.nftID = $root.proto.NftID.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TokenGetNftInfoQuery;
    })();

    proto.TokenNftInfo = (function() {

        /**
         * Properties of a TokenNftInfo.
         * @memberof proto
         * @interface ITokenNftInfo
         * @property {proto.INftID|null} [nftID] TokenNftInfo nftID
         * @property {proto.IAccountID|null} [accountID] TokenNftInfo accountID
         * @property {proto.ITimestamp|null} [creationTime] TokenNftInfo creationTime
         * @property {Uint8Array|null} [metadata] TokenNftInfo metadata
         */

        /**
         * Constructs a new TokenNftInfo.
         * @memberof proto
         * @classdesc Represents a TokenNftInfo.
         * @implements ITokenNftInfo
         * @constructor
         * @param {proto.ITokenNftInfo=} [p] Properties to set
         */
        function TokenNftInfo(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TokenNftInfo nftID.
         * @member {proto.INftID|null|undefined} nftID
         * @memberof proto.TokenNftInfo
         * @instance
         */
        TokenNftInfo.prototype.nftID = null;

        /**
         * TokenNftInfo accountID.
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.TokenNftInfo
         * @instance
         */
        TokenNftInfo.prototype.accountID = null;

        /**
         * TokenNftInfo creationTime.
         * @member {proto.ITimestamp|null|undefined} creationTime
         * @memberof proto.TokenNftInfo
         * @instance
         */
        TokenNftInfo.prototype.creationTime = null;

        /**
         * TokenNftInfo metadata.
         * @member {Uint8Array} metadata
         * @memberof proto.TokenNftInfo
         * @instance
         */
        TokenNftInfo.prototype.metadata = $util.newBuffer([]);

        /**
         * Creates a new TokenNftInfo instance using the specified properties.
         * @function create
         * @memberof proto.TokenNftInfo
         * @static
         * @param {proto.ITokenNftInfo=} [properties] Properties to set
         * @returns {proto.TokenNftInfo} TokenNftInfo instance
         */
        TokenNftInfo.create = function create(properties) {
            return new TokenNftInfo(properties);
        };

        /**
         * Encodes the specified TokenNftInfo message. Does not implicitly {@link proto.TokenNftInfo.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenNftInfo
         * @static
         * @param {proto.ITokenNftInfo} m TokenNftInfo message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenNftInfo.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.nftID != null && Object.hasOwnProperty.call(m, "nftID"))
                $root.proto.NftID.encode(m.nftID, w.uint32(10).fork()).ldelim();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
            if (m.creationTime != null && Object.hasOwnProperty.call(m, "creationTime"))
                $root.proto.Timestamp.encode(m.creationTime, w.uint32(26).fork()).ldelim();
            if (m.metadata != null && Object.hasOwnProperty.call(m, "metadata"))
                w.uint32(34).bytes(m.metadata);
            return w;
        };

        /**
         * Decodes a TokenNftInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenNftInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenNftInfo} TokenNftInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenNftInfo.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenNftInfo();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.nftID = $root.proto.NftID.decode(r, r.uint32());
                    break;
                case 2:
                    m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 3:
                    m.creationTime = $root.proto.Timestamp.decode(r, r.uint32());
                    break;
                case 4:
                    m.metadata = r.bytes();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TokenNftInfo;
    })();

    proto.TokenGetNftInfoResponse = (function() {

        /**
         * Properties of a TokenGetNftInfoResponse.
         * @memberof proto
         * @interface ITokenGetNftInfoResponse
         * @property {proto.IResponseHeader|null} [header] TokenGetNftInfoResponse header
         * @property {proto.ITokenNftInfo|null} [nft] TokenGetNftInfoResponse nft
         */

        /**
         * Constructs a new TokenGetNftInfoResponse.
         * @memberof proto
         * @classdesc Represents a TokenGetNftInfoResponse.
         * @implements ITokenGetNftInfoResponse
         * @constructor
         * @param {proto.ITokenGetNftInfoResponse=} [p] Properties to set
         */
        function TokenGetNftInfoResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TokenGetNftInfoResponse header.
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.TokenGetNftInfoResponse
         * @instance
         */
        TokenGetNftInfoResponse.prototype.header = null;

        /**
         * TokenGetNftInfoResponse nft.
         * @member {proto.ITokenNftInfo|null|undefined} nft
         * @memberof proto.TokenGetNftInfoResponse
         * @instance
         */
        TokenGetNftInfoResponse.prototype.nft = null;

        /**
         * Creates a new TokenGetNftInfoResponse instance using the specified properties.
         * @function create
         * @memberof proto.TokenGetNftInfoResponse
         * @static
         * @param {proto.ITokenGetNftInfoResponse=} [properties] Properties to set
         * @returns {proto.TokenGetNftInfoResponse} TokenGetNftInfoResponse instance
         */
        TokenGetNftInfoResponse.create = function create(properties) {
            return new TokenGetNftInfoResponse(properties);
        };

        /**
         * Encodes the specified TokenGetNftInfoResponse message. Does not implicitly {@link proto.TokenGetNftInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenGetNftInfoResponse
         * @static
         * @param {proto.ITokenGetNftInfoResponse} m TokenGetNftInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenGetNftInfoResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.nft != null && Object.hasOwnProperty.call(m, "nft"))
                $root.proto.TokenNftInfo.encode(m.nft, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a TokenGetNftInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenGetNftInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenGetNftInfoResponse} TokenGetNftInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenGetNftInfoResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenGetNftInfoResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.nft = $root.proto.TokenNftInfo.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TokenGetNftInfoResponse;
    })();

    proto.TokenGetNftInfosQuery = (function() {

        /**
         * Properties of a TokenGetNftInfosQuery.
         * @memberof proto
         * @interface ITokenGetNftInfosQuery
         * @property {proto.IQueryHeader|null} [header] TokenGetNftInfosQuery header
         * @property {proto.ITokenID|null} [tokenID] TokenGetNftInfosQuery tokenID
         * @property {Long|null} [start] TokenGetNftInfosQuery start
         * @property {Long|null} [end] TokenGetNftInfosQuery end
         */

        /**
         * Constructs a new TokenGetNftInfosQuery.
         * @memberof proto
         * @classdesc Represents a TokenGetNftInfosQuery.
         * @implements ITokenGetNftInfosQuery
         * @constructor
         * @param {proto.ITokenGetNftInfosQuery=} [p] Properties to set
         */
        function TokenGetNftInfosQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TokenGetNftInfosQuery header.
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.TokenGetNftInfosQuery
         * @instance
         */
        TokenGetNftInfosQuery.prototype.header = null;

        /**
         * TokenGetNftInfosQuery tokenID.
         * @member {proto.ITokenID|null|undefined} tokenID
         * @memberof proto.TokenGetNftInfosQuery
         * @instance
         */
        TokenGetNftInfosQuery.prototype.tokenID = null;

        /**
         * TokenGetNftInfosQuery start.
         * @member {Long} start
         * @memberof proto.TokenGetNftInfosQuery
         * @instance
         */
        TokenGetNftInfosQuery.prototype.start = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TokenGetNftInfosQuery end.
         * @member {Long} end
         * @memberof proto.TokenGetNftInfosQuery
         * @instance
         */
        TokenGetNftInfosQuery.prototype.end = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new TokenGetNftInfosQuery instance using the specified properties.
         * @function create
         * @memberof proto.TokenGetNftInfosQuery
         * @static
         * @param {proto.ITokenGetNftInfosQuery=} [properties] Properties to set
         * @returns {proto.TokenGetNftInfosQuery} TokenGetNftInfosQuery instance
         */
        TokenGetNftInfosQuery.create = function create(properties) {
            return new TokenGetNftInfosQuery(properties);
        };

        /**
         * Encodes the specified TokenGetNftInfosQuery message. Does not implicitly {@link proto.TokenGetNftInfosQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenGetNftInfosQuery
         * @static
         * @param {proto.ITokenGetNftInfosQuery} m TokenGetNftInfosQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenGetNftInfosQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.tokenID != null && Object.hasOwnProperty.call(m, "tokenID"))
                $root.proto.TokenID.encode(m.tokenID, w.uint32(18).fork()).ldelim();
            if (m.start != null && Object.hasOwnProperty.call(m, "start"))
                w.uint32(24).int64(m.start);
            if (m.end != null && Object.hasOwnProperty.call(m, "end"))
                w.uint32(32).int64(m.end);
            return w;
        };

        /**
         * Decodes a TokenGetNftInfosQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenGetNftInfosQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenGetNftInfosQuery} TokenGetNftInfosQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenGetNftInfosQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenGetNftInfosQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.tokenID = $root.proto.TokenID.decode(r, r.uint32());
                    break;
                case 3:
                    m.start = r.int64();
                    break;
                case 4:
                    m.end = r.int64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TokenGetNftInfosQuery;
    })();

    proto.TokenGetNftInfosResponse = (function() {

        /**
         * Properties of a TokenGetNftInfosResponse.
         * @memberof proto
         * @interface ITokenGetNftInfosResponse
         * @property {proto.IResponseHeader|null} [header] TokenGetNftInfosResponse header
         * @property {proto.ITokenID|null} [tokenID] TokenGetNftInfosResponse tokenID
         * @property {Array.<proto.ITokenNftInfo>|null} [nfts] TokenGetNftInfosResponse nfts
         */

        /**
         * Constructs a new TokenGetNftInfosResponse.
         * @memberof proto
         * @classdesc Represents a TokenGetNftInfosResponse.
         * @implements ITokenGetNftInfosResponse
         * @constructor
         * @param {proto.ITokenGetNftInfosResponse=} [p] Properties to set
         */
        function TokenGetNftInfosResponse(p) {
            this.nfts = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TokenGetNftInfosResponse header.
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.TokenGetNftInfosResponse
         * @instance
         */
        TokenGetNftInfosResponse.prototype.header = null;

        /**
         * TokenGetNftInfosResponse tokenID.
         * @member {proto.ITokenID|null|undefined} tokenID
         * @memberof proto.TokenGetNftInfosResponse
         * @instance
         */
        TokenGetNftInfosResponse.prototype.tokenID = null;

        /**
         * TokenGetNftInfosResponse nfts.
         * @member {Array.<proto.ITokenNftInfo>} nfts
         * @memberof proto.TokenGetNftInfosResponse
         * @instance
         */
        TokenGetNftInfosResponse.prototype.nfts = $util.emptyArray;

        /**
         * Creates a new TokenGetNftInfosResponse instance using the specified properties.
         * @function create
         * @memberof proto.TokenGetNftInfosResponse
         * @static
         * @param {proto.ITokenGetNftInfosResponse=} [properties] Properties to set
         * @returns {proto.TokenGetNftInfosResponse} TokenGetNftInfosResponse instance
         */
        TokenGetNftInfosResponse.create = function create(properties) {
            return new TokenGetNftInfosResponse(properties);
        };

        /**
         * Encodes the specified TokenGetNftInfosResponse message. Does not implicitly {@link proto.TokenGetNftInfosResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenGetNftInfosResponse
         * @static
         * @param {proto.ITokenGetNftInfosResponse} m TokenGetNftInfosResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenGetNftInfosResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.tokenID != null && Object.hasOwnProperty.call(m, "tokenID"))
                $root.proto.TokenID.encode(m.tokenID, w.uint32(18).fork()).ldelim();
            if (m.nfts != null && m.nfts.length) {
                for (var i = 0; i < m.nfts.length; ++i)
                    $root.proto.TokenNftInfo.encode(m.nfts[i], w.uint32(26).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TokenGetNftInfosResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenGetNftInfosResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenGetNftInfosResponse} TokenGetNftInfosResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenGetNftInfosResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenGetNftInfosResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.tokenID = $root.proto.TokenID.decode(r, r.uint32());
                    break;
                case 3:
                    if (!(m.nfts && m.nfts.length))
                        m.nfts = [];
                    m.nfts.push($root.proto.TokenNftInfo.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TokenGetNftInfosResponse;
    })();

    proto.Response = (function() {

        /**
         * Properties of a Response.
         * @memberof proto
         * @interface IResponse
         * @property {proto.IGetByKeyResponse|null} [getByKey] Response getByKey
         * @property {proto.IGetBySolidityIDResponse|null} [getBySolidityID] Response getBySolidityID
         * @property {proto.IContractCallLocalResponse|null} [contractCallLocal] Response contractCallLocal
         * @property {proto.IContractGetBytecodeResponse|null} [contractGetBytecodeResponse] Response contractGetBytecodeResponse
         * @property {proto.IContractGetInfoResponse|null} [contractGetInfo] Response contractGetInfo
         * @property {proto.IContractGetRecordsResponse|null} [contractGetRecordsResponse] Response contractGetRecordsResponse
         * @property {proto.ICryptoGetAccountBalanceResponse|null} [cryptogetAccountBalance] Response cryptogetAccountBalance
         * @property {proto.ICryptoGetAccountRecordsResponse|null} [cryptoGetAccountRecords] Response cryptoGetAccountRecords
         * @property {proto.ICryptoGetInfoResponse|null} [cryptoGetInfo] Response cryptoGetInfo
         * @property {proto.ICryptoGetLiveHashResponse|null} [cryptoGetLiveHash] Response cryptoGetLiveHash
         * @property {proto.ICryptoGetStakersResponse|null} [cryptoGetProxyStakers] Response cryptoGetProxyStakers
         * @property {proto.IFileGetContentsResponse|null} [fileGetContents] Response fileGetContents
         * @property {proto.IFileGetInfoResponse|null} [fileGetInfo] Response fileGetInfo
         * @property {proto.ITransactionGetReceiptResponse|null} [transactionGetReceipt] Response transactionGetReceipt
         * @property {proto.ITransactionGetRecordResponse|null} [transactionGetRecord] Response transactionGetRecord
         * @property {proto.ITransactionGetFastRecordResponse|null} [transactionGetFastRecord] Response transactionGetFastRecord
         * @property {proto.IConsensusGetTopicInfoResponse|null} [consensusGetTopicInfo] Response consensusGetTopicInfo
         * @property {proto.INetworkGetVersionInfoResponse|null} [networkGetVersionInfo] Response networkGetVersionInfo
         * @property {proto.ITokenGetInfoResponse|null} [tokenGetInfo] Response tokenGetInfo
         * @property {proto.IScheduleGetInfoResponse|null} [scheduleGetInfo] Response scheduleGetInfo
         * @property {proto.ITokenGetAccountNftInfosResponse|null} [tokenGetAccountNftInfos] Response tokenGetAccountNftInfos
         * @property {proto.ITokenGetNftInfoResponse|null} [tokenGetNftInfo] Response tokenGetNftInfo
         * @property {proto.ITokenGetNftInfosResponse|null} [tokenGetNftInfos] Response tokenGetNftInfos
         */

        /**
         * Constructs a new Response.
         * @memberof proto
         * @classdesc Represents a Response.
         * @implements IResponse
         * @constructor
         * @param {proto.IResponse=} [p] Properties to set
         */
        function Response(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Response getByKey.
         * @member {proto.IGetByKeyResponse|null|undefined} getByKey
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.getByKey = null;

        /**
         * Response getBySolidityID.
         * @member {proto.IGetBySolidityIDResponse|null|undefined} getBySolidityID
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.getBySolidityID = null;

        /**
         * Response contractCallLocal.
         * @member {proto.IContractCallLocalResponse|null|undefined} contractCallLocal
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.contractCallLocal = null;

        /**
         * Response contractGetBytecodeResponse.
         * @member {proto.IContractGetBytecodeResponse|null|undefined} contractGetBytecodeResponse
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.contractGetBytecodeResponse = null;

        /**
         * Response contractGetInfo.
         * @member {proto.IContractGetInfoResponse|null|undefined} contractGetInfo
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.contractGetInfo = null;

        /**
         * Response contractGetRecordsResponse.
         * @member {proto.IContractGetRecordsResponse|null|undefined} contractGetRecordsResponse
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.contractGetRecordsResponse = null;

        /**
         * Response cryptogetAccountBalance.
         * @member {proto.ICryptoGetAccountBalanceResponse|null|undefined} cryptogetAccountBalance
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.cryptogetAccountBalance = null;

        /**
         * Response cryptoGetAccountRecords.
         * @member {proto.ICryptoGetAccountRecordsResponse|null|undefined} cryptoGetAccountRecords
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.cryptoGetAccountRecords = null;

        /**
         * Response cryptoGetInfo.
         * @member {proto.ICryptoGetInfoResponse|null|undefined} cryptoGetInfo
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.cryptoGetInfo = null;

        /**
         * Response cryptoGetLiveHash.
         * @member {proto.ICryptoGetLiveHashResponse|null|undefined} cryptoGetLiveHash
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.cryptoGetLiveHash = null;

        /**
         * Response cryptoGetProxyStakers.
         * @member {proto.ICryptoGetStakersResponse|null|undefined} cryptoGetProxyStakers
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.cryptoGetProxyStakers = null;

        /**
         * Response fileGetContents.
         * @member {proto.IFileGetContentsResponse|null|undefined} fileGetContents
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.fileGetContents = null;

        /**
         * Response fileGetInfo.
         * @member {proto.IFileGetInfoResponse|null|undefined} fileGetInfo
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.fileGetInfo = null;

        /**
         * Response transactionGetReceipt.
         * @member {proto.ITransactionGetReceiptResponse|null|undefined} transactionGetReceipt
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.transactionGetReceipt = null;

        /**
         * Response transactionGetRecord.
         * @member {proto.ITransactionGetRecordResponse|null|undefined} transactionGetRecord
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.transactionGetRecord = null;

        /**
         * Response transactionGetFastRecord.
         * @member {proto.ITransactionGetFastRecordResponse|null|undefined} transactionGetFastRecord
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.transactionGetFastRecord = null;

        /**
         * Response consensusGetTopicInfo.
         * @member {proto.IConsensusGetTopicInfoResponse|null|undefined} consensusGetTopicInfo
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.consensusGetTopicInfo = null;

        /**
         * Response networkGetVersionInfo.
         * @member {proto.INetworkGetVersionInfoResponse|null|undefined} networkGetVersionInfo
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.networkGetVersionInfo = null;

        /**
         * Response tokenGetInfo.
         * @member {proto.ITokenGetInfoResponse|null|undefined} tokenGetInfo
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.tokenGetInfo = null;

        /**
         * Response scheduleGetInfo.
         * @member {proto.IScheduleGetInfoResponse|null|undefined} scheduleGetInfo
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.scheduleGetInfo = null;

        /**
         * Response tokenGetAccountNftInfos.
         * @member {proto.ITokenGetAccountNftInfosResponse|null|undefined} tokenGetAccountNftInfos
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.tokenGetAccountNftInfos = null;

        /**
         * Response tokenGetNftInfo.
         * @member {proto.ITokenGetNftInfoResponse|null|undefined} tokenGetNftInfo
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.tokenGetNftInfo = null;

        /**
         * Response tokenGetNftInfos.
         * @member {proto.ITokenGetNftInfosResponse|null|undefined} tokenGetNftInfos
         * @memberof proto.Response
         * @instance
         */
        Response.prototype.tokenGetNftInfos = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * Response response.
         * @member {"getByKey"|"getBySolidityID"|"contractCallLocal"|"contractGetBytecodeResponse"|"contractGetInfo"|"contractGetRecordsResponse"|"cryptogetAccountBalance"|"cryptoGetAccountRecords"|"cryptoGetInfo"|"cryptoGetLiveHash"|"cryptoGetProxyStakers"|"fileGetContents"|"fileGetInfo"|"transactionGetReceipt"|"transactionGetRecord"|"transactionGetFastRecord"|"consensusGetTopicInfo"|"networkGetVersionInfo"|"tokenGetInfo"|"scheduleGetInfo"|"tokenGetAccountNftInfos"|"tokenGetNftInfo"|"tokenGetNftInfos"|undefined} response
         * @memberof proto.Response
         * @instance
         */
        Object.defineProperty(Response.prototype, "response", {
            get: $util.oneOfGetter($oneOfFields = ["getByKey", "getBySolidityID", "contractCallLocal", "contractGetBytecodeResponse", "contractGetInfo", "contractGetRecordsResponse", "cryptogetAccountBalance", "cryptoGetAccountRecords", "cryptoGetInfo", "cryptoGetLiveHash", "cryptoGetProxyStakers", "fileGetContents", "fileGetInfo", "transactionGetReceipt", "transactionGetRecord", "transactionGetFastRecord", "consensusGetTopicInfo", "networkGetVersionInfo", "tokenGetInfo", "scheduleGetInfo", "tokenGetAccountNftInfos", "tokenGetNftInfo", "tokenGetNftInfos"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Response instance using the specified properties.
         * @function create
         * @memberof proto.Response
         * @static
         * @param {proto.IResponse=} [properties] Properties to set
         * @returns {proto.Response} Response instance
         */
        Response.create = function create(properties) {
            return new Response(properties);
        };

        /**
         * Encodes the specified Response message. Does not implicitly {@link proto.Response.verify|verify} messages.
         * @function encode
         * @memberof proto.Response
         * @static
         * @param {proto.IResponse} m Response message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Response.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.getByKey != null && Object.hasOwnProperty.call(m, "getByKey"))
                $root.proto.GetByKeyResponse.encode(m.getByKey, w.uint32(10).fork()).ldelim();
            if (m.getBySolidityID != null && Object.hasOwnProperty.call(m, "getBySolidityID"))
                $root.proto.GetBySolidityIDResponse.encode(m.getBySolidityID, w.uint32(18).fork()).ldelim();
            if (m.contractCallLocal != null && Object.hasOwnProperty.call(m, "contractCallLocal"))
                $root.proto.ContractCallLocalResponse.encode(m.contractCallLocal, w.uint32(26).fork()).ldelim();
            if (m.contractGetInfo != null && Object.hasOwnProperty.call(m, "contractGetInfo"))
                $root.proto.ContractGetInfoResponse.encode(m.contractGetInfo, w.uint32(34).fork()).ldelim();
            if (m.contractGetBytecodeResponse != null && Object.hasOwnProperty.call(m, "contractGetBytecodeResponse"))
                $root.proto.ContractGetBytecodeResponse.encode(m.contractGetBytecodeResponse, w.uint32(42).fork()).ldelim();
            if (m.contractGetRecordsResponse != null && Object.hasOwnProperty.call(m, "contractGetRecordsResponse"))
                $root.proto.ContractGetRecordsResponse.encode(m.contractGetRecordsResponse, w.uint32(50).fork()).ldelim();
            if (m.cryptogetAccountBalance != null && Object.hasOwnProperty.call(m, "cryptogetAccountBalance"))
                $root.proto.CryptoGetAccountBalanceResponse.encode(m.cryptogetAccountBalance, w.uint32(58).fork()).ldelim();
            if (m.cryptoGetAccountRecords != null && Object.hasOwnProperty.call(m, "cryptoGetAccountRecords"))
                $root.proto.CryptoGetAccountRecordsResponse.encode(m.cryptoGetAccountRecords, w.uint32(66).fork()).ldelim();
            if (m.cryptoGetInfo != null && Object.hasOwnProperty.call(m, "cryptoGetInfo"))
                $root.proto.CryptoGetInfoResponse.encode(m.cryptoGetInfo, w.uint32(74).fork()).ldelim();
            if (m.cryptoGetLiveHash != null && Object.hasOwnProperty.call(m, "cryptoGetLiveHash"))
                $root.proto.CryptoGetLiveHashResponse.encode(m.cryptoGetLiveHash, w.uint32(82).fork()).ldelim();
            if (m.cryptoGetProxyStakers != null && Object.hasOwnProperty.call(m, "cryptoGetProxyStakers"))
                $root.proto.CryptoGetStakersResponse.encode(m.cryptoGetProxyStakers, w.uint32(90).fork()).ldelim();
            if (m.fileGetContents != null && Object.hasOwnProperty.call(m, "fileGetContents"))
                $root.proto.FileGetContentsResponse.encode(m.fileGetContents, w.uint32(98).fork()).ldelim();
            if (m.fileGetInfo != null && Object.hasOwnProperty.call(m, "fileGetInfo"))
                $root.proto.FileGetInfoResponse.encode(m.fileGetInfo, w.uint32(106).fork()).ldelim();
            if (m.transactionGetReceipt != null && Object.hasOwnProperty.call(m, "transactionGetReceipt"))
                $root.proto.TransactionGetReceiptResponse.encode(m.transactionGetReceipt, w.uint32(114).fork()).ldelim();
            if (m.transactionGetRecord != null && Object.hasOwnProperty.call(m, "transactionGetRecord"))
                $root.proto.TransactionGetRecordResponse.encode(m.transactionGetRecord, w.uint32(122).fork()).ldelim();
            if (m.transactionGetFastRecord != null && Object.hasOwnProperty.call(m, "transactionGetFastRecord"))
                $root.proto.TransactionGetFastRecordResponse.encode(m.transactionGetFastRecord, w.uint32(130).fork()).ldelim();
            if (m.consensusGetTopicInfo != null && Object.hasOwnProperty.call(m, "consensusGetTopicInfo"))
                $root.proto.ConsensusGetTopicInfoResponse.encode(m.consensusGetTopicInfo, w.uint32(1202).fork()).ldelim();
            if (m.networkGetVersionInfo != null && Object.hasOwnProperty.call(m, "networkGetVersionInfo"))
                $root.proto.NetworkGetVersionInfoResponse.encode(m.networkGetVersionInfo, w.uint32(1210).fork()).ldelim();
            if (m.tokenGetInfo != null && Object.hasOwnProperty.call(m, "tokenGetInfo"))
                $root.proto.TokenGetInfoResponse.encode(m.tokenGetInfo, w.uint32(1218).fork()).ldelim();
            if (m.scheduleGetInfo != null && Object.hasOwnProperty.call(m, "scheduleGetInfo"))
                $root.proto.ScheduleGetInfoResponse.encode(m.scheduleGetInfo, w.uint32(1226).fork()).ldelim();
            if (m.tokenGetAccountNftInfos != null && Object.hasOwnProperty.call(m, "tokenGetAccountNftInfos"))
                $root.proto.TokenGetAccountNftInfosResponse.encode(m.tokenGetAccountNftInfos, w.uint32(1234).fork()).ldelim();
            if (m.tokenGetNftInfo != null && Object.hasOwnProperty.call(m, "tokenGetNftInfo"))
                $root.proto.TokenGetNftInfoResponse.encode(m.tokenGetNftInfo, w.uint32(1242).fork()).ldelim();
            if (m.tokenGetNftInfos != null && Object.hasOwnProperty.call(m, "tokenGetNftInfos"))
                $root.proto.TokenGetNftInfosResponse.encode(m.tokenGetNftInfos, w.uint32(1250).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a Response message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.Response} Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Response.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.Response();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.getByKey = $root.proto.GetByKeyResponse.decode(r, r.uint32());
                    break;
                case 2:
                    m.getBySolidityID = $root.proto.GetBySolidityIDResponse.decode(r, r.uint32());
                    break;
                case 3:
                    m.contractCallLocal = $root.proto.ContractCallLocalResponse.decode(r, r.uint32());
                    break;
                case 5:
                    m.contractGetBytecodeResponse = $root.proto.ContractGetBytecodeResponse.decode(r, r.uint32());
                    break;
                case 4:
                    m.contractGetInfo = $root.proto.ContractGetInfoResponse.decode(r, r.uint32());
                    break;
                case 6:
                    m.contractGetRecordsResponse = $root.proto.ContractGetRecordsResponse.decode(r, r.uint32());
                    break;
                case 7:
                    m.cryptogetAccountBalance = $root.proto.CryptoGetAccountBalanceResponse.decode(r, r.uint32());
                    break;
                case 8:
                    m.cryptoGetAccountRecords = $root.proto.CryptoGetAccountRecordsResponse.decode(r, r.uint32());
                    break;
                case 9:
                    m.cryptoGetInfo = $root.proto.CryptoGetInfoResponse.decode(r, r.uint32());
                    break;
                case 10:
                    m.cryptoGetLiveHash = $root.proto.CryptoGetLiveHashResponse.decode(r, r.uint32());
                    break;
                case 11:
                    m.cryptoGetProxyStakers = $root.proto.CryptoGetStakersResponse.decode(r, r.uint32());
                    break;
                case 12:
                    m.fileGetContents = $root.proto.FileGetContentsResponse.decode(r, r.uint32());
                    break;
                case 13:
                    m.fileGetInfo = $root.proto.FileGetInfoResponse.decode(r, r.uint32());
                    break;
                case 14:
                    m.transactionGetReceipt = $root.proto.TransactionGetReceiptResponse.decode(r, r.uint32());
                    break;
                case 15:
                    m.transactionGetRecord = $root.proto.TransactionGetRecordResponse.decode(r, r.uint32());
                    break;
                case 16:
                    m.transactionGetFastRecord = $root.proto.TransactionGetFastRecordResponse.decode(r, r.uint32());
                    break;
                case 150:
                    m.consensusGetTopicInfo = $root.proto.ConsensusGetTopicInfoResponse.decode(r, r.uint32());
                    break;
                case 151:
                    m.networkGetVersionInfo = $root.proto.NetworkGetVersionInfoResponse.decode(r, r.uint32());
                    break;
                case 152:
                    m.tokenGetInfo = $root.proto.TokenGetInfoResponse.decode(r, r.uint32());
                    break;
                case 153:
                    m.scheduleGetInfo = $root.proto.ScheduleGetInfoResponse.decode(r, r.uint32());
                    break;
                case 154:
                    m.tokenGetAccountNftInfos = $root.proto.TokenGetAccountNftInfosResponse.decode(r, r.uint32());
                    break;
                case 155:
                    m.tokenGetNftInfo = $root.proto.TokenGetNftInfoResponse.decode(r, r.uint32());
                    break;
                case 156:
                    m.tokenGetNftInfos = $root.proto.TokenGetNftInfosResponse.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return Response;
    })();

    proto.Claim = (function() {

        /**
         * Properties of a Claim.
         * @memberof proto
         * @interface IClaim
         * @property {proto.IAccountID|null} [accountID] Claim accountID
         * @property {Uint8Array|null} [hash] Claim hash
         * @property {proto.IKeyList|null} [keys] Claim keys
         * @property {proto.IDuration|null} [claimDuration] Claim claimDuration
         */

        /**
         * Constructs a new Claim.
         * @memberof proto
         * @classdesc Represents a Claim.
         * @implements IClaim
         * @constructor
         * @param {proto.IClaim=} [p] Properties to set
         */
        function Claim(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Claim accountID.
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.Claim
         * @instance
         */
        Claim.prototype.accountID = null;

        /**
         * Claim hash.
         * @member {Uint8Array} hash
         * @memberof proto.Claim
         * @instance
         */
        Claim.prototype.hash = $util.newBuffer([]);

        /**
         * Claim keys.
         * @member {proto.IKeyList|null|undefined} keys
         * @memberof proto.Claim
         * @instance
         */
        Claim.prototype.keys = null;

        /**
         * Claim claimDuration.
         * @member {proto.IDuration|null|undefined} claimDuration
         * @memberof proto.Claim
         * @instance
         */
        Claim.prototype.claimDuration = null;

        /**
         * Creates a new Claim instance using the specified properties.
         * @function create
         * @memberof proto.Claim
         * @static
         * @param {proto.IClaim=} [properties] Properties to set
         * @returns {proto.Claim} Claim instance
         */
        Claim.create = function create(properties) {
            return new Claim(properties);
        };

        /**
         * Encodes the specified Claim message. Does not implicitly {@link proto.Claim.verify|verify} messages.
         * @function encode
         * @memberof proto.Claim
         * @static
         * @param {proto.IClaim} m Claim message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Claim.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(10).fork()).ldelim();
            if (m.hash != null && Object.hasOwnProperty.call(m, "hash"))
                w.uint32(18).bytes(m.hash);
            if (m.keys != null && Object.hasOwnProperty.call(m, "keys"))
                $root.proto.KeyList.encode(m.keys, w.uint32(26).fork()).ldelim();
            if (m.claimDuration != null && Object.hasOwnProperty.call(m, "claimDuration"))
                $root.proto.Duration.encode(m.claimDuration, w.uint32(42).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a Claim message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Claim
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.Claim} Claim
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Claim.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.Claim();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 2:
                    m.hash = r.bytes();
                    break;
                case 3:
                    m.keys = $root.proto.KeyList.decode(r, r.uint32());
                    break;
                case 5:
                    m.claimDuration = $root.proto.Duration.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return Claim;
    })();

    proto.CryptoAddClaimTransactionBody = (function() {

        /**
         * Properties of a CryptoAddClaimTransactionBody.
         * @memberof proto
         * @interface ICryptoAddClaimTransactionBody
         * @property {proto.IClaim|null} [claim] CryptoAddClaimTransactionBody claim
         */

        /**
         * Constructs a new CryptoAddClaimTransactionBody.
         * @memberof proto
         * @classdesc Represents a CryptoAddClaimTransactionBody.
         * @implements ICryptoAddClaimTransactionBody
         * @constructor
         * @param {proto.ICryptoAddClaimTransactionBody=} [p] Properties to set
         */
        function CryptoAddClaimTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * CryptoAddClaimTransactionBody claim.
         * @member {proto.IClaim|null|undefined} claim
         * @memberof proto.CryptoAddClaimTransactionBody
         * @instance
         */
        CryptoAddClaimTransactionBody.prototype.claim = null;

        /**
         * Creates a new CryptoAddClaimTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.CryptoAddClaimTransactionBody
         * @static
         * @param {proto.ICryptoAddClaimTransactionBody=} [properties] Properties to set
         * @returns {proto.CryptoAddClaimTransactionBody} CryptoAddClaimTransactionBody instance
         */
        CryptoAddClaimTransactionBody.create = function create(properties) {
            return new CryptoAddClaimTransactionBody(properties);
        };

        /**
         * Encodes the specified CryptoAddClaimTransactionBody message. Does not implicitly {@link proto.CryptoAddClaimTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoAddClaimTransactionBody
         * @static
         * @param {proto.ICryptoAddClaimTransactionBody} m CryptoAddClaimTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoAddClaimTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.claim != null && Object.hasOwnProperty.call(m, "claim"))
                $root.proto.Claim.encode(m.claim, w.uint32(26).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a CryptoAddClaimTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoAddClaimTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoAddClaimTransactionBody} CryptoAddClaimTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoAddClaimTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoAddClaimTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 3:
                    m.claim = $root.proto.Claim.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return CryptoAddClaimTransactionBody;
    })();

    proto.CryptoDeleteClaimTransactionBody = (function() {

        /**
         * Properties of a CryptoDeleteClaimTransactionBody.
         * @memberof proto
         * @interface ICryptoDeleteClaimTransactionBody
         * @property {proto.IAccountID|null} [accountIDToDeleteFrom] CryptoDeleteClaimTransactionBody accountIDToDeleteFrom
         * @property {Uint8Array|null} [hashToDelete] CryptoDeleteClaimTransactionBody hashToDelete
         */

        /**
         * Constructs a new CryptoDeleteClaimTransactionBody.
         * @memberof proto
         * @classdesc Represents a CryptoDeleteClaimTransactionBody.
         * @implements ICryptoDeleteClaimTransactionBody
         * @constructor
         * @param {proto.ICryptoDeleteClaimTransactionBody=} [p] Properties to set
         */
        function CryptoDeleteClaimTransactionBody(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * CryptoDeleteClaimTransactionBody accountIDToDeleteFrom.
         * @member {proto.IAccountID|null|undefined} accountIDToDeleteFrom
         * @memberof proto.CryptoDeleteClaimTransactionBody
         * @instance
         */
        CryptoDeleteClaimTransactionBody.prototype.accountIDToDeleteFrom = null;

        /**
         * CryptoDeleteClaimTransactionBody hashToDelete.
         * @member {Uint8Array} hashToDelete
         * @memberof proto.CryptoDeleteClaimTransactionBody
         * @instance
         */
        CryptoDeleteClaimTransactionBody.prototype.hashToDelete = $util.newBuffer([]);

        /**
         * Creates a new CryptoDeleteClaimTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.CryptoDeleteClaimTransactionBody
         * @static
         * @param {proto.ICryptoDeleteClaimTransactionBody=} [properties] Properties to set
         * @returns {proto.CryptoDeleteClaimTransactionBody} CryptoDeleteClaimTransactionBody instance
         */
        CryptoDeleteClaimTransactionBody.create = function create(properties) {
            return new CryptoDeleteClaimTransactionBody(properties);
        };

        /**
         * Encodes the specified CryptoDeleteClaimTransactionBody message. Does not implicitly {@link proto.CryptoDeleteClaimTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoDeleteClaimTransactionBody
         * @static
         * @param {proto.ICryptoDeleteClaimTransactionBody} m CryptoDeleteClaimTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoDeleteClaimTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.accountIDToDeleteFrom != null && Object.hasOwnProperty.call(m, "accountIDToDeleteFrom"))
                $root.proto.AccountID.encode(m.accountIDToDeleteFrom, w.uint32(10).fork()).ldelim();
            if (m.hashToDelete != null && Object.hasOwnProperty.call(m, "hashToDelete"))
                w.uint32(18).bytes(m.hashToDelete);
            return w;
        };

        /**
         * Decodes a CryptoDeleteClaimTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoDeleteClaimTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoDeleteClaimTransactionBody} CryptoDeleteClaimTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoDeleteClaimTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoDeleteClaimTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.accountIDToDeleteFrom = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 2:
                    m.hashToDelete = r.bytes();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return CryptoDeleteClaimTransactionBody;
    })();

    proto.CryptoGetClaimQuery = (function() {

        /**
         * Properties of a CryptoGetClaimQuery.
         * @memberof proto
         * @interface ICryptoGetClaimQuery
         * @property {proto.IQueryHeader|null} [header] CryptoGetClaimQuery header
         * @property {proto.IAccountID|null} [accountID] CryptoGetClaimQuery accountID
         * @property {Uint8Array|null} [hash] CryptoGetClaimQuery hash
         */

        /**
         * Constructs a new CryptoGetClaimQuery.
         * @memberof proto
         * @classdesc Represents a CryptoGetClaimQuery.
         * @implements ICryptoGetClaimQuery
         * @constructor
         * @param {proto.ICryptoGetClaimQuery=} [p] Properties to set
         */
        function CryptoGetClaimQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * CryptoGetClaimQuery header.
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.CryptoGetClaimQuery
         * @instance
         */
        CryptoGetClaimQuery.prototype.header = null;

        /**
         * CryptoGetClaimQuery accountID.
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.CryptoGetClaimQuery
         * @instance
         */
        CryptoGetClaimQuery.prototype.accountID = null;

        /**
         * CryptoGetClaimQuery hash.
         * @member {Uint8Array} hash
         * @memberof proto.CryptoGetClaimQuery
         * @instance
         */
        CryptoGetClaimQuery.prototype.hash = $util.newBuffer([]);

        /**
         * Creates a new CryptoGetClaimQuery instance using the specified properties.
         * @function create
         * @memberof proto.CryptoGetClaimQuery
         * @static
         * @param {proto.ICryptoGetClaimQuery=} [properties] Properties to set
         * @returns {proto.CryptoGetClaimQuery} CryptoGetClaimQuery instance
         */
        CryptoGetClaimQuery.create = function create(properties) {
            return new CryptoGetClaimQuery(properties);
        };

        /**
         * Encodes the specified CryptoGetClaimQuery message. Does not implicitly {@link proto.CryptoGetClaimQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoGetClaimQuery
         * @static
         * @param {proto.ICryptoGetClaimQuery} m CryptoGetClaimQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoGetClaimQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
            if (m.hash != null && Object.hasOwnProperty.call(m, "hash"))
                w.uint32(26).bytes(m.hash);
            return w;
        };

        /**
         * Decodes a CryptoGetClaimQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoGetClaimQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoGetClaimQuery} CryptoGetClaimQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoGetClaimQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoGetClaimQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 3:
                    m.hash = r.bytes();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return CryptoGetClaimQuery;
    })();

    proto.CryptoGetClaimResponse = (function() {

        /**
         * Properties of a CryptoGetClaimResponse.
         * @memberof proto
         * @interface ICryptoGetClaimResponse
         * @property {proto.IResponseHeader|null} [header] CryptoGetClaimResponse header
         * @property {proto.IClaim|null} [claim] CryptoGetClaimResponse claim
         */

        /**
         * Constructs a new CryptoGetClaimResponse.
         * @memberof proto
         * @classdesc Represents a CryptoGetClaimResponse.
         * @implements ICryptoGetClaimResponse
         * @constructor
         * @param {proto.ICryptoGetClaimResponse=} [p] Properties to set
         */
        function CryptoGetClaimResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * CryptoGetClaimResponse header.
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.CryptoGetClaimResponse
         * @instance
         */
        CryptoGetClaimResponse.prototype.header = null;

        /**
         * CryptoGetClaimResponse claim.
         * @member {proto.IClaim|null|undefined} claim
         * @memberof proto.CryptoGetClaimResponse
         * @instance
         */
        CryptoGetClaimResponse.prototype.claim = null;

        /**
         * Creates a new CryptoGetClaimResponse instance using the specified properties.
         * @function create
         * @memberof proto.CryptoGetClaimResponse
         * @static
         * @param {proto.ICryptoGetClaimResponse=} [properties] Properties to set
         * @returns {proto.CryptoGetClaimResponse} CryptoGetClaimResponse instance
         */
        CryptoGetClaimResponse.create = function create(properties) {
            return new CryptoGetClaimResponse(properties);
        };

        /**
         * Encodes the specified CryptoGetClaimResponse message. Does not implicitly {@link proto.CryptoGetClaimResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.CryptoGetClaimResponse
         * @static
         * @param {proto.ICryptoGetClaimResponse} m CryptoGetClaimResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CryptoGetClaimResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.claim != null && Object.hasOwnProperty.call(m, "claim"))
                $root.proto.Claim.encode(m.claim, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a CryptoGetClaimResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.CryptoGetClaimResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.CryptoGetClaimResponse} CryptoGetClaimResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CryptoGetClaimResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.CryptoGetClaimResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.claim = $root.proto.Claim.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return CryptoGetClaimResponse;
    })();

    proto.CryptoService = (function() {

        /**
         * Constructs a new CryptoService service.
         * @memberof proto
         * @classdesc Represents a CryptoService
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function CryptoService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (CryptoService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = CryptoService;

        /**
         * Creates new CryptoService service using the specified rpc implementation.
         * @function create
         * @memberof proto.CryptoService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {CryptoService} RPC service. Useful where requests and/or responses are streamed.
         */
        CryptoService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link proto.CryptoService#createAccount}.
         * @memberof proto.CryptoService
         * @typedef createAccountCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls createAccount.
         * @function createAccount
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.CryptoService.createAccountCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(CryptoService.prototype.createAccount = function createAccount(request, callback) {
            return this.rpcCall(createAccount, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "createAccount" });

        /**
         * Calls createAccount.
         * @function createAccount
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#updateAccount}.
         * @memberof proto.CryptoService
         * @typedef updateAccountCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls updateAccount.
         * @function updateAccount
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.CryptoService.updateAccountCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(CryptoService.prototype.updateAccount = function updateAccount(request, callback) {
            return this.rpcCall(updateAccount, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "updateAccount" });

        /**
         * Calls updateAccount.
         * @function updateAccount
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#cryptoTransfer}.
         * @memberof proto.CryptoService
         * @typedef cryptoTransferCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls cryptoTransfer.
         * @function cryptoTransfer
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.CryptoService.cryptoTransferCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(CryptoService.prototype.cryptoTransfer = function cryptoTransfer(request, callback) {
            return this.rpcCall(cryptoTransfer, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "cryptoTransfer" });

        /**
         * Calls cryptoTransfer.
         * @function cryptoTransfer
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#cryptoDelete}.
         * @memberof proto.CryptoService
         * @typedef cryptoDeleteCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls cryptoDelete.
         * @function cryptoDelete
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.CryptoService.cryptoDeleteCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(CryptoService.prototype.cryptoDelete = function cryptoDelete(request, callback) {
            return this.rpcCall(cryptoDelete, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "cryptoDelete" });

        /**
         * Calls cryptoDelete.
         * @function cryptoDelete
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#addLiveHash}.
         * @memberof proto.CryptoService
         * @typedef addLiveHashCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls addLiveHash.
         * @function addLiveHash
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.CryptoService.addLiveHashCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(CryptoService.prototype.addLiveHash = function addLiveHash(request, callback) {
            return this.rpcCall(addLiveHash, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "addLiveHash" });

        /**
         * Calls addLiveHash.
         * @function addLiveHash
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#deleteLiveHash}.
         * @memberof proto.CryptoService
         * @typedef deleteLiveHashCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls deleteLiveHash.
         * @function deleteLiveHash
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.CryptoService.deleteLiveHashCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(CryptoService.prototype.deleteLiveHash = function deleteLiveHash(request, callback) {
            return this.rpcCall(deleteLiveHash, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "deleteLiveHash" });

        /**
         * Calls deleteLiveHash.
         * @function deleteLiveHash
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#getLiveHash}.
         * @memberof proto.CryptoService
         * @typedef getLiveHashCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Calls getLiveHash.
         * @function getLiveHash
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.CryptoService.getLiveHashCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(CryptoService.prototype.getLiveHash = function getLiveHash(request, callback) {
            return this.rpcCall(getLiveHash, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getLiveHash" });

        /**
         * Calls getLiveHash.
         * @function getLiveHash
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#getAccountRecords}.
         * @memberof proto.CryptoService
         * @typedef getAccountRecordsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Calls getAccountRecords.
         * @function getAccountRecords
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.CryptoService.getAccountRecordsCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(CryptoService.prototype.getAccountRecords = function getAccountRecords(request, callback) {
            return this.rpcCall(getAccountRecords, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getAccountRecords" });

        /**
         * Calls getAccountRecords.
         * @function getAccountRecords
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#cryptoGetBalance}.
         * @memberof proto.CryptoService
         * @typedef cryptoGetBalanceCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Calls cryptoGetBalance.
         * @function cryptoGetBalance
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.CryptoService.cryptoGetBalanceCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(CryptoService.prototype.cryptoGetBalance = function cryptoGetBalance(request, callback) {
            return this.rpcCall(cryptoGetBalance, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "cryptoGetBalance" });

        /**
         * Calls cryptoGetBalance.
         * @function cryptoGetBalance
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#getAccountInfo}.
         * @memberof proto.CryptoService
         * @typedef getAccountInfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Calls getAccountInfo.
         * @function getAccountInfo
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.CryptoService.getAccountInfoCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(CryptoService.prototype.getAccountInfo = function getAccountInfo(request, callback) {
            return this.rpcCall(getAccountInfo, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getAccountInfo" });

        /**
         * Calls getAccountInfo.
         * @function getAccountInfo
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#getTransactionReceipts}.
         * @memberof proto.CryptoService
         * @typedef getTransactionReceiptsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Calls getTransactionReceipts.
         * @function getTransactionReceipts
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.CryptoService.getTransactionReceiptsCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(CryptoService.prototype.getTransactionReceipts = function getTransactionReceipts(request, callback) {
            return this.rpcCall(getTransactionReceipts, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getTransactionReceipts" });

        /**
         * Calls getTransactionReceipts.
         * @function getTransactionReceipts
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#getFastTransactionRecord}.
         * @memberof proto.CryptoService
         * @typedef getFastTransactionRecordCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Calls getFastTransactionRecord.
         * @function getFastTransactionRecord
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.CryptoService.getFastTransactionRecordCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(CryptoService.prototype.getFastTransactionRecord = function getFastTransactionRecord(request, callback) {
            return this.rpcCall(getFastTransactionRecord, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getFastTransactionRecord" });

        /**
         * Calls getFastTransactionRecord.
         * @function getFastTransactionRecord
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#getTxRecordByTxID}.
         * @memberof proto.CryptoService
         * @typedef getTxRecordByTxIDCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Calls getTxRecordByTxID.
         * @function getTxRecordByTxID
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.CryptoService.getTxRecordByTxIDCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(CryptoService.prototype.getTxRecordByTxID = function getTxRecordByTxID(request, callback) {
            return this.rpcCall(getTxRecordByTxID, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getTxRecordByTxID" });

        /**
         * Calls getTxRecordByTxID.
         * @function getTxRecordByTxID
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.CryptoService#getStakersByAccountID}.
         * @memberof proto.CryptoService
         * @typedef getStakersByAccountIDCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Calls getStakersByAccountID.
         * @function getStakersByAccountID
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.CryptoService.getStakersByAccountIDCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(CryptoService.prototype.getStakersByAccountID = function getStakersByAccountID(request, callback) {
            return this.rpcCall(getStakersByAccountID, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getStakersByAccountID" });

        /**
         * Calls getStakersByAccountID.
         * @function getStakersByAccountID
         * @memberof proto.CryptoService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        return CryptoService;
    })();

    proto.FileService = (function() {

        /**
         * Constructs a new FileService service.
         * @memberof proto
         * @classdesc Represents a FileService
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function FileService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (FileService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = FileService;

        /**
         * Creates new FileService service using the specified rpc implementation.
         * @function create
         * @memberof proto.FileService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {FileService} RPC service. Useful where requests and/or responses are streamed.
         */
        FileService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link proto.FileService#createFile}.
         * @memberof proto.FileService
         * @typedef createFileCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls createFile.
         * @function createFile
         * @memberof proto.FileService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.FileService.createFileCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(FileService.prototype.createFile = function createFile(request, callback) {
            return this.rpcCall(createFile, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "createFile" });

        /**
         * Calls createFile.
         * @function createFile
         * @memberof proto.FileService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.FileService#updateFile}.
         * @memberof proto.FileService
         * @typedef updateFileCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls updateFile.
         * @function updateFile
         * @memberof proto.FileService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.FileService.updateFileCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(FileService.prototype.updateFile = function updateFile(request, callback) {
            return this.rpcCall(updateFile, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "updateFile" });

        /**
         * Calls updateFile.
         * @function updateFile
         * @memberof proto.FileService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.FileService#deleteFile}.
         * @memberof proto.FileService
         * @typedef deleteFileCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls deleteFile.
         * @function deleteFile
         * @memberof proto.FileService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.FileService.deleteFileCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(FileService.prototype.deleteFile = function deleteFile(request, callback) {
            return this.rpcCall(deleteFile, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "deleteFile" });

        /**
         * Calls deleteFile.
         * @function deleteFile
         * @memberof proto.FileService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.FileService#appendContent}.
         * @memberof proto.FileService
         * @typedef appendContentCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls appendContent.
         * @function appendContent
         * @memberof proto.FileService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.FileService.appendContentCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(FileService.prototype.appendContent = function appendContent(request, callback) {
            return this.rpcCall(appendContent, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "appendContent" });

        /**
         * Calls appendContent.
         * @function appendContent
         * @memberof proto.FileService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.FileService#getFileContent}.
         * @memberof proto.FileService
         * @typedef getFileContentCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Calls getFileContent.
         * @function getFileContent
         * @memberof proto.FileService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.FileService.getFileContentCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(FileService.prototype.getFileContent = function getFileContent(request, callback) {
            return this.rpcCall(getFileContent, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getFileContent" });

        /**
         * Calls getFileContent.
         * @function getFileContent
         * @memberof proto.FileService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.FileService#getFileInfo}.
         * @memberof proto.FileService
         * @typedef getFileInfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Calls getFileInfo.
         * @function getFileInfo
         * @memberof proto.FileService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.FileService.getFileInfoCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(FileService.prototype.getFileInfo = function getFileInfo(request, callback) {
            return this.rpcCall(getFileInfo, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getFileInfo" });

        /**
         * Calls getFileInfo.
         * @function getFileInfo
         * @memberof proto.FileService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.FileService#systemDelete}.
         * @memberof proto.FileService
         * @typedef systemDeleteCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls systemDelete.
         * @function systemDelete
         * @memberof proto.FileService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.FileService.systemDeleteCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(FileService.prototype.systemDelete = function systemDelete(request, callback) {
            return this.rpcCall(systemDelete, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "systemDelete" });

        /**
         * Calls systemDelete.
         * @function systemDelete
         * @memberof proto.FileService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.FileService#systemUndelete}.
         * @memberof proto.FileService
         * @typedef systemUndeleteCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls systemUndelete.
         * @function systemUndelete
         * @memberof proto.FileService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.FileService.systemUndeleteCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(FileService.prototype.systemUndelete = function systemUndelete(request, callback) {
            return this.rpcCall(systemUndelete, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "systemUndelete" });

        /**
         * Calls systemUndelete.
         * @function systemUndelete
         * @memberof proto.FileService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        return FileService;
    })();

    proto.FreezeService = (function() {

        /**
         * Constructs a new FreezeService service.
         * @memberof proto
         * @classdesc Represents a FreezeService
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function FreezeService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (FreezeService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = FreezeService;

        /**
         * Creates new FreezeService service using the specified rpc implementation.
         * @function create
         * @memberof proto.FreezeService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {FreezeService} RPC service. Useful where requests and/or responses are streamed.
         */
        FreezeService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link proto.FreezeService#freeze}.
         * @memberof proto.FreezeService
         * @typedef freezeCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls freeze.
         * @function freeze
         * @memberof proto.FreezeService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.FreezeService.freezeCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(FreezeService.prototype.freeze = function freeze(request, callback) {
            return this.rpcCall(freeze, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "freeze" });

        /**
         * Calls freeze.
         * @function freeze
         * @memberof proto.FreezeService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        return FreezeService;
    })();

    proto.ConsensusTopicQuery = (function() {

        /**
         * Properties of a ConsensusTopicQuery.
         * @memberof proto
         * @interface IConsensusTopicQuery
         * @property {proto.ITopicID|null} [topicID] ConsensusTopicQuery topicID
         * @property {proto.ITimestamp|null} [consensusStartTime] ConsensusTopicQuery consensusStartTime
         * @property {proto.ITimestamp|null} [consensusEndTime] ConsensusTopicQuery consensusEndTime
         * @property {Long|null} [limit] ConsensusTopicQuery limit
         */

        /**
         * Constructs a new ConsensusTopicQuery.
         * @memberof proto
         * @classdesc Represents a ConsensusTopicQuery.
         * @implements IConsensusTopicQuery
         * @constructor
         * @param {proto.IConsensusTopicQuery=} [p] Properties to set
         */
        function ConsensusTopicQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ConsensusTopicQuery topicID.
         * @member {proto.ITopicID|null|undefined} topicID
         * @memberof proto.ConsensusTopicQuery
         * @instance
         */
        ConsensusTopicQuery.prototype.topicID = null;

        /**
         * ConsensusTopicQuery consensusStartTime.
         * @member {proto.ITimestamp|null|undefined} consensusStartTime
         * @memberof proto.ConsensusTopicQuery
         * @instance
         */
        ConsensusTopicQuery.prototype.consensusStartTime = null;

        /**
         * ConsensusTopicQuery consensusEndTime.
         * @member {proto.ITimestamp|null|undefined} consensusEndTime
         * @memberof proto.ConsensusTopicQuery
         * @instance
         */
        ConsensusTopicQuery.prototype.consensusEndTime = null;

        /**
         * ConsensusTopicQuery limit.
         * @member {Long} limit
         * @memberof proto.ConsensusTopicQuery
         * @instance
         */
        ConsensusTopicQuery.prototype.limit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new ConsensusTopicQuery instance using the specified properties.
         * @function create
         * @memberof proto.ConsensusTopicQuery
         * @static
         * @param {proto.IConsensusTopicQuery=} [properties] Properties to set
         * @returns {proto.ConsensusTopicQuery} ConsensusTopicQuery instance
         */
        ConsensusTopicQuery.create = function create(properties) {
            return new ConsensusTopicQuery(properties);
        };

        /**
         * Encodes the specified ConsensusTopicQuery message. Does not implicitly {@link proto.ConsensusTopicQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.ConsensusTopicQuery
         * @static
         * @param {proto.IConsensusTopicQuery} m ConsensusTopicQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConsensusTopicQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
                $root.proto.TopicID.encode(m.topicID, w.uint32(10).fork()).ldelim();
            if (m.consensusStartTime != null && Object.hasOwnProperty.call(m, "consensusStartTime"))
                $root.proto.Timestamp.encode(m.consensusStartTime, w.uint32(18).fork()).ldelim();
            if (m.consensusEndTime != null && Object.hasOwnProperty.call(m, "consensusEndTime"))
                $root.proto.Timestamp.encode(m.consensusEndTime, w.uint32(26).fork()).ldelim();
            if (m.limit != null && Object.hasOwnProperty.call(m, "limit"))
                w.uint32(32).uint64(m.limit);
            return w;
        };

        /**
         * Decodes a ConsensusTopicQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ConsensusTopicQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ConsensusTopicQuery} ConsensusTopicQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConsensusTopicQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ConsensusTopicQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.topicID = $root.proto.TopicID.decode(r, r.uint32());
                    break;
                case 2:
                    m.consensusStartTime = $root.proto.Timestamp.decode(r, r.uint32());
                    break;
                case 3:
                    m.consensusEndTime = $root.proto.Timestamp.decode(r, r.uint32());
                    break;
                case 4:
                    m.limit = r.uint64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ConsensusTopicQuery;
    })();

    proto.ConsensusTopicResponse = (function() {

        /**
         * Properties of a ConsensusTopicResponse.
         * @memberof proto
         * @interface IConsensusTopicResponse
         * @property {proto.ITimestamp|null} [consensusTimestamp] ConsensusTopicResponse consensusTimestamp
         * @property {Uint8Array|null} [message] ConsensusTopicResponse message
         * @property {Uint8Array|null} [runningHash] ConsensusTopicResponse runningHash
         * @property {Long|null} [sequenceNumber] ConsensusTopicResponse sequenceNumber
         * @property {Long|null} [runningHashVersion] ConsensusTopicResponse runningHashVersion
         * @property {proto.IConsensusMessageChunkInfo|null} [chunkInfo] ConsensusTopicResponse chunkInfo
         */

        /**
         * Constructs a new ConsensusTopicResponse.
         * @memberof proto
         * @classdesc Represents a ConsensusTopicResponse.
         * @implements IConsensusTopicResponse
         * @constructor
         * @param {proto.IConsensusTopicResponse=} [p] Properties to set
         */
        function ConsensusTopicResponse(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ConsensusTopicResponse consensusTimestamp.
         * @member {proto.ITimestamp|null|undefined} consensusTimestamp
         * @memberof proto.ConsensusTopicResponse
         * @instance
         */
        ConsensusTopicResponse.prototype.consensusTimestamp = null;

        /**
         * ConsensusTopicResponse message.
         * @member {Uint8Array} message
         * @memberof proto.ConsensusTopicResponse
         * @instance
         */
        ConsensusTopicResponse.prototype.message = $util.newBuffer([]);

        /**
         * ConsensusTopicResponse runningHash.
         * @member {Uint8Array} runningHash
         * @memberof proto.ConsensusTopicResponse
         * @instance
         */
        ConsensusTopicResponse.prototype.runningHash = $util.newBuffer([]);

        /**
         * ConsensusTopicResponse sequenceNumber.
         * @member {Long} sequenceNumber
         * @memberof proto.ConsensusTopicResponse
         * @instance
         */
        ConsensusTopicResponse.prototype.sequenceNumber = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ConsensusTopicResponse runningHashVersion.
         * @member {Long} runningHashVersion
         * @memberof proto.ConsensusTopicResponse
         * @instance
         */
        ConsensusTopicResponse.prototype.runningHashVersion = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ConsensusTopicResponse chunkInfo.
         * @member {proto.IConsensusMessageChunkInfo|null|undefined} chunkInfo
         * @memberof proto.ConsensusTopicResponse
         * @instance
         */
        ConsensusTopicResponse.prototype.chunkInfo = null;

        /**
         * Creates a new ConsensusTopicResponse instance using the specified properties.
         * @function create
         * @memberof proto.ConsensusTopicResponse
         * @static
         * @param {proto.IConsensusTopicResponse=} [properties] Properties to set
         * @returns {proto.ConsensusTopicResponse} ConsensusTopicResponse instance
         */
        ConsensusTopicResponse.create = function create(properties) {
            return new ConsensusTopicResponse(properties);
        };

        /**
         * Encodes the specified ConsensusTopicResponse message. Does not implicitly {@link proto.ConsensusTopicResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.ConsensusTopicResponse
         * @static
         * @param {proto.IConsensusTopicResponse} m ConsensusTopicResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConsensusTopicResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.consensusTimestamp != null && Object.hasOwnProperty.call(m, "consensusTimestamp"))
                $root.proto.Timestamp.encode(m.consensusTimestamp, w.uint32(10).fork()).ldelim();
            if (m.message != null && Object.hasOwnProperty.call(m, "message"))
                w.uint32(18).bytes(m.message);
            if (m.runningHash != null && Object.hasOwnProperty.call(m, "runningHash"))
                w.uint32(26).bytes(m.runningHash);
            if (m.sequenceNumber != null && Object.hasOwnProperty.call(m, "sequenceNumber"))
                w.uint32(32).uint64(m.sequenceNumber);
            if (m.runningHashVersion != null && Object.hasOwnProperty.call(m, "runningHashVersion"))
                w.uint32(40).uint64(m.runningHashVersion);
            if (m.chunkInfo != null && Object.hasOwnProperty.call(m, "chunkInfo"))
                $root.proto.ConsensusMessageChunkInfo.encode(m.chunkInfo, w.uint32(50).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a ConsensusTopicResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ConsensusTopicResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ConsensusTopicResponse} ConsensusTopicResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConsensusTopicResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ConsensusTopicResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.consensusTimestamp = $root.proto.Timestamp.decode(r, r.uint32());
                    break;
                case 2:
                    m.message = r.bytes();
                    break;
                case 3:
                    m.runningHash = r.bytes();
                    break;
                case 4:
                    m.sequenceNumber = r.uint64();
                    break;
                case 5:
                    m.runningHashVersion = r.uint64();
                    break;
                case 6:
                    m.chunkInfo = $root.proto.ConsensusMessageChunkInfo.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ConsensusTopicResponse;
    })();

    proto.MirrorConsensusService = (function() {

        /**
         * Constructs a new MirrorConsensusService service.
         * @memberof proto
         * @classdesc Represents a MirrorConsensusService
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function MirrorConsensusService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (MirrorConsensusService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = MirrorConsensusService;

        /**
         * Creates new MirrorConsensusService service using the specified rpc implementation.
         * @function create
         * @memberof proto.MirrorConsensusService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {MirrorConsensusService} RPC service. Useful where requests and/or responses are streamed.
         */
        MirrorConsensusService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link proto.MirrorConsensusService#subscribeTopic}.
         * @memberof proto.MirrorConsensusService
         * @typedef subscribeTopicCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.ConsensusTopicResponse} [response] ConsensusTopicResponse
         */

        /**
         * Calls subscribeTopic.
         * @function subscribeTopic
         * @memberof proto.MirrorConsensusService
         * @instance
         * @param {proto.IConsensusTopicQuery} request ConsensusTopicQuery message or plain object
         * @param {proto.MirrorConsensusService.subscribeTopicCallback} callback Node-style callback called with the error, if any, and ConsensusTopicResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(MirrorConsensusService.prototype.subscribeTopic = function subscribeTopic(request, callback) {
            return this.rpcCall(subscribeTopic, $root.proto.ConsensusTopicQuery, $root.proto.ConsensusTopicResponse, request, callback);
        }, "name", { value: "subscribeTopic" });

        /**
         * Calls subscribeTopic.
         * @function subscribeTopic
         * @memberof proto.MirrorConsensusService
         * @instance
         * @param {proto.IConsensusTopicQuery} request ConsensusTopicQuery message or plain object
         * @returns {Promise<proto.ConsensusTopicResponse>} Promise
         * @variation 2
         */

        return MirrorConsensusService;
    })();

    proto.NetworkService = (function() {

        /**
         * Constructs a new NetworkService service.
         * @memberof proto
         * @classdesc Represents a NetworkService
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function NetworkService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (NetworkService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = NetworkService;

        /**
         * Creates new NetworkService service using the specified rpc implementation.
         * @function create
         * @memberof proto.NetworkService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {NetworkService} RPC service. Useful where requests and/or responses are streamed.
         */
        NetworkService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link proto.NetworkService#getVersionInfo}.
         * @memberof proto.NetworkService
         * @typedef getVersionInfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Calls getVersionInfo.
         * @function getVersionInfo
         * @memberof proto.NetworkService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.NetworkService.getVersionInfoCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(NetworkService.prototype.getVersionInfo = function getVersionInfo(request, callback) {
            return this.rpcCall(getVersionInfo, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getVersionInfo" });

        /**
         * Calls getVersionInfo.
         * @function getVersionInfo
         * @memberof proto.NetworkService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.NetworkService#uncheckedSubmit}.
         * @memberof proto.NetworkService
         * @typedef uncheckedSubmitCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls uncheckedSubmit.
         * @function uncheckedSubmit
         * @memberof proto.NetworkService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.NetworkService.uncheckedSubmitCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(NetworkService.prototype.uncheckedSubmit = function uncheckedSubmit(request, callback) {
            return this.rpcCall(uncheckedSubmit, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "uncheckedSubmit" });

        /**
         * Calls uncheckedSubmit.
         * @function uncheckedSubmit
         * @memberof proto.NetworkService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        return NetworkService;
    })();

    proto.ScheduleService = (function() {

        /**
         * Constructs a new ScheduleService service.
         * @memberof proto
         * @classdesc Represents a ScheduleService
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function ScheduleService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (ScheduleService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ScheduleService;

        /**
         * Creates new ScheduleService service using the specified rpc implementation.
         * @function create
         * @memberof proto.ScheduleService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {ScheduleService} RPC service. Useful where requests and/or responses are streamed.
         */
        ScheduleService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link proto.ScheduleService#createSchedule}.
         * @memberof proto.ScheduleService
         * @typedef createScheduleCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls createSchedule.
         * @function createSchedule
         * @memberof proto.ScheduleService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.ScheduleService.createScheduleCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ScheduleService.prototype.createSchedule = function createSchedule(request, callback) {
            return this.rpcCall(createSchedule, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "createSchedule" });

        /**
         * Calls createSchedule.
         * @function createSchedule
         * @memberof proto.ScheduleService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.ScheduleService#signSchedule}.
         * @memberof proto.ScheduleService
         * @typedef signScheduleCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls signSchedule.
         * @function signSchedule
         * @memberof proto.ScheduleService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.ScheduleService.signScheduleCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ScheduleService.prototype.signSchedule = function signSchedule(request, callback) {
            return this.rpcCall(signSchedule, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "signSchedule" });

        /**
         * Calls signSchedule.
         * @function signSchedule
         * @memberof proto.ScheduleService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.ScheduleService#deleteSchedule}.
         * @memberof proto.ScheduleService
         * @typedef deleteScheduleCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls deleteSchedule.
         * @function deleteSchedule
         * @memberof proto.ScheduleService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.ScheduleService.deleteScheduleCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ScheduleService.prototype.deleteSchedule = function deleteSchedule(request, callback) {
            return this.rpcCall(deleteSchedule, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "deleteSchedule" });

        /**
         * Calls deleteSchedule.
         * @function deleteSchedule
         * @memberof proto.ScheduleService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.ScheduleService#getScheduleInfo}.
         * @memberof proto.ScheduleService
         * @typedef getScheduleInfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Calls getScheduleInfo.
         * @function getScheduleInfo
         * @memberof proto.ScheduleService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.ScheduleService.getScheduleInfoCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ScheduleService.prototype.getScheduleInfo = function getScheduleInfo(request, callback) {
            return this.rpcCall(getScheduleInfo, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getScheduleInfo" });

        /**
         * Calls getScheduleInfo.
         * @function getScheduleInfo
         * @memberof proto.ScheduleService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        return ScheduleService;
    })();

    proto.SmartContractService = (function() {

        /**
         * Constructs a new SmartContractService service.
         * @memberof proto
         * @classdesc Represents a SmartContractService
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function SmartContractService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (SmartContractService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = SmartContractService;

        /**
         * Creates new SmartContractService service using the specified rpc implementation.
         * @function create
         * @memberof proto.SmartContractService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {SmartContractService} RPC service. Useful where requests and/or responses are streamed.
         */
        SmartContractService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link proto.SmartContractService#createContract}.
         * @memberof proto.SmartContractService
         * @typedef createContractCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls createContract.
         * @function createContract
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.SmartContractService.createContractCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(SmartContractService.prototype.createContract = function createContract(request, callback) {
            return this.rpcCall(createContract, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "createContract" });

        /**
         * Calls createContract.
         * @function createContract
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.SmartContractService#updateContract}.
         * @memberof proto.SmartContractService
         * @typedef updateContractCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls updateContract.
         * @function updateContract
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.SmartContractService.updateContractCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(SmartContractService.prototype.updateContract = function updateContract(request, callback) {
            return this.rpcCall(updateContract, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "updateContract" });

        /**
         * Calls updateContract.
         * @function updateContract
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.SmartContractService#contractCallMethod}.
         * @memberof proto.SmartContractService
         * @typedef contractCallMethodCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls contractCallMethod.
         * @function contractCallMethod
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.SmartContractService.contractCallMethodCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(SmartContractService.prototype.contractCallMethod = function contractCallMethod(request, callback) {
            return this.rpcCall(contractCallMethod, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "contractCallMethod" });

        /**
         * Calls contractCallMethod.
         * @function contractCallMethod
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.SmartContractService#getContractInfo}.
         * @memberof proto.SmartContractService
         * @typedef getContractInfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Calls getContractInfo.
         * @function getContractInfo
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.SmartContractService.getContractInfoCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(SmartContractService.prototype.getContractInfo = function getContractInfo(request, callback) {
            return this.rpcCall(getContractInfo, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getContractInfo" });

        /**
         * Calls getContractInfo.
         * @function getContractInfo
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.SmartContractService#contractCallLocalMethod}.
         * @memberof proto.SmartContractService
         * @typedef contractCallLocalMethodCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Calls contractCallLocalMethod.
         * @function contractCallLocalMethod
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.SmartContractService.contractCallLocalMethodCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(SmartContractService.prototype.contractCallLocalMethod = function contractCallLocalMethod(request, callback) {
            return this.rpcCall(contractCallLocalMethod, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "contractCallLocalMethod" });

        /**
         * Calls contractCallLocalMethod.
         * @function contractCallLocalMethod
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.SmartContractService#contractGetBytecode}.
         * @memberof proto.SmartContractService
         * @typedef ContractGetBytecodeCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Calls ContractGetBytecode.
         * @function contractGetBytecode
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.SmartContractService.ContractGetBytecodeCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(SmartContractService.prototype.contractGetBytecode = function contractGetBytecode(request, callback) {
            return this.rpcCall(contractGetBytecode, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "ContractGetBytecode" });

        /**
         * Calls ContractGetBytecode.
         * @function contractGetBytecode
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.SmartContractService#getBySolidityID}.
         * @memberof proto.SmartContractService
         * @typedef getBySolidityIDCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Calls getBySolidityID.
         * @function getBySolidityID
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.SmartContractService.getBySolidityIDCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(SmartContractService.prototype.getBySolidityID = function getBySolidityID(request, callback) {
            return this.rpcCall(getBySolidityID, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getBySolidityID" });

        /**
         * Calls getBySolidityID.
         * @function getBySolidityID
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.SmartContractService#getTxRecordByContractID}.
         * @memberof proto.SmartContractService
         * @typedef getTxRecordByContractIDCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Calls getTxRecordByContractID.
         * @function getTxRecordByContractID
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.SmartContractService.getTxRecordByContractIDCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(SmartContractService.prototype.getTxRecordByContractID = function getTxRecordByContractID(request, callback) {
            return this.rpcCall(getTxRecordByContractID, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getTxRecordByContractID" });

        /**
         * Calls getTxRecordByContractID.
         * @function getTxRecordByContractID
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.SmartContractService#deleteContract}.
         * @memberof proto.SmartContractService
         * @typedef deleteContractCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls deleteContract.
         * @function deleteContract
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.SmartContractService.deleteContractCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(SmartContractService.prototype.deleteContract = function deleteContract(request, callback) {
            return this.rpcCall(deleteContract, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "deleteContract" });

        /**
         * Calls deleteContract.
         * @function deleteContract
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.SmartContractService#systemDelete}.
         * @memberof proto.SmartContractService
         * @typedef systemDeleteCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls systemDelete.
         * @function systemDelete
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.SmartContractService.systemDeleteCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(SmartContractService.prototype.systemDelete = function systemDelete(request, callback) {
            return this.rpcCall(systemDelete, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "systemDelete" });

        /**
         * Calls systemDelete.
         * @function systemDelete
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.SmartContractService#systemUndelete}.
         * @memberof proto.SmartContractService
         * @typedef systemUndeleteCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls systemUndelete.
         * @function systemUndelete
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.SmartContractService.systemUndeleteCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(SmartContractService.prototype.systemUndelete = function systemUndelete(request, callback) {
            return this.rpcCall(systemUndelete, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "systemUndelete" });

        /**
         * Calls systemUndelete.
         * @function systemUndelete
         * @memberof proto.SmartContractService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        return SmartContractService;
    })();

    proto.ThrottleGroup = (function() {

        /**
         * Properties of a ThrottleGroup.
         * @memberof proto
         * @interface IThrottleGroup
         * @property {Array.<proto.HederaFunctionality>|null} [operations] ThrottleGroup operations
         * @property {Long|null} [milliOpsPerSec] ThrottleGroup milliOpsPerSec
         */

        /**
         * Constructs a new ThrottleGroup.
         * @memberof proto
         * @classdesc Represents a ThrottleGroup.
         * @implements IThrottleGroup
         * @constructor
         * @param {proto.IThrottleGroup=} [p] Properties to set
         */
        function ThrottleGroup(p) {
            this.operations = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ThrottleGroup operations.
         * @member {Array.<proto.HederaFunctionality>} operations
         * @memberof proto.ThrottleGroup
         * @instance
         */
        ThrottleGroup.prototype.operations = $util.emptyArray;

        /**
         * ThrottleGroup milliOpsPerSec.
         * @member {Long} milliOpsPerSec
         * @memberof proto.ThrottleGroup
         * @instance
         */
        ThrottleGroup.prototype.milliOpsPerSec = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new ThrottleGroup instance using the specified properties.
         * @function create
         * @memberof proto.ThrottleGroup
         * @static
         * @param {proto.IThrottleGroup=} [properties] Properties to set
         * @returns {proto.ThrottleGroup} ThrottleGroup instance
         */
        ThrottleGroup.create = function create(properties) {
            return new ThrottleGroup(properties);
        };

        /**
         * Encodes the specified ThrottleGroup message. Does not implicitly {@link proto.ThrottleGroup.verify|verify} messages.
         * @function encode
         * @memberof proto.ThrottleGroup
         * @static
         * @param {proto.IThrottleGroup} m ThrottleGroup message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ThrottleGroup.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.operations != null && m.operations.length) {
                w.uint32(10).fork();
                for (var i = 0; i < m.operations.length; ++i)
                    w.int32(m.operations[i]);
                w.ldelim();
            }
            if (m.milliOpsPerSec != null && Object.hasOwnProperty.call(m, "milliOpsPerSec"))
                w.uint32(16).uint64(m.milliOpsPerSec);
            return w;
        };

        /**
         * Decodes a ThrottleGroup message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ThrottleGroup
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ThrottleGroup} ThrottleGroup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ThrottleGroup.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ThrottleGroup();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    if (!(m.operations && m.operations.length))
                        m.operations = [];
                    if ((t & 7) === 2) {
                        var c2 = r.uint32() + r.pos;
                        while (r.pos < c2)
                            m.operations.push(r.int32());
                    } else
                        m.operations.push(r.int32());
                    break;
                case 2:
                    m.milliOpsPerSec = r.uint64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ThrottleGroup;
    })();

    proto.ThrottleBucket = (function() {

        /**
         * Properties of a ThrottleBucket.
         * @memberof proto
         * @interface IThrottleBucket
         * @property {string|null} [name] ThrottleBucket name
         * @property {Long|null} [burstPeriodMs] ThrottleBucket burstPeriodMs
         * @property {Array.<proto.IThrottleGroup>|null} [throttleGroups] ThrottleBucket throttleGroups
         */

        /**
         * Constructs a new ThrottleBucket.
         * @memberof proto
         * @classdesc Represents a ThrottleBucket.
         * @implements IThrottleBucket
         * @constructor
         * @param {proto.IThrottleBucket=} [p] Properties to set
         */
        function ThrottleBucket(p) {
            this.throttleGroups = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ThrottleBucket name.
         * @member {string} name
         * @memberof proto.ThrottleBucket
         * @instance
         */
        ThrottleBucket.prototype.name = "";

        /**
         * ThrottleBucket burstPeriodMs.
         * @member {Long} burstPeriodMs
         * @memberof proto.ThrottleBucket
         * @instance
         */
        ThrottleBucket.prototype.burstPeriodMs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ThrottleBucket throttleGroups.
         * @member {Array.<proto.IThrottleGroup>} throttleGroups
         * @memberof proto.ThrottleBucket
         * @instance
         */
        ThrottleBucket.prototype.throttleGroups = $util.emptyArray;

        /**
         * Creates a new ThrottleBucket instance using the specified properties.
         * @function create
         * @memberof proto.ThrottleBucket
         * @static
         * @param {proto.IThrottleBucket=} [properties] Properties to set
         * @returns {proto.ThrottleBucket} ThrottleBucket instance
         */
        ThrottleBucket.create = function create(properties) {
            return new ThrottleBucket(properties);
        };

        /**
         * Encodes the specified ThrottleBucket message. Does not implicitly {@link proto.ThrottleBucket.verify|verify} messages.
         * @function encode
         * @memberof proto.ThrottleBucket
         * @static
         * @param {proto.IThrottleBucket} m ThrottleBucket message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ThrottleBucket.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.name != null && Object.hasOwnProperty.call(m, "name"))
                w.uint32(10).string(m.name);
            if (m.burstPeriodMs != null && Object.hasOwnProperty.call(m, "burstPeriodMs"))
                w.uint32(16).uint64(m.burstPeriodMs);
            if (m.throttleGroups != null && m.throttleGroups.length) {
                for (var i = 0; i < m.throttleGroups.length; ++i)
                    $root.proto.ThrottleGroup.encode(m.throttleGroups[i], w.uint32(26).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a ThrottleBucket message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ThrottleBucket
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ThrottleBucket} ThrottleBucket
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ThrottleBucket.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ThrottleBucket();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.name = r.string();
                    break;
                case 2:
                    m.burstPeriodMs = r.uint64();
                    break;
                case 3:
                    if (!(m.throttleGroups && m.throttleGroups.length))
                        m.throttleGroups = [];
                    m.throttleGroups.push($root.proto.ThrottleGroup.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ThrottleBucket;
    })();

    proto.ThrottleDefinitions = (function() {

        /**
         * Properties of a ThrottleDefinitions.
         * @memberof proto
         * @interface IThrottleDefinitions
         * @property {Array.<proto.IThrottleBucket>|null} [throttleBuckets] ThrottleDefinitions throttleBuckets
         */

        /**
         * Constructs a new ThrottleDefinitions.
         * @memberof proto
         * @classdesc Represents a ThrottleDefinitions.
         * @implements IThrottleDefinitions
         * @constructor
         * @param {proto.IThrottleDefinitions=} [p] Properties to set
         */
        function ThrottleDefinitions(p) {
            this.throttleBuckets = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * ThrottleDefinitions throttleBuckets.
         * @member {Array.<proto.IThrottleBucket>} throttleBuckets
         * @memberof proto.ThrottleDefinitions
         * @instance
         */
        ThrottleDefinitions.prototype.throttleBuckets = $util.emptyArray;

        /**
         * Creates a new ThrottleDefinitions instance using the specified properties.
         * @function create
         * @memberof proto.ThrottleDefinitions
         * @static
         * @param {proto.IThrottleDefinitions=} [properties] Properties to set
         * @returns {proto.ThrottleDefinitions} ThrottleDefinitions instance
         */
        ThrottleDefinitions.create = function create(properties) {
            return new ThrottleDefinitions(properties);
        };

        /**
         * Encodes the specified ThrottleDefinitions message. Does not implicitly {@link proto.ThrottleDefinitions.verify|verify} messages.
         * @function encode
         * @memberof proto.ThrottleDefinitions
         * @static
         * @param {proto.IThrottleDefinitions} m ThrottleDefinitions message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ThrottleDefinitions.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.throttleBuckets != null && m.throttleBuckets.length) {
                for (var i = 0; i < m.throttleBuckets.length; ++i)
                    $root.proto.ThrottleBucket.encode(m.throttleBuckets[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a ThrottleDefinitions message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ThrottleDefinitions
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.ThrottleDefinitions} ThrottleDefinitions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ThrottleDefinitions.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.ThrottleDefinitions();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    if (!(m.throttleBuckets && m.throttleBuckets.length))
                        m.throttleBuckets = [];
                    m.throttleBuckets.push($root.proto.ThrottleBucket.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return ThrottleDefinitions;
    })();

    proto.TokenGetAccountNftInfoQuery = (function() {

        /**
         * Properties of a TokenGetAccountNftInfoQuery.
         * @memberof proto
         * @interface ITokenGetAccountNftInfoQuery
         * @property {proto.IQueryHeader|null} [header] TokenGetAccountNftInfoQuery header
         * @property {proto.IAccountID|null} [accountID] TokenGetAccountNftInfoQuery accountID
         * @property {Long|null} [start] TokenGetAccountNftInfoQuery start
         * @property {Long|null} [end] TokenGetAccountNftInfoQuery end
         */

        /**
         * Constructs a new TokenGetAccountNftInfoQuery.
         * @memberof proto
         * @classdesc Represents a TokenGetAccountNftInfoQuery.
         * @implements ITokenGetAccountNftInfoQuery
         * @constructor
         * @param {proto.ITokenGetAccountNftInfoQuery=} [p] Properties to set
         */
        function TokenGetAccountNftInfoQuery(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TokenGetAccountNftInfoQuery header.
         * @member {proto.IQueryHeader|null|undefined} header
         * @memberof proto.TokenGetAccountNftInfoQuery
         * @instance
         */
        TokenGetAccountNftInfoQuery.prototype.header = null;

        /**
         * TokenGetAccountNftInfoQuery accountID.
         * @member {proto.IAccountID|null|undefined} accountID
         * @memberof proto.TokenGetAccountNftInfoQuery
         * @instance
         */
        TokenGetAccountNftInfoQuery.prototype.accountID = null;

        /**
         * TokenGetAccountNftInfoQuery start.
         * @member {Long} start
         * @memberof proto.TokenGetAccountNftInfoQuery
         * @instance
         */
        TokenGetAccountNftInfoQuery.prototype.start = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TokenGetAccountNftInfoQuery end.
         * @member {Long} end
         * @memberof proto.TokenGetAccountNftInfoQuery
         * @instance
         */
        TokenGetAccountNftInfoQuery.prototype.end = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new TokenGetAccountNftInfoQuery instance using the specified properties.
         * @function create
         * @memberof proto.TokenGetAccountNftInfoQuery
         * @static
         * @param {proto.ITokenGetAccountNftInfoQuery=} [properties] Properties to set
         * @returns {proto.TokenGetAccountNftInfoQuery} TokenGetAccountNftInfoQuery instance
         */
        TokenGetAccountNftInfoQuery.create = function create(properties) {
            return new TokenGetAccountNftInfoQuery(properties);
        };

        /**
         * Encodes the specified TokenGetAccountNftInfoQuery message. Does not implicitly {@link proto.TokenGetAccountNftInfoQuery.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenGetAccountNftInfoQuery
         * @static
         * @param {proto.ITokenGetAccountNftInfoQuery} m TokenGetAccountNftInfoQuery message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenGetAccountNftInfoQuery.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.QueryHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.accountID != null && Object.hasOwnProperty.call(m, "accountID"))
                $root.proto.AccountID.encode(m.accountID, w.uint32(18).fork()).ldelim();
            if (m.start != null && Object.hasOwnProperty.call(m, "start"))
                w.uint32(24).int64(m.start);
            if (m.end != null && Object.hasOwnProperty.call(m, "end"))
                w.uint32(32).int64(m.end);
            return w;
        };

        /**
         * Decodes a TokenGetAccountNftInfoQuery message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenGetAccountNftInfoQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenGetAccountNftInfoQuery} TokenGetAccountNftInfoQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenGetAccountNftInfoQuery.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenGetAccountNftInfoQuery();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.QueryHeader.decode(r, r.uint32());
                    break;
                case 2:
                    m.accountID = $root.proto.AccountID.decode(r, r.uint32());
                    break;
                case 3:
                    m.start = r.int64();
                    break;
                case 4:
                    m.end = r.int64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TokenGetAccountNftInfoQuery;
    })();

    proto.TokenGetAccountNftInfoResponse = (function() {

        /**
         * Properties of a TokenGetAccountNftInfoResponse.
         * @memberof proto
         * @interface ITokenGetAccountNftInfoResponse
         * @property {proto.IResponseHeader|null} [header] TokenGetAccountNftInfoResponse header
         * @property {Array.<proto.ITokenNftInfo>|null} [nfts] TokenGetAccountNftInfoResponse nfts
         */

        /**
         * Constructs a new TokenGetAccountNftInfoResponse.
         * @memberof proto
         * @classdesc Represents a TokenGetAccountNftInfoResponse.
         * @implements ITokenGetAccountNftInfoResponse
         * @constructor
         * @param {proto.ITokenGetAccountNftInfoResponse=} [p] Properties to set
         */
        function TokenGetAccountNftInfoResponse(p) {
            this.nfts = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TokenGetAccountNftInfoResponse header.
         * @member {proto.IResponseHeader|null|undefined} header
         * @memberof proto.TokenGetAccountNftInfoResponse
         * @instance
         */
        TokenGetAccountNftInfoResponse.prototype.header = null;

        /**
         * TokenGetAccountNftInfoResponse nfts.
         * @member {Array.<proto.ITokenNftInfo>} nfts
         * @memberof proto.TokenGetAccountNftInfoResponse
         * @instance
         */
        TokenGetAccountNftInfoResponse.prototype.nfts = $util.emptyArray;

        /**
         * Creates a new TokenGetAccountNftInfoResponse instance using the specified properties.
         * @function create
         * @memberof proto.TokenGetAccountNftInfoResponse
         * @static
         * @param {proto.ITokenGetAccountNftInfoResponse=} [properties] Properties to set
         * @returns {proto.TokenGetAccountNftInfoResponse} TokenGetAccountNftInfoResponse instance
         */
        TokenGetAccountNftInfoResponse.create = function create(properties) {
            return new TokenGetAccountNftInfoResponse(properties);
        };

        /**
         * Encodes the specified TokenGetAccountNftInfoResponse message. Does not implicitly {@link proto.TokenGetAccountNftInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenGetAccountNftInfoResponse
         * @static
         * @param {proto.ITokenGetAccountNftInfoResponse} m TokenGetAccountNftInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenGetAccountNftInfoResponse.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.header != null && Object.hasOwnProperty.call(m, "header"))
                $root.proto.ResponseHeader.encode(m.header, w.uint32(10).fork()).ldelim();
            if (m.nfts != null && m.nfts.length) {
                for (var i = 0; i < m.nfts.length; ++i)
                    $root.proto.TokenNftInfo.encode(m.nfts[i], w.uint32(18).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TokenGetAccountNftInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenGetAccountNftInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenGetAccountNftInfoResponse} TokenGetAccountNftInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenGetAccountNftInfoResponse.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenGetAccountNftInfoResponse();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.header = $root.proto.ResponseHeader.decode(r, r.uint32());
                    break;
                case 2:
                    if (!(m.nfts && m.nfts.length))
                        m.nfts = [];
                    m.nfts.push($root.proto.TokenNftInfo.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TokenGetAccountNftInfoResponse;
    })();

    proto.TokenService = (function() {

        /**
         * Constructs a new TokenService service.
         * @memberof proto
         * @classdesc Represents a TokenService
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function TokenService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (TokenService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = TokenService;

        /**
         * Creates new TokenService service using the specified rpc implementation.
         * @function create
         * @memberof proto.TokenService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {TokenService} RPC service. Useful where requests and/or responses are streamed.
         */
        TokenService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link proto.TokenService#createToken}.
         * @memberof proto.TokenService
         * @typedef createTokenCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls createToken.
         * @function createToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.createTokenCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TokenService.prototype.createToken = function createToken(request, callback) {
            return this.rpcCall(createToken, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "createToken" });

        /**
         * Calls createToken.
         * @function createToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#updateToken}.
         * @memberof proto.TokenService
         * @typedef updateTokenCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls updateToken.
         * @function updateToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.updateTokenCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TokenService.prototype.updateToken = function updateToken(request, callback) {
            return this.rpcCall(updateToken, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "updateToken" });

        /**
         * Calls updateToken.
         * @function updateToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#mintToken}.
         * @memberof proto.TokenService
         * @typedef mintTokenCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls mintToken.
         * @function mintToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.mintTokenCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TokenService.prototype.mintToken = function mintToken(request, callback) {
            return this.rpcCall(mintToken, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "mintToken" });

        /**
         * Calls mintToken.
         * @function mintToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#burnToken}.
         * @memberof proto.TokenService
         * @typedef burnTokenCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls burnToken.
         * @function burnToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.burnTokenCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TokenService.prototype.burnToken = function burnToken(request, callback) {
            return this.rpcCall(burnToken, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "burnToken" });

        /**
         * Calls burnToken.
         * @function burnToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#deleteToken}.
         * @memberof proto.TokenService
         * @typedef deleteTokenCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls deleteToken.
         * @function deleteToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.deleteTokenCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TokenService.prototype.deleteToken = function deleteToken(request, callback) {
            return this.rpcCall(deleteToken, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "deleteToken" });

        /**
         * Calls deleteToken.
         * @function deleteToken
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#wipeTokenAccount}.
         * @memberof proto.TokenService
         * @typedef wipeTokenAccountCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls wipeTokenAccount.
         * @function wipeTokenAccount
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.wipeTokenAccountCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TokenService.prototype.wipeTokenAccount = function wipeTokenAccount(request, callback) {
            return this.rpcCall(wipeTokenAccount, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "wipeTokenAccount" });

        /**
         * Calls wipeTokenAccount.
         * @function wipeTokenAccount
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#freezeTokenAccount}.
         * @memberof proto.TokenService
         * @typedef freezeTokenAccountCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls freezeTokenAccount.
         * @function freezeTokenAccount
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.freezeTokenAccountCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TokenService.prototype.freezeTokenAccount = function freezeTokenAccount(request, callback) {
            return this.rpcCall(freezeTokenAccount, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "freezeTokenAccount" });

        /**
         * Calls freezeTokenAccount.
         * @function freezeTokenAccount
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#unfreezeTokenAccount}.
         * @memberof proto.TokenService
         * @typedef unfreezeTokenAccountCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls unfreezeTokenAccount.
         * @function unfreezeTokenAccount
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.unfreezeTokenAccountCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TokenService.prototype.unfreezeTokenAccount = function unfreezeTokenAccount(request, callback) {
            return this.rpcCall(unfreezeTokenAccount, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "unfreezeTokenAccount" });

        /**
         * Calls unfreezeTokenAccount.
         * @function unfreezeTokenAccount
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#grantKycToTokenAccount}.
         * @memberof proto.TokenService
         * @typedef grantKycToTokenAccountCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls grantKycToTokenAccount.
         * @function grantKycToTokenAccount
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.grantKycToTokenAccountCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TokenService.prototype.grantKycToTokenAccount = function grantKycToTokenAccount(request, callback) {
            return this.rpcCall(grantKycToTokenAccount, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "grantKycToTokenAccount" });

        /**
         * Calls grantKycToTokenAccount.
         * @function grantKycToTokenAccount
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#revokeKycFromTokenAccount}.
         * @memberof proto.TokenService
         * @typedef revokeKycFromTokenAccountCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls revokeKycFromTokenAccount.
         * @function revokeKycFromTokenAccount
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.revokeKycFromTokenAccountCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TokenService.prototype.revokeKycFromTokenAccount = function revokeKycFromTokenAccount(request, callback) {
            return this.rpcCall(revokeKycFromTokenAccount, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "revokeKycFromTokenAccount" });

        /**
         * Calls revokeKycFromTokenAccount.
         * @function revokeKycFromTokenAccount
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#associateTokens}.
         * @memberof proto.TokenService
         * @typedef associateTokensCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls associateTokens.
         * @function associateTokens
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.associateTokensCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TokenService.prototype.associateTokens = function associateTokens(request, callback) {
            return this.rpcCall(associateTokens, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "associateTokens" });

        /**
         * Calls associateTokens.
         * @function associateTokens
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#dissociateTokens}.
         * @memberof proto.TokenService
         * @typedef dissociateTokensCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls dissociateTokens.
         * @function dissociateTokens
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.dissociateTokensCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TokenService.prototype.dissociateTokens = function dissociateTokens(request, callback) {
            return this.rpcCall(dissociateTokens, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "dissociateTokens" });

        /**
         * Calls dissociateTokens.
         * @function dissociateTokens
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#updateTokenFeeSchedule}.
         * @memberof proto.TokenService
         * @typedef updateTokenFeeScheduleCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.TransactionResponse} [response] TransactionResponse
         */

        /**
         * Calls updateTokenFeeSchedule.
         * @function updateTokenFeeSchedule
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @param {proto.TokenService.updateTokenFeeScheduleCallback} callback Node-style callback called with the error, if any, and TransactionResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TokenService.prototype.updateTokenFeeSchedule = function updateTokenFeeSchedule(request, callback) {
            return this.rpcCall(updateTokenFeeSchedule, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "updateTokenFeeSchedule" });

        /**
         * Calls updateTokenFeeSchedule.
         * @function updateTokenFeeSchedule
         * @memberof proto.TokenService
         * @instance
         * @param {proto.ITransaction} request Transaction message or plain object
         * @returns {Promise<proto.TransactionResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#getTokenInfo}.
         * @memberof proto.TokenService
         * @typedef getTokenInfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Calls getTokenInfo.
         * @function getTokenInfo
         * @memberof proto.TokenService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.TokenService.getTokenInfoCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TokenService.prototype.getTokenInfo = function getTokenInfo(request, callback) {
            return this.rpcCall(getTokenInfo, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getTokenInfo" });

        /**
         * Calls getTokenInfo.
         * @function getTokenInfo
         * @memberof proto.TokenService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#getAccountNftInfos}.
         * @memberof proto.TokenService
         * @typedef getAccountNftInfosCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Calls getAccountNftInfos.
         * @function getAccountNftInfos
         * @memberof proto.TokenService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.TokenService.getAccountNftInfosCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TokenService.prototype.getAccountNftInfos = function getAccountNftInfos(request, callback) {
            return this.rpcCall(getAccountNftInfos, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getAccountNftInfos" });

        /**
         * Calls getAccountNftInfos.
         * @function getAccountNftInfos
         * @memberof proto.TokenService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#getTokenNftInfo}.
         * @memberof proto.TokenService
         * @typedef getTokenNftInfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Calls getTokenNftInfo.
         * @function getTokenNftInfo
         * @memberof proto.TokenService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.TokenService.getTokenNftInfoCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TokenService.prototype.getTokenNftInfo = function getTokenNftInfo(request, callback) {
            return this.rpcCall(getTokenNftInfo, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getTokenNftInfo" });

        /**
         * Calls getTokenNftInfo.
         * @function getTokenNftInfo
         * @memberof proto.TokenService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link proto.TokenService#getTokenNftInfos}.
         * @memberof proto.TokenService
         * @typedef getTokenNftInfosCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {proto.Response} [response] Response
         */

        /**
         * Calls getTokenNftInfos.
         * @function getTokenNftInfos
         * @memberof proto.TokenService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @param {proto.TokenService.getTokenNftInfosCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(TokenService.prototype.getTokenNftInfos = function getTokenNftInfos(request, callback) {
            return this.rpcCall(getTokenNftInfos, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getTokenNftInfos" });

        /**
         * Calls getTokenNftInfos.
         * @function getTokenNftInfos
         * @memberof proto.TokenService
         * @instance
         * @param {proto.IQuery} request Query message or plain object
         * @returns {Promise<proto.Response>} Promise
         * @variation 2
         */

        return TokenService;
    })();

    proto.TokenTransfersTransactionBody = (function() {

        /**
         * Properties of a TokenTransfersTransactionBody.
         * @memberof proto
         * @interface ITokenTransfersTransactionBody
         * @property {Array.<proto.ITokenTransferList>|null} [tokenTransfers] TokenTransfersTransactionBody tokenTransfers
         */

        /**
         * Constructs a new TokenTransfersTransactionBody.
         * @memberof proto
         * @classdesc Represents a TokenTransfersTransactionBody.
         * @implements ITokenTransfersTransactionBody
         * @constructor
         * @param {proto.ITokenTransfersTransactionBody=} [p] Properties to set
         */
        function TokenTransfersTransactionBody(p) {
            this.tokenTransfers = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TokenTransfersTransactionBody tokenTransfers.
         * @member {Array.<proto.ITokenTransferList>} tokenTransfers
         * @memberof proto.TokenTransfersTransactionBody
         * @instance
         */
        TokenTransfersTransactionBody.prototype.tokenTransfers = $util.emptyArray;

        /**
         * Creates a new TokenTransfersTransactionBody instance using the specified properties.
         * @function create
         * @memberof proto.TokenTransfersTransactionBody
         * @static
         * @param {proto.ITokenTransfersTransactionBody=} [properties] Properties to set
         * @returns {proto.TokenTransfersTransactionBody} TokenTransfersTransactionBody instance
         */
        TokenTransfersTransactionBody.create = function create(properties) {
            return new TokenTransfersTransactionBody(properties);
        };

        /**
         * Encodes the specified TokenTransfersTransactionBody message. Does not implicitly {@link proto.TokenTransfersTransactionBody.verify|verify} messages.
         * @function encode
         * @memberof proto.TokenTransfersTransactionBody
         * @static
         * @param {proto.ITokenTransfersTransactionBody} m TokenTransfersTransactionBody message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenTransfersTransactionBody.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.tokenTransfers != null && m.tokenTransfers.length) {
                for (var i = 0; i < m.tokenTransfers.length; ++i)
                    $root.proto.TokenTransferList.encode(m.tokenTransfers[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TokenTransfersTransactionBody message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TokenTransfersTransactionBody
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TokenTransfersTransactionBody} TokenTransfersTransactionBody
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenTransfersTransactionBody.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TokenTransfersTransactionBody();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    if (!(m.tokenTransfers && m.tokenTransfers.length))
                        m.tokenTransfers = [];
                    m.tokenTransfers.push($root.proto.TokenTransferList.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TokenTransfersTransactionBody;
    })();

    proto.SignedTransaction = (function() {

        /**
         * Properties of a SignedTransaction.
         * @memberof proto
         * @interface ISignedTransaction
         * @property {Uint8Array|null} [bodyBytes] SignedTransaction bodyBytes
         * @property {proto.ISignatureMap|null} [sigMap] SignedTransaction sigMap
         */

        /**
         * Constructs a new SignedTransaction.
         * @memberof proto
         * @classdesc Represents a SignedTransaction.
         * @implements ISignedTransaction
         * @constructor
         * @param {proto.ISignedTransaction=} [p] Properties to set
         */
        function SignedTransaction(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * SignedTransaction bodyBytes.
         * @member {Uint8Array} bodyBytes
         * @memberof proto.SignedTransaction
         * @instance
         */
        SignedTransaction.prototype.bodyBytes = $util.newBuffer([]);

        /**
         * SignedTransaction sigMap.
         * @member {proto.ISignatureMap|null|undefined} sigMap
         * @memberof proto.SignedTransaction
         * @instance
         */
        SignedTransaction.prototype.sigMap = null;

        /**
         * Creates a new SignedTransaction instance using the specified properties.
         * @function create
         * @memberof proto.SignedTransaction
         * @static
         * @param {proto.ISignedTransaction=} [properties] Properties to set
         * @returns {proto.SignedTransaction} SignedTransaction instance
         */
        SignedTransaction.create = function create(properties) {
            return new SignedTransaction(properties);
        };

        /**
         * Encodes the specified SignedTransaction message. Does not implicitly {@link proto.SignedTransaction.verify|verify} messages.
         * @function encode
         * @memberof proto.SignedTransaction
         * @static
         * @param {proto.ISignedTransaction} m SignedTransaction message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignedTransaction.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.bodyBytes != null && Object.hasOwnProperty.call(m, "bodyBytes"))
                w.uint32(10).bytes(m.bodyBytes);
            if (m.sigMap != null && Object.hasOwnProperty.call(m, "sigMap"))
                $root.proto.SignatureMap.encode(m.sigMap, w.uint32(18).fork()).ldelim();
            return w;
        };

        /**
         * Decodes a SignedTransaction message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SignedTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.SignedTransaction} SignedTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignedTransaction.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.SignedTransaction();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.bodyBytes = r.bytes();
                    break;
                case 2:
                    m.sigMap = $root.proto.SignatureMap.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return SignedTransaction;
    })();

    proto.TransactionList = (function() {

        /**
         * Properties of a TransactionList.
         * @memberof proto
         * @interface ITransactionList
         * @property {Array.<proto.ITransaction>|null} [transactionList] TransactionList transactionList
         */

        /**
         * Constructs a new TransactionList.
         * @memberof proto
         * @classdesc Represents a TransactionList.
         * @implements ITransactionList
         * @constructor
         * @param {proto.ITransactionList=} [p] Properties to set
         */
        function TransactionList(p) {
            this.transactionList = [];
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * TransactionList transactionList.
         * @member {Array.<proto.ITransaction>} transactionList
         * @memberof proto.TransactionList
         * @instance
         */
        TransactionList.prototype.transactionList = $util.emptyArray;

        /**
         * Creates a new TransactionList instance using the specified properties.
         * @function create
         * @memberof proto.TransactionList
         * @static
         * @param {proto.ITransactionList=} [properties] Properties to set
         * @returns {proto.TransactionList} TransactionList instance
         */
        TransactionList.create = function create(properties) {
            return new TransactionList(properties);
        };

        /**
         * Encodes the specified TransactionList message. Does not implicitly {@link proto.TransactionList.verify|verify} messages.
         * @function encode
         * @memberof proto.TransactionList
         * @static
         * @param {proto.ITransactionList} m TransactionList message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionList.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.transactionList != null && m.transactionList.length) {
                for (var i = 0; i < m.transactionList.length; ++i)
                    $root.proto.Transaction.encode(m.transactionList[i], w.uint32(10).fork()).ldelim();
            }
            return w;
        };

        /**
         * Decodes a TransactionList message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TransactionList
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.TransactionList} TransactionList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionList.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.TransactionList();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    if (!(m.transactionList && m.transactionList.length))
                        m.transactionList = [];
                    m.transactionList.push($root.proto.Transaction.decode(r, r.uint32()));
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return TransactionList;
    })();

    proto.DoubleValue = (function() {

        /**
         * Properties of a DoubleValue.
         * @memberof proto
         * @interface IDoubleValue
         * @property {number|null} [value] DoubleValue value
         */

        /**
         * Constructs a new DoubleValue.
         * @memberof proto
         * @classdesc Represents a DoubleValue.
         * @implements IDoubleValue
         * @constructor
         * @param {proto.IDoubleValue=} [p] Properties to set
         */
        function DoubleValue(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * DoubleValue value.
         * @member {number} value
         * @memberof proto.DoubleValue
         * @instance
         */
        DoubleValue.prototype.value = 0;

        /**
         * Creates a new DoubleValue instance using the specified properties.
         * @function create
         * @memberof proto.DoubleValue
         * @static
         * @param {proto.IDoubleValue=} [properties] Properties to set
         * @returns {proto.DoubleValue} DoubleValue instance
         */
        DoubleValue.create = function create(properties) {
            return new DoubleValue(properties);
        };

        /**
         * Encodes the specified DoubleValue message. Does not implicitly {@link proto.DoubleValue.verify|verify} messages.
         * @function encode
         * @memberof proto.DoubleValue
         * @static
         * @param {proto.IDoubleValue} m DoubleValue message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DoubleValue.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                w.uint32(9).double(m.value);
            return w;
        };

        /**
         * Decodes a DoubleValue message from the specified reader or buffer.
         * @function decode
         * @memberof proto.DoubleValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.DoubleValue} DoubleValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DoubleValue.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.DoubleValue();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.value = r.double();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return DoubleValue;
    })();

    proto.FloatValue = (function() {

        /**
         * Properties of a FloatValue.
         * @memberof proto
         * @interface IFloatValue
         * @property {number|null} [value] FloatValue value
         */

        /**
         * Constructs a new FloatValue.
         * @memberof proto
         * @classdesc Represents a FloatValue.
         * @implements IFloatValue
         * @constructor
         * @param {proto.IFloatValue=} [p] Properties to set
         */
        function FloatValue(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * FloatValue value.
         * @member {number} value
         * @memberof proto.FloatValue
         * @instance
         */
        FloatValue.prototype.value = 0;

        /**
         * Creates a new FloatValue instance using the specified properties.
         * @function create
         * @memberof proto.FloatValue
         * @static
         * @param {proto.IFloatValue=} [properties] Properties to set
         * @returns {proto.FloatValue} FloatValue instance
         */
        FloatValue.create = function create(properties) {
            return new FloatValue(properties);
        };

        /**
         * Encodes the specified FloatValue message. Does not implicitly {@link proto.FloatValue.verify|verify} messages.
         * @function encode
         * @memberof proto.FloatValue
         * @static
         * @param {proto.IFloatValue} m FloatValue message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FloatValue.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                w.uint32(13).float(m.value);
            return w;
        };

        /**
         * Decodes a FloatValue message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FloatValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.FloatValue} FloatValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FloatValue.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.FloatValue();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.value = r.float();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return FloatValue;
    })();

    proto.Int64Value = (function() {

        /**
         * Properties of an Int64Value.
         * @memberof proto
         * @interface IInt64Value
         * @property {Long|null} [value] Int64Value value
         */

        /**
         * Constructs a new Int64Value.
         * @memberof proto
         * @classdesc Represents an Int64Value.
         * @implements IInt64Value
         * @constructor
         * @param {proto.IInt64Value=} [p] Properties to set
         */
        function Int64Value(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Int64Value value.
         * @member {Long} value
         * @memberof proto.Int64Value
         * @instance
         */
        Int64Value.prototype.value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Int64Value instance using the specified properties.
         * @function create
         * @memberof proto.Int64Value
         * @static
         * @param {proto.IInt64Value=} [properties] Properties to set
         * @returns {proto.Int64Value} Int64Value instance
         */
        Int64Value.create = function create(properties) {
            return new Int64Value(properties);
        };

        /**
         * Encodes the specified Int64Value message. Does not implicitly {@link proto.Int64Value.verify|verify} messages.
         * @function encode
         * @memberof proto.Int64Value
         * @static
         * @param {proto.IInt64Value} m Int64Value message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Int64Value.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                w.uint32(8).int64(m.value);
            return w;
        };

        /**
         * Decodes an Int64Value message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Int64Value
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.Int64Value} Int64Value
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Int64Value.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.Int64Value();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.value = r.int64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return Int64Value;
    })();

    proto.UInt64Value = (function() {

        /**
         * Properties of a UInt64Value.
         * @memberof proto
         * @interface IUInt64Value
         * @property {Long|null} [value] UInt64Value value
         */

        /**
         * Constructs a new UInt64Value.
         * @memberof proto
         * @classdesc Represents a UInt64Value.
         * @implements IUInt64Value
         * @constructor
         * @param {proto.IUInt64Value=} [p] Properties to set
         */
        function UInt64Value(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * UInt64Value value.
         * @member {Long} value
         * @memberof proto.UInt64Value
         * @instance
         */
        UInt64Value.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new UInt64Value instance using the specified properties.
         * @function create
         * @memberof proto.UInt64Value
         * @static
         * @param {proto.IUInt64Value=} [properties] Properties to set
         * @returns {proto.UInt64Value} UInt64Value instance
         */
        UInt64Value.create = function create(properties) {
            return new UInt64Value(properties);
        };

        /**
         * Encodes the specified UInt64Value message. Does not implicitly {@link proto.UInt64Value.verify|verify} messages.
         * @function encode
         * @memberof proto.UInt64Value
         * @static
         * @param {proto.IUInt64Value} m UInt64Value message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UInt64Value.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                w.uint32(8).uint64(m.value);
            return w;
        };

        /**
         * Decodes a UInt64Value message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UInt64Value
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.UInt64Value} UInt64Value
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UInt64Value.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.UInt64Value();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.value = r.uint64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return UInt64Value;
    })();

    proto.Int32Value = (function() {

        /**
         * Properties of an Int32Value.
         * @memberof proto
         * @interface IInt32Value
         * @property {number|null} [value] Int32Value value
         */

        /**
         * Constructs a new Int32Value.
         * @memberof proto
         * @classdesc Represents an Int32Value.
         * @implements IInt32Value
         * @constructor
         * @param {proto.IInt32Value=} [p] Properties to set
         */
        function Int32Value(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * Int32Value value.
         * @member {number} value
         * @memberof proto.Int32Value
         * @instance
         */
        Int32Value.prototype.value = 0;

        /**
         * Creates a new Int32Value instance using the specified properties.
         * @function create
         * @memberof proto.Int32Value
         * @static
         * @param {proto.IInt32Value=} [properties] Properties to set
         * @returns {proto.Int32Value} Int32Value instance
         */
        Int32Value.create = function create(properties) {
            return new Int32Value(properties);
        };

        /**
         * Encodes the specified Int32Value message. Does not implicitly {@link proto.Int32Value.verify|verify} messages.
         * @function encode
         * @memberof proto.Int32Value
         * @static
         * @param {proto.IInt32Value} m Int32Value message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Int32Value.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                w.uint32(8).int32(m.value);
            return w;
        };

        /**
         * Decodes an Int32Value message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Int32Value
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.Int32Value} Int32Value
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Int32Value.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.Int32Value();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.value = r.int32();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return Int32Value;
    })();

    proto.UInt32Value = (function() {

        /**
         * Properties of a UInt32Value.
         * @memberof proto
         * @interface IUInt32Value
         * @property {number|null} [value] UInt32Value value
         */

        /**
         * Constructs a new UInt32Value.
         * @memberof proto
         * @classdesc Represents a UInt32Value.
         * @implements IUInt32Value
         * @constructor
         * @param {proto.IUInt32Value=} [p] Properties to set
         */
        function UInt32Value(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * UInt32Value value.
         * @member {number} value
         * @memberof proto.UInt32Value
         * @instance
         */
        UInt32Value.prototype.value = 0;

        /**
         * Creates a new UInt32Value instance using the specified properties.
         * @function create
         * @memberof proto.UInt32Value
         * @static
         * @param {proto.IUInt32Value=} [properties] Properties to set
         * @returns {proto.UInt32Value} UInt32Value instance
         */
        UInt32Value.create = function create(properties) {
            return new UInt32Value(properties);
        };

        /**
         * Encodes the specified UInt32Value message. Does not implicitly {@link proto.UInt32Value.verify|verify} messages.
         * @function encode
         * @memberof proto.UInt32Value
         * @static
         * @param {proto.IUInt32Value} m UInt32Value message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UInt32Value.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                w.uint32(8).uint32(m.value);
            return w;
        };

        /**
         * Decodes a UInt32Value message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UInt32Value
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.UInt32Value} UInt32Value
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UInt32Value.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.UInt32Value();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.value = r.uint32();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return UInt32Value;
    })();

    proto.BoolValue = (function() {

        /**
         * Properties of a BoolValue.
         * @memberof proto
         * @interface IBoolValue
         * @property {boolean|null} [value] BoolValue value
         */

        /**
         * Constructs a new BoolValue.
         * @memberof proto
         * @classdesc Represents a BoolValue.
         * @implements IBoolValue
         * @constructor
         * @param {proto.IBoolValue=} [p] Properties to set
         */
        function BoolValue(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * BoolValue value.
         * @member {boolean} value
         * @memberof proto.BoolValue
         * @instance
         */
        BoolValue.prototype.value = false;

        /**
         * Creates a new BoolValue instance using the specified properties.
         * @function create
         * @memberof proto.BoolValue
         * @static
         * @param {proto.IBoolValue=} [properties] Properties to set
         * @returns {proto.BoolValue} BoolValue instance
         */
        BoolValue.create = function create(properties) {
            return new BoolValue(properties);
        };

        /**
         * Encodes the specified BoolValue message. Does not implicitly {@link proto.BoolValue.verify|verify} messages.
         * @function encode
         * @memberof proto.BoolValue
         * @static
         * @param {proto.IBoolValue} m BoolValue message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BoolValue.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                w.uint32(8).bool(m.value);
            return w;
        };

        /**
         * Decodes a BoolValue message from the specified reader or buffer.
         * @function decode
         * @memberof proto.BoolValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.BoolValue} BoolValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BoolValue.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.BoolValue();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.value = r.bool();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return BoolValue;
    })();

    proto.StringValue = (function() {

        /**
         * Properties of a StringValue.
         * @memberof proto
         * @interface IStringValue
         * @property {string|null} [value] StringValue value
         */

        /**
         * Constructs a new StringValue.
         * @memberof proto
         * @classdesc Represents a StringValue.
         * @implements IStringValue
         * @constructor
         * @param {proto.IStringValue=} [p] Properties to set
         */
        function StringValue(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * StringValue value.
         * @member {string} value
         * @memberof proto.StringValue
         * @instance
         */
        StringValue.prototype.value = "";

        /**
         * Creates a new StringValue instance using the specified properties.
         * @function create
         * @memberof proto.StringValue
         * @static
         * @param {proto.IStringValue=} [properties] Properties to set
         * @returns {proto.StringValue} StringValue instance
         */
        StringValue.create = function create(properties) {
            return new StringValue(properties);
        };

        /**
         * Encodes the specified StringValue message. Does not implicitly {@link proto.StringValue.verify|verify} messages.
         * @function encode
         * @memberof proto.StringValue
         * @static
         * @param {proto.IStringValue} m StringValue message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StringValue.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                w.uint32(10).string(m.value);
            return w;
        };

        /**
         * Decodes a StringValue message from the specified reader or buffer.
         * @function decode
         * @memberof proto.StringValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.StringValue} StringValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StringValue.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.StringValue();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.value = r.string();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return StringValue;
    })();

    proto.BytesValue = (function() {

        /**
         * Properties of a BytesValue.
         * @memberof proto
         * @interface IBytesValue
         * @property {Uint8Array|null} [value] BytesValue value
         */

        /**
         * Constructs a new BytesValue.
         * @memberof proto
         * @classdesc Represents a BytesValue.
         * @implements IBytesValue
         * @constructor
         * @param {proto.IBytesValue=} [p] Properties to set
         */
        function BytesValue(p) {
            if (p)
                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                    if (p[ks[i]] != null)
                        this[ks[i]] = p[ks[i]];
        }

        /**
         * BytesValue value.
         * @member {Uint8Array} value
         * @memberof proto.BytesValue
         * @instance
         */
        BytesValue.prototype.value = $util.newBuffer([]);

        /**
         * Creates a new BytesValue instance using the specified properties.
         * @function create
         * @memberof proto.BytesValue
         * @static
         * @param {proto.IBytesValue=} [properties] Properties to set
         * @returns {proto.BytesValue} BytesValue instance
         */
        BytesValue.create = function create(properties) {
            return new BytesValue(properties);
        };

        /**
         * Encodes the specified BytesValue message. Does not implicitly {@link proto.BytesValue.verify|verify} messages.
         * @function encode
         * @memberof proto.BytesValue
         * @static
         * @param {proto.IBytesValue} m BytesValue message or plain object to encode
         * @param {$protobuf.Writer} [w] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BytesValue.encode = function encode(m, w) {
            if (!w)
                w = $Writer.create();
            if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                w.uint32(10).bytes(m.value);
            return w;
        };

        /**
         * Decodes a BytesValue message from the specified reader or buffer.
         * @function decode
         * @memberof proto.BytesValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
         * @param {number} [l] Message length if known beforehand
         * @returns {proto.BytesValue} BytesValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BytesValue.decode = function decode(r, l) {
            if (!(r instanceof $Reader))
                r = $Reader.create(r);
            var c = l === undefined ? r.len : r.pos + l, m = new $root.proto.BytesValue();
            while (r.pos < c) {
                var t = r.uint32();
                switch (t >>> 3) {
                case 1:
                    m.value = r.bytes();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
                }
            }
            return m;
        };

        return BytesValue;
    })();

    return proto;
})();

export const google = $root.google = (() => {

    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    const google = {};

    google.protobuf = (function() {

        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        const protobuf = {};

        protobuf.DoubleValue = (function() {

            /**
             * Properties of a DoubleValue.
             * @memberof google.protobuf
             * @interface IDoubleValue
             * @property {number|null} [value] DoubleValue value
             */

            /**
             * Constructs a new DoubleValue.
             * @memberof google.protobuf
             * @classdesc Represents a DoubleValue.
             * @implements IDoubleValue
             * @constructor
             * @param {google.protobuf.IDoubleValue=} [p] Properties to set
             */
            function DoubleValue(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * DoubleValue value.
             * @member {number} value
             * @memberof google.protobuf.DoubleValue
             * @instance
             */
            DoubleValue.prototype.value = 0;

            /**
             * Creates a new DoubleValue instance using the specified properties.
             * @function create
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {google.protobuf.IDoubleValue=} [properties] Properties to set
             * @returns {google.protobuf.DoubleValue} DoubleValue instance
             */
            DoubleValue.create = function create(properties) {
                return new DoubleValue(properties);
            };

            /**
             * Encodes the specified DoubleValue message. Does not implicitly {@link google.protobuf.DoubleValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {google.protobuf.IDoubleValue} m DoubleValue message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DoubleValue.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                    w.uint32(9).double(m.value);
                return w;
            };

            /**
             * Decodes a DoubleValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {google.protobuf.DoubleValue} DoubleValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DoubleValue.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.DoubleValue();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.value = r.double();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return DoubleValue;
        })();

        protobuf.FloatValue = (function() {

            /**
             * Properties of a FloatValue.
             * @memberof google.protobuf
             * @interface IFloatValue
             * @property {number|null} [value] FloatValue value
             */

            /**
             * Constructs a new FloatValue.
             * @memberof google.protobuf
             * @classdesc Represents a FloatValue.
             * @implements IFloatValue
             * @constructor
             * @param {google.protobuf.IFloatValue=} [p] Properties to set
             */
            function FloatValue(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * FloatValue value.
             * @member {number} value
             * @memberof google.protobuf.FloatValue
             * @instance
             */
            FloatValue.prototype.value = 0;

            /**
             * Creates a new FloatValue instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {google.protobuf.IFloatValue=} [properties] Properties to set
             * @returns {google.protobuf.FloatValue} FloatValue instance
             */
            FloatValue.create = function create(properties) {
                return new FloatValue(properties);
            };

            /**
             * Encodes the specified FloatValue message. Does not implicitly {@link google.protobuf.FloatValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {google.protobuf.IFloatValue} m FloatValue message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FloatValue.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                    w.uint32(13).float(m.value);
                return w;
            };

            /**
             * Decodes a FloatValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {google.protobuf.FloatValue} FloatValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FloatValue.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.FloatValue();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.value = r.float();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return FloatValue;
        })();

        protobuf.Int64Value = (function() {

            /**
             * Properties of an Int64Value.
             * @memberof google.protobuf
             * @interface IInt64Value
             * @property {Long|null} [value] Int64Value value
             */

            /**
             * Constructs a new Int64Value.
             * @memberof google.protobuf
             * @classdesc Represents an Int64Value.
             * @implements IInt64Value
             * @constructor
             * @param {google.protobuf.IInt64Value=} [p] Properties to set
             */
            function Int64Value(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * Int64Value value.
             * @member {Long} value
             * @memberof google.protobuf.Int64Value
             * @instance
             */
            Int64Value.prototype.value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new Int64Value instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {google.protobuf.IInt64Value=} [properties] Properties to set
             * @returns {google.protobuf.Int64Value} Int64Value instance
             */
            Int64Value.create = function create(properties) {
                return new Int64Value(properties);
            };

            /**
             * Encodes the specified Int64Value message. Does not implicitly {@link google.protobuf.Int64Value.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {google.protobuf.IInt64Value} m Int64Value message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Int64Value.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                    w.uint32(8).int64(m.value);
                return w;
            };

            /**
             * Decodes an Int64Value message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {google.protobuf.Int64Value} Int64Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Int64Value.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.Int64Value();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.value = r.int64();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return Int64Value;
        })();

        protobuf.UInt64Value = (function() {

            /**
             * Properties of a UInt64Value.
             * @memberof google.protobuf
             * @interface IUInt64Value
             * @property {Long|null} [value] UInt64Value value
             */

            /**
             * Constructs a new UInt64Value.
             * @memberof google.protobuf
             * @classdesc Represents a UInt64Value.
             * @implements IUInt64Value
             * @constructor
             * @param {google.protobuf.IUInt64Value=} [p] Properties to set
             */
            function UInt64Value(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * UInt64Value value.
             * @member {Long} value
             * @memberof google.protobuf.UInt64Value
             * @instance
             */
            UInt64Value.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new UInt64Value instance using the specified properties.
             * @function create
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {google.protobuf.IUInt64Value=} [properties] Properties to set
             * @returns {google.protobuf.UInt64Value} UInt64Value instance
             */
            UInt64Value.create = function create(properties) {
                return new UInt64Value(properties);
            };

            /**
             * Encodes the specified UInt64Value message. Does not implicitly {@link google.protobuf.UInt64Value.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {google.protobuf.IUInt64Value} m UInt64Value message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UInt64Value.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                    w.uint32(8).uint64(m.value);
                return w;
            };

            /**
             * Decodes a UInt64Value message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {google.protobuf.UInt64Value} UInt64Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UInt64Value.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.UInt64Value();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.value = r.uint64();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return UInt64Value;
        })();

        protobuf.Int32Value = (function() {

            /**
             * Properties of an Int32Value.
             * @memberof google.protobuf
             * @interface IInt32Value
             * @property {number|null} [value] Int32Value value
             */

            /**
             * Constructs a new Int32Value.
             * @memberof google.protobuf
             * @classdesc Represents an Int32Value.
             * @implements IInt32Value
             * @constructor
             * @param {google.protobuf.IInt32Value=} [p] Properties to set
             */
            function Int32Value(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * Int32Value value.
             * @member {number} value
             * @memberof google.protobuf.Int32Value
             * @instance
             */
            Int32Value.prototype.value = 0;

            /**
             * Creates a new Int32Value instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {google.protobuf.IInt32Value=} [properties] Properties to set
             * @returns {google.protobuf.Int32Value} Int32Value instance
             */
            Int32Value.create = function create(properties) {
                return new Int32Value(properties);
            };

            /**
             * Encodes the specified Int32Value message. Does not implicitly {@link google.protobuf.Int32Value.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {google.protobuf.IInt32Value} m Int32Value message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Int32Value.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                    w.uint32(8).int32(m.value);
                return w;
            };

            /**
             * Decodes an Int32Value message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {google.protobuf.Int32Value} Int32Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Int32Value.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.Int32Value();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.value = r.int32();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return Int32Value;
        })();

        protobuf.UInt32Value = (function() {

            /**
             * Properties of a UInt32Value.
             * @memberof google.protobuf
             * @interface IUInt32Value
             * @property {number|null} [value] UInt32Value value
             */

            /**
             * Constructs a new UInt32Value.
             * @memberof google.protobuf
             * @classdesc Represents a UInt32Value.
             * @implements IUInt32Value
             * @constructor
             * @param {google.protobuf.IUInt32Value=} [p] Properties to set
             */
            function UInt32Value(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * UInt32Value value.
             * @member {number} value
             * @memberof google.protobuf.UInt32Value
             * @instance
             */
            UInt32Value.prototype.value = 0;

            /**
             * Creates a new UInt32Value instance using the specified properties.
             * @function create
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {google.protobuf.IUInt32Value=} [properties] Properties to set
             * @returns {google.protobuf.UInt32Value} UInt32Value instance
             */
            UInt32Value.create = function create(properties) {
                return new UInt32Value(properties);
            };

            /**
             * Encodes the specified UInt32Value message. Does not implicitly {@link google.protobuf.UInt32Value.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {google.protobuf.IUInt32Value} m UInt32Value message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UInt32Value.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                    w.uint32(8).uint32(m.value);
                return w;
            };

            /**
             * Decodes a UInt32Value message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {google.protobuf.UInt32Value} UInt32Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UInt32Value.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.UInt32Value();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.value = r.uint32();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return UInt32Value;
        })();

        protobuf.BoolValue = (function() {

            /**
             * Properties of a BoolValue.
             * @memberof google.protobuf
             * @interface IBoolValue
             * @property {boolean|null} [value] BoolValue value
             */

            /**
             * Constructs a new BoolValue.
             * @memberof google.protobuf
             * @classdesc Represents a BoolValue.
             * @implements IBoolValue
             * @constructor
             * @param {google.protobuf.IBoolValue=} [p] Properties to set
             */
            function BoolValue(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * BoolValue value.
             * @member {boolean} value
             * @memberof google.protobuf.BoolValue
             * @instance
             */
            BoolValue.prototype.value = false;

            /**
             * Creates a new BoolValue instance using the specified properties.
             * @function create
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {google.protobuf.IBoolValue=} [properties] Properties to set
             * @returns {google.protobuf.BoolValue} BoolValue instance
             */
            BoolValue.create = function create(properties) {
                return new BoolValue(properties);
            };

            /**
             * Encodes the specified BoolValue message. Does not implicitly {@link google.protobuf.BoolValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {google.protobuf.IBoolValue} m BoolValue message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BoolValue.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                    w.uint32(8).bool(m.value);
                return w;
            };

            /**
             * Decodes a BoolValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {google.protobuf.BoolValue} BoolValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BoolValue.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.BoolValue();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.value = r.bool();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return BoolValue;
        })();

        protobuf.StringValue = (function() {

            /**
             * Properties of a StringValue.
             * @memberof google.protobuf
             * @interface IStringValue
             * @property {string|null} [value] StringValue value
             */

            /**
             * Constructs a new StringValue.
             * @memberof google.protobuf
             * @classdesc Represents a StringValue.
             * @implements IStringValue
             * @constructor
             * @param {google.protobuf.IStringValue=} [p] Properties to set
             */
            function StringValue(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * StringValue value.
             * @member {string} value
             * @memberof google.protobuf.StringValue
             * @instance
             */
            StringValue.prototype.value = "";

            /**
             * Creates a new StringValue instance using the specified properties.
             * @function create
             * @memberof google.protobuf.StringValue
             * @static
             * @param {google.protobuf.IStringValue=} [properties] Properties to set
             * @returns {google.protobuf.StringValue} StringValue instance
             */
            StringValue.create = function create(properties) {
                return new StringValue(properties);
            };

            /**
             * Encodes the specified StringValue message. Does not implicitly {@link google.protobuf.StringValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.StringValue
             * @static
             * @param {google.protobuf.IStringValue} m StringValue message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StringValue.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                    w.uint32(10).string(m.value);
                return w;
            };

            /**
             * Decodes a StringValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.StringValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {google.protobuf.StringValue} StringValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StringValue.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.StringValue();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.value = r.string();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return StringValue;
        })();

        protobuf.BytesValue = (function() {

            /**
             * Properties of a BytesValue.
             * @memberof google.protobuf
             * @interface IBytesValue
             * @property {Uint8Array|null} [value] BytesValue value
             */

            /**
             * Constructs a new BytesValue.
             * @memberof google.protobuf
             * @classdesc Represents a BytesValue.
             * @implements IBytesValue
             * @constructor
             * @param {google.protobuf.IBytesValue=} [p] Properties to set
             */
            function BytesValue(p) {
                if (p)
                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                        if (p[ks[i]] != null)
                            this[ks[i]] = p[ks[i]];
            }

            /**
             * BytesValue value.
             * @member {Uint8Array} value
             * @memberof google.protobuf.BytesValue
             * @instance
             */
            BytesValue.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new BytesValue instance using the specified properties.
             * @function create
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {google.protobuf.IBytesValue=} [properties] Properties to set
             * @returns {google.protobuf.BytesValue} BytesValue instance
             */
            BytesValue.create = function create(properties) {
                return new BytesValue(properties);
            };

            /**
             * Encodes the specified BytesValue message. Does not implicitly {@link google.protobuf.BytesValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {google.protobuf.IBytesValue} m BytesValue message or plain object to encode
             * @param {$protobuf.Writer} [w] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BytesValue.encode = function encode(m, w) {
                if (!w)
                    w = $Writer.create();
                if (m.value != null && Object.hasOwnProperty.call(m, "value"))
                    w.uint32(10).bytes(m.value);
                return w;
            };

            /**
             * Decodes a BytesValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
             * @param {number} [l] Message length if known beforehand
             * @returns {google.protobuf.BytesValue} BytesValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BytesValue.decode = function decode(r, l) {
                if (!(r instanceof $Reader))
                    r = $Reader.create(r);
                var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.BytesValue();
                while (r.pos < c) {
                    var t = r.uint32();
                    switch (t >>> 3) {
                    case 1:
                        m.value = r.bytes();
                        break;
                    default:
                        r.skipType(t & 7);
                        break;
                    }
                }
                return m;
            };

            return BytesValue;
        })();

        return protobuf;
    })();

    return google;
})();

export { $root as default };
